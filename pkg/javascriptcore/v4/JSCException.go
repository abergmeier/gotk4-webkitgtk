// Code generated by girgen. DO NOT EDIT.

package javascriptcore

import (
	"runtime"
	"unsafe"

	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: javascriptcoregtk-4.0 webkit2gtk-4.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <jsc/jsc.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.jsc_exception_get_type()), F: marshalExceptioner},
	})
}

type Exception struct {
	*externglib.Object
}

func wrapException(obj *externglib.Object) *Exception {
	return &Exception{
		Object: obj,
	}
}

func marshalExceptioner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapException(obj), nil
}

// NewException: create a new CException in context with message.
func NewException(context *Context, message string) *Exception {
	var _arg1 *C.JSCContext   // out
	var _arg2 *C.char         // out
	var _cret *C.JSCException // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.jsc_exception_new(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(message)

	var _exception *Exception // out

	_exception = wrapException(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _exception
}

// NewExceptionWithName: create a new CException in context with name and
// message.
func NewExceptionWithName(context *Context, name string, message string) *Exception {
	var _arg1 *C.JSCContext   // out
	var _arg2 *C.char         // out
	var _arg3 *C.char         // out
	var _cret *C.JSCException // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.jsc_exception_new_with_name(_arg1, _arg2, _arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(name)
	runtime.KeepAlive(message)

	var _exception *Exception // out

	_exception = wrapException(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _exception
}

// BacktraceString: get a string with the exception backtrace.
func (exception *Exception) BacktraceString() string {
	var _arg0 *C.JSCException // out
	var _cret *C.char         // in

	_arg0 = (*C.JSCException)(unsafe.Pointer(exception.Native()))

	_cret = C.jsc_exception_get_backtrace_string(_arg0)
	runtime.KeepAlive(exception)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// ColumnNumber: get the column number at which exception happened.
func (exception *Exception) ColumnNumber() uint {
	var _arg0 *C.JSCException // out
	var _cret C.guint         // in

	_arg0 = (*C.JSCException)(unsafe.Pointer(exception.Native()))

	_cret = C.jsc_exception_get_column_number(_arg0)
	runtime.KeepAlive(exception)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// LineNumber: get the line number at which exception happened.
func (exception *Exception) LineNumber() uint {
	var _arg0 *C.JSCException // out
	var _cret C.guint         // in

	_arg0 = (*C.JSCException)(unsafe.Pointer(exception.Native()))

	_cret = C.jsc_exception_get_line_number(_arg0)
	runtime.KeepAlive(exception)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Message: get the error message of exception.
func (exception *Exception) Message() string {
	var _arg0 *C.JSCException // out
	var _cret *C.char         // in

	_arg0 = (*C.JSCException)(unsafe.Pointer(exception.Native()))

	_cret = C.jsc_exception_get_message(_arg0)
	runtime.KeepAlive(exception)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Name: get the error name of exception
func (exception *Exception) Name() string {
	var _arg0 *C.JSCException // out
	var _cret *C.char         // in

	_arg0 = (*C.JSCException)(unsafe.Pointer(exception.Native()))

	_cret = C.jsc_exception_get_name(_arg0)
	runtime.KeepAlive(exception)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// SourceURI: get the source URI of exception.
func (exception *Exception) SourceURI() string {
	var _arg0 *C.JSCException // out
	var _cret *C.char         // in

	_arg0 = (*C.JSCException)(unsafe.Pointer(exception.Native()))

	_cret = C.jsc_exception_get_source_uri(_arg0)
	runtime.KeepAlive(exception)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Report: return a report message of exception, containing all the possible
// details such us source URI, line, column and backtrace, and formatted to be
// printed.
func (exception *Exception) Report() string {
	var _arg0 *C.JSCException // out
	var _cret *C.char         // in

	_arg0 = (*C.JSCException)(unsafe.Pointer(exception.Native()))

	_cret = C.jsc_exception_report(_arg0)
	runtime.KeepAlive(exception)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// String: get the string representation of exception error.
func (exception *Exception) String() string {
	var _arg0 *C.JSCException // out
	var _cret *C.char         // in

	_arg0 = (*C.JSCException)(unsafe.Pointer(exception.Native()))

	_cret = C.jsc_exception_to_string(_arg0)
	runtime.KeepAlive(exception)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}
