// Code generated by girgen. DO NOT EDIT.

package javascriptcore

import (
	"runtime"
	"unsafe"

	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <jsc/jsc.h>
import "C"

// glib.Type values for JSCException.go.
var GTypeException = externglib.Type(C.jsc_exception_get_type())

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: GTypeException, F: marshalException},
	})
}

// ExceptionOverrider contains methods that are overridable.
type ExceptionOverrider interface {
}

type Exception struct {
	_ [0]func() // equal guard
	*externglib.Object
}

var (
	_ externglib.Objector = (*Exception)(nil)
)

func classInitExceptioner(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

}

func wrapException(obj *externglib.Object) *Exception {
	return &Exception{
		Object: obj,
	}
}

func marshalException(p uintptr) (interface{}, error) {
	return wrapException(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewException: create a new CException in context with message.
//
// The function takes the following parameters:
//
//    - context: CContext.
//    - message: error message.
//
// The function returns the following values:
//
//    - exception: new CException.
//
func NewException(context *Context, message string) *Exception {
	var _arg1 *C.JSCContext   // out
	var _arg2 *C.char         // out
	var _cret *C.JSCException // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.jsc_exception_new(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(message)

	var _exception *Exception // out

	_exception = wrapException(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _exception
}

// NewExceptionWithName: create a new CException in context with name and
// message.
//
// The function takes the following parameters:
//
//    - context: CContext.
//    - name: error name.
//    - message: error message.
//
// The function returns the following values:
//
//    - exception: new CException.
//
func NewExceptionWithName(context *Context, name, message string) *Exception {
	var _arg1 *C.JSCContext   // out
	var _arg2 *C.char         // out
	var _arg3 *C.char         // out
	var _cret *C.JSCException // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.jsc_exception_new_with_name(_arg1, _arg2, _arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(name)
	runtime.KeepAlive(message)

	var _exception *Exception // out

	_exception = wrapException(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _exception
}

// BacktraceString: get a string with the exception backtrace.
//
// The function returns the following values:
//
//    - utf8 (optional): exception backtrace string or NULL.
//
func (exception *Exception) BacktraceString() string {
	var _arg0 *C.JSCException // out
	var _cret *C.char         // in

	_arg0 = (*C.JSCException)(unsafe.Pointer(externglib.InternObject(exception).Native()))

	_cret = C.jsc_exception_get_backtrace_string(_arg0)
	runtime.KeepAlive(exception)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// ColumnNumber: get the column number at which exception happened.
//
// The function returns the following values:
//
//    - guint: column number of exception.
//
func (exception *Exception) ColumnNumber() uint {
	var _arg0 *C.JSCException // out
	var _cret C.guint         // in

	_arg0 = (*C.JSCException)(unsafe.Pointer(externglib.InternObject(exception).Native()))

	_cret = C.jsc_exception_get_column_number(_arg0)
	runtime.KeepAlive(exception)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// LineNumber: get the line number at which exception happened.
//
// The function returns the following values:
//
//    - guint: line number of exception.
//
func (exception *Exception) LineNumber() uint {
	var _arg0 *C.JSCException // out
	var _cret C.guint         // in

	_arg0 = (*C.JSCException)(unsafe.Pointer(externglib.InternObject(exception).Native()))

	_cret = C.jsc_exception_get_line_number(_arg0)
	runtime.KeepAlive(exception)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Message: get the error message of exception.
//
// The function returns the following values:
//
//    - utf8: exception error message.
//
func (exception *Exception) Message() string {
	var _arg0 *C.JSCException // out
	var _cret *C.char         // in

	_arg0 = (*C.JSCException)(unsafe.Pointer(externglib.InternObject(exception).Native()))

	_cret = C.jsc_exception_get_message(_arg0)
	runtime.KeepAlive(exception)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Name: get the error name of exception.
//
// The function returns the following values:
//
//    - utf8: exception error name.
//
func (exception *Exception) Name() string {
	var _arg0 *C.JSCException // out
	var _cret *C.char         // in

	_arg0 = (*C.JSCException)(unsafe.Pointer(externglib.InternObject(exception).Native()))

	_cret = C.jsc_exception_get_name(_arg0)
	runtime.KeepAlive(exception)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// SourceURI: get the source URI of exception.
//
// The function returns the following values:
//
//    - utf8 (optional): the source URI of exception, or NULL.
//
func (exception *Exception) SourceURI() string {
	var _arg0 *C.JSCException // out
	var _cret *C.char         // in

	_arg0 = (*C.JSCException)(unsafe.Pointer(externglib.InternObject(exception).Native()))

	_cret = C.jsc_exception_get_source_uri(_arg0)
	runtime.KeepAlive(exception)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Report: return a report message of exception, containing all the possible
// details such us source URI, line, column and backtrace, and formatted to be
// printed.
//
// The function returns the following values:
//
//    - utf8: new string with the exception report.
//
func (exception *Exception) Report() string {
	var _arg0 *C.JSCException // out
	var _cret *C.char         // in

	_arg0 = (*C.JSCException)(unsafe.Pointer(externglib.InternObject(exception).Native()))

	_cret = C.jsc_exception_report(_arg0)
	runtime.KeepAlive(exception)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// String: get the string representation of exception error.
//
// The function returns the following values:
//
//    - utf8: string representation of exception.
//
func (exception *Exception) String() string {
	var _arg0 *C.JSCException // out
	var _cret *C.char         // in

	_arg0 = (*C.JSCException)(unsafe.Pointer(externglib.InternObject(exception).Native()))

	_cret = C.jsc_exception_to_string(_arg0)
	runtime.KeepAlive(exception)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}
