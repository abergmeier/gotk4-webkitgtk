// Code generated by girgen. DO NOT EDIT.

package javascriptcore

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: javascriptcoregtk-4.0 webkit2gtk-4.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <jsc/jsc.h>
// gboolean _gotk4_javascriptcore4_OptionsFunc(char*, JSCOptionType, char*, gpointer);
import "C"

// OptionType: enum values for options types.
type OptionType int

const (
	// OptionBoolean option type.
	OptionBoolean OptionType = iota
	// OptionInt option type.
	OptionInt
	// OptionUint option type.
	OptionUint
	// OptionSize options type.
	OptionSize
	// OptionDouble options type.
	OptionDouble
	// OptionString option type.
	OptionString
	// OptionRangeString: range string option type.
	OptionRangeString
)

// String returns the name in string for OptionType.
func (o OptionType) String() string {
	switch o {
	case OptionBoolean:
		return "Boolean"
	case OptionInt:
		return "Int"
	case OptionUint:
		return "Uint"
	case OptionSize:
		return "Size"
	case OptionDouble:
		return "Double"
	case OptionString:
		return "String"
	case OptionRangeString:
		return "RangeString"
	default:
		return fmt.Sprintf("OptionType(%d)", o)
	}
}

// OptionsFunc: function used to iterate options.
//
// Not that description string is not localized.
type OptionsFunc func(option string, typ OptionType, description string) (ok bool)

//export _gotk4_javascriptcore4_OptionsFunc
func _gotk4_javascriptcore4_OptionsFunc(arg0 *C.char, arg1 C.JSCOptionType, arg2 *C.char, arg3 C.gpointer) (cret C.gboolean) {
	v := gbox.Get(uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var option string      // out
	var typ OptionType     // out
	var description string // out

	option = C.GoString((*C.gchar)(unsafe.Pointer(arg0)))
	defer C.free(unsafe.Pointer(arg0))
	typ = OptionType(arg1)
	description = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	defer C.free(unsafe.Pointer(arg2))

	fn := v.(OptionsFunc)
	ok := fn(option, typ, description)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// OptionsForeach iterates all available options calling function for each one.
// Iteration can stop early if function returns FALSE.
func OptionsForeach(function OptionsFunc) {
	var _arg1 C.JSCOptionsFunc // out
	var _arg2 C.gpointer

	_arg1 = (*[0]byte)(C._gotk4_javascriptcore4_OptionsFunc)
	_arg2 = C.gpointer(gbox.Assign(function))
	defer gbox.Delete(uintptr(_arg2))

	C.jsc_options_foreach(_arg1, _arg2)
}

// OptionsGetBoolean: get option as a #gboolean value.
func OptionsGetBoolean(option string) (value bool, ok bool) {
	var _arg1 *C.char    // out
	var _arg2 C.gboolean // in
	var _cret C.gboolean // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(option)))

	_cret = C.jsc_options_get_boolean(_arg1, &_arg2)

	var _value bool // out
	var _ok bool    // out

	if _arg2 != 0 {
		_value = true
	}
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// OptionsGetDouble: get option as a #gdouble value.
func OptionsGetDouble(option string) (float64, bool) {
	var _arg1 *C.char    // out
	var _arg2 C.gdouble  // in
	var _cret C.gboolean // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(option)))

	_cret = C.jsc_options_get_double(_arg1, &_arg2)

	var _value float64 // out
	var _ok bool       // out

	_value = float64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// OptionsGetInt: get option as a #gint value.
func OptionsGetInt(option string) (int, bool) {
	var _arg1 *C.char    // out
	var _arg2 C.gint     // in
	var _cret C.gboolean // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(option)))

	_cret = C.jsc_options_get_int(_arg1, &_arg2)

	var _value int // out
	var _ok bool   // out

	_value = int(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// OptionsGetOptionGroup: create a Group to handle JSCOptions as command line
// arguments. The options will be exposed as command line arguments with the
// form <emphasis>--jsc-&lt;option&gt;=&lt;value&gt;</emphasis>. Each entry in
// the returned Group is configured to apply the corresponding option during
// command line parsing. Applications only need to pass the returned group to
// g_option_context_add_group(), and the rest will be taken care for
// automatically.
func OptionsGetOptionGroup() *glib.OptionGroup {
	var _cret *C.GOptionGroup // in

	_cret = C.jsc_options_get_option_group()

	var _optionGroup *glib.OptionGroup // out

	_optionGroup = (*glib.OptionGroup)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_option_group_ref(_cret)
	runtime.SetFinalizer(_optionGroup, func(v *glib.OptionGroup) {
		C.g_option_group_unref((*C.GOptionGroup)(gextras.StructNative(unsafe.Pointer(v))))
	})

	return _optionGroup
}

// OptionsGetRangeString: get option as a range string. The string must be in
// the format <emphasis>[!]&lt;low&gt;[:&lt;high&gt;]</emphasis> where low and
// high are #guint values. Values between low and high (both included) will be
// considered in the range, unless <emphasis>!</emphasis> is used to invert the
// range.
func OptionsGetRangeString(option string) (string, bool) {
	var _arg1 *C.char    // out
	var _arg2 *C.char    // in
	var _cret C.gboolean // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(option)))

	_cret = C.jsc_options_get_range_string(_arg1, &_arg2)

	var _value string // out
	var _ok bool      // out

	_value = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
	defer C.free(unsafe.Pointer(_arg2))
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// OptionsGetSize: get option as a #gsize value.
func OptionsGetSize(option string) (uint, bool) {
	var _arg1 *C.char    // out
	var _arg2 C.gsize    // in
	var _cret C.gboolean // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(option)))

	_cret = C.jsc_options_get_size(_arg1, &_arg2)

	var _value uint // out
	var _ok bool    // out

	_value = uint(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// OptionsGetString: get option as a string.
func OptionsGetString(option string) (string, bool) {
	var _arg1 *C.char    // out
	var _arg2 *C.char    // in
	var _cret C.gboolean // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(option)))

	_cret = C.jsc_options_get_string(_arg1, &_arg2)

	var _value string // out
	var _ok bool      // out

	_value = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
	defer C.free(unsafe.Pointer(_arg2))
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// OptionsGetUint: get option as a #guint value.
func OptionsGetUint(option string) (uint, bool) {
	var _arg1 *C.char    // out
	var _arg2 C.guint    // in
	var _cret C.gboolean // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(option)))

	_cret = C.jsc_options_get_uint(_arg1, &_arg2)

	var _value uint // out
	var _ok bool    // out

	_value = uint(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// OptionsSetBoolean: set option as a #gboolean value.
func OptionsSetBoolean(option string, value bool) bool {
	var _arg1 *C.char    // out
	var _arg2 C.gboolean // out
	var _cret C.gboolean // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(option)))
	if value {
		_arg2 = C.TRUE
	}

	_cret = C.jsc_options_set_boolean(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// OptionsSetDouble: set option as a #gdouble value.
func OptionsSetDouble(option string, value float64) bool {
	var _arg1 *C.char    // out
	var _arg2 C.gdouble  // out
	var _cret C.gboolean // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(option)))
	_arg2 = C.gdouble(value)

	_cret = C.jsc_options_set_double(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// OptionsSetInt: set option as a #gint value.
func OptionsSetInt(option string, value int) bool {
	var _arg1 *C.char    // out
	var _arg2 C.gint     // out
	var _cret C.gboolean // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(option)))
	_arg2 = C.gint(value)

	_cret = C.jsc_options_set_int(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// OptionsSetRangeString: set option as a range string. The string must be in
// the format <emphasis>[!]&lt;low&gt;[:&lt;high&gt;]</emphasis> where low and
// high are #guint values. Values between low and high (both included) will be
// considered in the range, unless <emphasis>!</emphasis> is used to invert the
// range.
func OptionsSetRangeString(option string, value string) bool {
	var _arg1 *C.char    // out
	var _arg2 *C.char    // out
	var _cret C.gboolean // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(option)))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(value)))

	_cret = C.jsc_options_set_range_string(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// OptionsSetSize: set option as a #gsize value.
func OptionsSetSize(option string, value uint) bool {
	var _arg1 *C.char    // out
	var _arg2 C.gsize    // out
	var _cret C.gboolean // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(option)))
	_arg2 = C.gsize(value)

	_cret = C.jsc_options_set_size(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// OptionsSetString: set option as a string.
func OptionsSetString(option string, value string) bool {
	var _arg1 *C.char    // out
	var _arg2 *C.char    // out
	var _cret C.gboolean // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(option)))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(value)))

	_cret = C.jsc_options_set_string(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// OptionsSetUint: set option as a #guint value.
func OptionsSetUint(option string, value uint) bool {
	var _arg1 *C.char    // out
	var _arg2 C.guint    // out
	var _cret C.gboolean // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(option)))
	_arg2 = C.guint(value)

	_cret = C.jsc_options_set_uint(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
