// Code generated by girgen. DO NOT EDIT.

package javascriptcore

import (
	"fmt"
	"runtime"
	"runtime/cgo"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <jsc/jsc.h>
import "C"

// glib.Type values for JSCValue.go.
var GTypeValue = externglib.Type(C.jsc_value_get_type())

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: GTypeValue, F: marshalValue},
	})
}

// ValuePropertyFlags flags used when defining properties with
// jsc_value_object_define_property_data() and
// jsc_value_object_define_property_accessor().
type ValuePropertyFlags C.guint

const (
	// ValuePropertyConfigurable: type of the property descriptor may be changed
	// and the property may be deleted from the corresponding object.
	ValuePropertyConfigurable ValuePropertyFlags = 0b1
	// ValuePropertyEnumerable: property shows up during enumeration of the
	// properties on the corresponding object.
	ValuePropertyEnumerable ValuePropertyFlags = 0b10
	// ValuePropertyWritable: value associated with the property may be changed
	// with an assignment operator. This doesn't have any effect when passed to
	// jsc_value_object_define_property_accessor().
	ValuePropertyWritable ValuePropertyFlags = 0b100
)

// String returns the names in string for ValuePropertyFlags.
func (v ValuePropertyFlags) String() string {
	if v == 0 {
		return "ValuePropertyFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(71)

	for v != 0 {
		next := v & (v - 1)
		bit := v - next

		switch bit {
		case ValuePropertyConfigurable:
			builder.WriteString("Configurable|")
		case ValuePropertyEnumerable:
			builder.WriteString("Enumerable|")
		case ValuePropertyWritable:
			builder.WriteString("Writable|")
		default:
			builder.WriteString(fmt.Sprintf("ValuePropertyFlags(0b%b)|", bit))
		}

		v = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if v contains other.
func (v ValuePropertyFlags) Has(other ValuePropertyFlags) bool {
	return (v & other) == other
}

// ValueOverrider contains methods that are overridable.
type ValueOverrider interface {
}

type Value struct {
	_ [0]func() // equal guard
	*externglib.Object
}

var (
	_ externglib.Objector = (*Value)(nil)
)

func classInitValueer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

}

func wrapValue(obj *externglib.Object) *Value {
	return &Value{
		Object: obj,
	}
}

func marshalValue(p uintptr) (interface{}, error) {
	return wrapValue(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewValueArrayFromStrv: create a new CValue referencing an array of strings
// with the items from strv. If array is NULL or empty a new empty array will be
// created.
//
// The function takes the following parameters:
//
//    - context: CContext.
//    - strv: NULL-terminated array of strings.
//
// The function returns the following values:
//
//    - value: CValue.
//
func NewValueArrayFromStrv(context *Context, strv []string) *Value {
	var _arg1 *C.JSCContext // out
	var _arg2 **C.char      // out
	var _cret *C.JSCValue   // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	{
		_arg2 = (**C.char)(C.calloc(C.size_t((len(strv) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice(_arg2, len(strv)+1)
			var zero *C.char
			out[len(strv)] = zero
			for i := range strv {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(strv[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.jsc_value_new_array_from_strv(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(strv)

	var _value *Value // out

	_value = wrapValue(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// NewValueBoolean: create a new CValue from value.
//
// The function takes the following parameters:
//
//    - context: CContext.
//    - value: #gboolean.
//
// The function returns the following values:
//
//    - ret: CValue.
//
func NewValueBoolean(context *Context, value bool) *Value {
	var _arg1 *C.JSCContext // out
	var _arg2 C.gboolean    // out
	var _cret *C.JSCValue   // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	if value {
		_arg2 = C.TRUE
	}

	_cret = C.jsc_value_new_boolean(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(value)

	var _ret *Value // out

	_ret = wrapValue(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ret
}

// NewValueFromJson: create a new CValue referencing a new value created by
// parsing json.
//
// The function takes the following parameters:
//
//    - context: CContext.
//    - json: JSON string to be parsed.
//
// The function returns the following values:
//
//    - value: CValue.
//
func NewValueFromJson(context *Context, json string) *Value {
	var _arg1 *C.JSCContext // out
	var _arg2 *C.char       // out
	var _cret *C.JSCValue   // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(json)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.jsc_value_new_from_json(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(json)

	var _value *Value // out

	_value = wrapValue(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// NewValueNull: create a new CValue referencing <function>null</function> in
// context.
//
// The function takes the following parameters:
//
//    - context: CContext.
//
// The function returns the following values:
//
//    - value: CValue.
//
func NewValueNull(context *Context) *Value {
	var _arg1 *C.JSCContext // out
	var _cret *C.JSCValue   // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(externglib.InternObject(context).Native()))

	_cret = C.jsc_value_new_null(_arg1)
	runtime.KeepAlive(context)

	var _value *Value // out

	_value = wrapValue(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// NewValueNumber: create a new CValue from number.
//
// The function takes the following parameters:
//
//    - context: CContext.
//    - number: number.
//
// The function returns the following values:
//
//    - value: CValue.
//
func NewValueNumber(context *Context, number float64) *Value {
	var _arg1 *C.JSCContext // out
	var _arg2 C.double      // out
	var _cret *C.JSCValue   // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	_arg2 = C.double(number)

	_cret = C.jsc_value_new_number(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(number)

	var _value *Value // out

	_value = wrapValue(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// NewValueObject: create a new CValue from instance. If instance is NULL a new
// empty object is created. When instance is provided, jsc_class must be
// provided too. jsc_class takes ownership of instance that will be freed by the
// Notify passed to jsc_context_register_class().
//
// The function takes the following parameters:
//
//    - context: CContext.
//    - instance (optional): object instance or NULL.
//    - jscClass (optional) of instance.
//
// The function returns the following values:
//
//    - value: CValue.
//
func NewValueObject(context *Context, instance cgo.Handle, jscClass *Class) *Value {
	var _arg1 *C.JSCContext // out
	var _arg2 C.gpointer    // out
	var _arg3 *C.JSCClass   // out
	var _cret *C.JSCValue   // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	_arg2 = (C.gpointer)(unsafe.Pointer(instance))
	if jscClass != nil {
		_arg3 = (*C.JSCClass)(unsafe.Pointer(externglib.InternObject(jscClass).Native()))
	}

	_cret = C.jsc_value_new_object(_arg1, _arg2, _arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(instance)
	runtime.KeepAlive(jscClass)

	var _value *Value // out

	_value = wrapValue(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// NewValueString: create a new CValue from string. If you need to create a
// CValue from a string containing null characters, use
// jsc_value_new_string_from_bytes() instead.
//
// The function takes the following parameters:
//
//    - context: CContext.
//    - str (optional): null-terminated string.
//
// The function returns the following values:
//
//    - value: CValue.
//
func NewValueString(context *Context, str string) *Value {
	var _arg1 *C.JSCContext // out
	var _arg2 *C.char       // out
	var _cret *C.JSCValue   // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	if str != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.jsc_value_new_string(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(str)

	var _value *Value // out

	_value = wrapValue(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// NewValueStringFromBytes: create a new CValue from bytes.
//
// The function takes the following parameters:
//
//    - context: CContext.
//    - bytes (optional): #GBytes.
//
// The function returns the following values:
//
//    - value: CValue.
//
func NewValueStringFromBytes(context *Context, bytes *glib.Bytes) *Value {
	var _arg1 *C.JSCContext // out
	var _arg2 *C.GBytes     // out
	var _cret *C.JSCValue   // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	if bytes != nil {
		_arg2 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))
	}

	_cret = C.jsc_value_new_string_from_bytes(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(bytes)

	var _value *Value // out

	_value = wrapValue(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// NewValueUndefined: create a new CValue referencing
// <function>undefined</function> in context.
//
// The function takes the following parameters:
//
//    - context: CContext.
//
// The function returns the following values:
//
//    - value: CValue.
//
func NewValueUndefined(context *Context) *Value {
	var _arg1 *C.JSCContext // out
	var _cret *C.JSCValue   // in

	_arg1 = (*C.JSCContext)(unsafe.Pointer(externglib.InternObject(context).Native()))

	_cret = C.jsc_value_new_undefined(_arg1)
	runtime.KeepAlive(context)

	var _value *Value // out

	_value = wrapValue(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _value
}

// ConstructorCall: invoke <function>new</function> with constructor referenced
// by value. If n_parameters is 0 no parameters will be passed to the
// constructor.
//
// The function takes the following parameters:
//
//    - parameters (optional) -->s to pass as parameters to the constructor, or
//      NULL.
//
// The function returns the following values:
//
//    - ret referencing the newly created object instance.
//
func (value *Value) ConstructorCall(parameters []*Value) *Value {
	var _arg0 *C.JSCValue  // out
	var _arg2 **C.JSCValue // out
	var _arg1 C.guint
	var _cret *C.JSCValue // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))
	if parameters != nil {
		_arg1 = (C.guint)(len(parameters))
		_arg2 = (**C.JSCValue)(C.calloc(C.size_t(len(parameters)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice((**C.JSCValue)(_arg2), len(parameters))
			for i := range parameters {
				out[i] = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(parameters[i]).Native()))
			}
		}
	}

	_cret = C.jsc_value_constructor_callv(_arg0, _arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(parameters)

	var _ret *Value // out

	_ret = wrapValue(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ret
}

// FunctionCall: call function referenced by value, passing the given
// parameters. If n_parameters is 0 no parameters will be passed to the
// function.
//
// This function always returns a CValue, in case of void functions a CValue
// referencing <function>undefined</function> is returned.
//
// The function takes the following parameters:
//
//    - parameters (optional) -->s to pass as parameters to the function, or
//      NULL.
//
// The function returns the following values:
//
//    - ret with the return value of the function.
//
func (value *Value) FunctionCall(parameters []*Value) *Value {
	var _arg0 *C.JSCValue  // out
	var _arg2 **C.JSCValue // out
	var _arg1 C.guint
	var _cret *C.JSCValue // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))
	if parameters != nil {
		_arg1 = (C.guint)(len(parameters))
		_arg2 = (**C.JSCValue)(C.calloc(C.size_t(len(parameters)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice((**C.JSCValue)(_arg2), len(parameters))
			for i := range parameters {
				out[i] = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(parameters[i]).Native()))
			}
		}
	}

	_cret = C.jsc_value_function_callv(_arg0, _arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(parameters)

	var _ret *Value // out

	_ret = wrapValue(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ret
}

// Context: get the CContext in which value was created.
//
// The function returns the following values:
//
//    - context: CValue context.
//
func (value *Value) Context() *Context {
	var _arg0 *C.JSCValue   // out
	var _cret *C.JSCContext // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))

	_cret = C.jsc_value_get_context(_arg0)
	runtime.KeepAlive(value)

	var _context *Context // out

	_context = wrapContext(externglib.Take(unsafe.Pointer(_cret)))

	return _context
}

// IsArray: get whether the value referenced by value is an array.
//
// The function returns the following values:
//
//    - ok: whether the value is an array.
//
func (value *Value) IsArray() bool {
	var _arg0 *C.JSCValue // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))

	_cret = C.jsc_value_is_array(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsBoolean: get whether the value referenced by value is a boolean.
//
// The function returns the following values:
//
//    - ok: whether the value is a boolean.
//
func (value *Value) IsBoolean() bool {
	var _arg0 *C.JSCValue // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))

	_cret = C.jsc_value_is_boolean(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsConstructor: get whether the value referenced by value is a constructor.
//
// The function returns the following values:
//
//    - ok: whether the value is a constructor.
//
func (value *Value) IsConstructor() bool {
	var _arg0 *C.JSCValue // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))

	_cret = C.jsc_value_is_constructor(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFunction: get whether the value referenced by value is a function.
//
// The function returns the following values:
//
//    - ok: whether the value is a function.
//
func (value *Value) IsFunction() bool {
	var _arg0 *C.JSCValue // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))

	_cret = C.jsc_value_is_function(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsNull: get whether the value referenced by value is
// <function>null</function>.
//
// The function returns the following values:
//
//    - ok: whether the value is null.
//
func (value *Value) IsNull() bool {
	var _arg0 *C.JSCValue // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))

	_cret = C.jsc_value_is_null(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsNumber: get whether the value referenced by value is a number.
//
// The function returns the following values:
//
//    - ok: whether the value is a number.
//
func (value *Value) IsNumber() bool {
	var _arg0 *C.JSCValue // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))

	_cret = C.jsc_value_is_number(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsObject: get whether the value referenced by value is an object.
//
// The function returns the following values:
//
//    - ok: whether the value is an object.
//
func (value *Value) IsObject() bool {
	var _arg0 *C.JSCValue // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))

	_cret = C.jsc_value_is_object(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsString: get whether the value referenced by value is a string.
//
// The function returns the following values:
//
//    - ok: whether the value is a string.
//
func (value *Value) IsString() bool {
	var _arg0 *C.JSCValue // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))

	_cret = C.jsc_value_is_string(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsUndefined: get whether the value referenced by value is
// <function>undefined</function>.
//
// The function returns the following values:
//
//    - ok: whether the value is undefined.
//
func (value *Value) IsUndefined() bool {
	var _arg0 *C.JSCValue // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))

	_cret = C.jsc_value_is_undefined(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ObjectDefinePropertyData: define or modify a property with property_name in
// object referenced by value. This is equivalent to JavaScript
// <function>Object.defineProperty()</function> when used with a data
// descriptor.
//
// The function takes the following parameters:
//
//    - propertyName: name of the property to define.
//    - flags: CValuePropertyFlags.
//    - propertyValue (optional): default property value.
//
func (value *Value) ObjectDefinePropertyData(propertyName string, flags ValuePropertyFlags, propertyValue *Value) {
	var _arg0 *C.JSCValue             // out
	var _arg1 *C.char                 // out
	var _arg2 C.JSCValuePropertyFlags // out
	var _arg3 *C.JSCValue             // out

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.JSCValuePropertyFlags(flags)
	if propertyValue != nil {
		_arg3 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(propertyValue).Native()))
	}

	C.jsc_value_object_define_property_data(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(value)
	runtime.KeepAlive(propertyName)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(propertyValue)
}

// ObjectDeleteProperty: try to delete property with name from value. This
// function will return FALSE if the property was defined without
// JSC_VALUE_PROPERTY_CONFIGURABLE flag.
//
// The function takes the following parameters:
//
//    - name: property name.
//
// The function returns the following values:
//
//    - ok: TRUE if the property was deleted, or FALSE otherwise.
//
func (value *Value) ObjectDeleteProperty(name string) bool {
	var _arg0 *C.JSCValue // out
	var _arg1 *C.char     // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.jsc_value_object_delete_property(_arg0, _arg1)
	runtime.KeepAlive(value)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ObjectEnumerateProperties: get the list of property names of value. Only
// properties defined with JSC_VALUE_PROPERTY_ENUMERABLE flag will be collected.
//
// The function returns the following values:
//
//    - utf8s (optional): NULL-terminated array of strings containing the
//      property names, or NULL if value doesn't have enumerable properties. Use
//      g_strfreev() to free.
//
func (value *Value) ObjectEnumerateProperties() []string {
	var _arg0 *C.JSCValue // out
	var _cret **C.gchar   // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))

	_cret = C.jsc_value_object_enumerate_properties(_arg0)
	runtime.KeepAlive(value)

	var _utf8s []string // out

	if _cret != nil {
		defer C.free(unsafe.Pointer(_cret))
		{
			var i int
			var z *C.gchar
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_utf8s = make([]string, i)
			for i := range src {
				_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
				defer C.free(unsafe.Pointer(src[i]))
			}
		}
	}

	return _utf8s
}

// ObjectGetProperty: get property with name from value.
//
// The function takes the following parameters:
//
//    - name: property name.
//
// The function returns the following values:
//
//    - ret: property CValue.
//
func (value *Value) ObjectGetProperty(name string) *Value {
	var _arg0 *C.JSCValue // out
	var _arg1 *C.char     // out
	var _cret *C.JSCValue // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.jsc_value_object_get_property(_arg0, _arg1)
	runtime.KeepAlive(value)
	runtime.KeepAlive(name)

	var _ret *Value // out

	_ret = wrapValue(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ret
}

// ObjectGetPropertyAtIndex: get property at index from value.
//
// The function takes the following parameters:
//
//    - index: property index.
//
// The function returns the following values:
//
//    - ret: property CValue.
//
func (value *Value) ObjectGetPropertyAtIndex(index uint) *Value {
	var _arg0 *C.JSCValue // out
	var _arg1 C.guint     // out
	var _cret *C.JSCValue // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))
	_arg1 = C.guint(index)

	_cret = C.jsc_value_object_get_property_at_index(_arg0, _arg1)
	runtime.KeepAlive(value)
	runtime.KeepAlive(index)

	var _ret *Value // out

	_ret = wrapValue(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ret
}

// ObjectHasProperty: get whether value has property with name.
//
// The function takes the following parameters:
//
//    - name: property name.
//
// The function returns the following values:
//
//    - ok: TRUE if value has a property with name, or FALSE otherwise.
//
func (value *Value) ObjectHasProperty(name string) bool {
	var _arg0 *C.JSCValue // out
	var _arg1 *C.char     // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.jsc_value_object_has_property(_arg0, _arg1)
	runtime.KeepAlive(value)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ObjectInvokeMethod: invoke method with name on object referenced by value,
// passing the given parameters. If n_parameters is 0 no parameters will be
// passed to the method. The object instance will be handled automatically even
// when the method is a custom one registered with jsc_class_add_method(), so it
// should never be passed explicitly as parameter of this function.
//
// This function always returns a CValue, in case of void methods a CValue
// referencing <function>undefined</function> is returned.
//
// The function takes the following parameters:
//
//    - name: method name.
//    - parameters (optional) -->s to pass as parameters to the method, or NULL.
//
// The function returns the following values:
//
//    - ret with the return value of the method.
//
func (value *Value) ObjectInvokeMethod(name string, parameters []*Value) *Value {
	var _arg0 *C.JSCValue  // out
	var _arg1 *C.char      // out
	var _arg3 **C.JSCValue // out
	var _arg2 C.guint
	var _cret *C.JSCValue // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	if parameters != nil {
		_arg2 = (C.guint)(len(parameters))
		_arg3 = (**C.JSCValue)(C.calloc(C.size_t(len(parameters)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg3))
		{
			out := unsafe.Slice((**C.JSCValue)(_arg3), len(parameters))
			for i := range parameters {
				out[i] = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(parameters[i]).Native()))
			}
		}
	}

	_cret = C.jsc_value_object_invoke_methodv(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(value)
	runtime.KeepAlive(name)
	runtime.KeepAlive(parameters)

	var _ret *Value // out

	_ret = wrapValue(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ret
}

// ObjectIsInstanceOf: get whether the value referenced by value is an instance
// of class name.
//
// The function takes the following parameters:
//
//    - name class name.
//
// The function returns the following values:
//
//    - ok: whether the value is an object instance of class name.
//
func (value *Value) ObjectIsInstanceOf(name string) bool {
	var _arg0 *C.JSCValue // out
	var _arg1 *C.char     // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.jsc_value_object_is_instance_of(_arg0, _arg1)
	runtime.KeepAlive(value)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ObjectSetProperty: set property with name on value.
//
// The function takes the following parameters:
//
//    - name: property name.
//    - property to set.
//
func (value *Value) ObjectSetProperty(name string, property *Value) {
	var _arg0 *C.JSCValue // out
	var _arg1 *C.char     // out
	var _arg2 *C.JSCValue // out

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(property).Native()))

	C.jsc_value_object_set_property(_arg0, _arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(name)
	runtime.KeepAlive(property)
}

// ObjectSetPropertyAtIndex: set property at index on value.
//
// The function takes the following parameters:
//
//    - index: property index.
//    - property to set.
//
func (value *Value) ObjectSetPropertyAtIndex(index uint, property *Value) {
	var _arg0 *C.JSCValue // out
	var _arg1 C.guint     // out
	var _arg2 *C.JSCValue // out

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))
	_arg1 = C.guint(index)
	_arg2 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(property).Native()))

	C.jsc_value_object_set_property_at_index(_arg0, _arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(index)
	runtime.KeepAlive(property)
}

// ToBoolean: convert value to a boolean.
//
// The function returns the following values:
//
//    - ok result of the conversion.
//
func (value *Value) ToBoolean() bool {
	var _arg0 *C.JSCValue // out
	var _cret C.gboolean  // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))

	_cret = C.jsc_value_to_boolean(_arg0)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ToDouble: convert value to a double.
//
// The function returns the following values:
//
//    - gdouble result of the conversion.
//
func (value *Value) ToDouble() float64 {
	var _arg0 *C.JSCValue // out
	var _cret C.double    // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))

	_cret = C.jsc_value_to_double(_arg0)
	runtime.KeepAlive(value)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// ToInt32: convert value to a #gint32.
//
// The function returns the following values:
//
//    - gint32 result of the conversion.
//
func (value *Value) ToInt32() int32 {
	var _arg0 *C.JSCValue // out
	var _cret C.gint32    // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))

	_cret = C.jsc_value_to_int32(_arg0)
	runtime.KeepAlive(value)

	var _gint32 int32 // out

	_gint32 = int32(_cret)

	return _gint32
}

// ToJson: create a JSON string of value serialization. If indent is 0, the
// resulting JSON will not contain newlines. The size of the indent is clamped
// to 10 spaces.
//
// The function takes the following parameters:
//
//    - indent: number of spaces to indent when nesting.
//
// The function returns the following values:
//
//    - utf8: null-terminated JSON string with serialization of value.
//
func (value *Value) ToJson(indent uint) string {
	var _arg0 *C.JSCValue // out
	var _arg1 C.guint     // out
	var _cret *C.char     // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))
	_arg1 = C.guint(indent)

	_cret = C.jsc_value_to_json(_arg0, _arg1)
	runtime.KeepAlive(value)
	runtime.KeepAlive(indent)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// String: convert value to a string. Use jsc_value_to_string_as_bytes()
// instead, if you need to handle strings containing null characters.
//
// The function returns the following values:
//
//    - utf8: null-terminated string result of the conversion.
//
func (value *Value) String() string {
	var _arg0 *C.JSCValue // out
	var _cret *C.char     // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))

	_cret = C.jsc_value_to_string(_arg0)
	runtime.KeepAlive(value)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ToStringAsBytes: convert value to a string and return the results as #GBytes.
// This is needed to handle strings with null characters.
//
// The function returns the following values:
//
//    - bytes with the result of the conversion.
//
func (value *Value) ToStringAsBytes() *glib.Bytes {
	var _arg0 *C.JSCValue // out
	var _cret *C.GBytes   // in

	_arg0 = (*C.JSCValue)(unsafe.Pointer(externglib.InternObject(value).Native()))

	_cret = C.jsc_value_to_string_as_bytes(_arg0)
	runtime.KeepAlive(value)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}
