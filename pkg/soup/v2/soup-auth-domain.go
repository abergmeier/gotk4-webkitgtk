// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: libsoup-2.4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <libsoup/soup.h>
// extern void callbackDelete(gpointer);
// gboolean _gotk4_soup2_AuthDomainFilter(SoupAuthDomain*, SoupMessage*, gpointer);
// gboolean _gotk4_soup2_AuthDomainGenericAuthCallback(SoupAuthDomain*, SoupMessage*, char*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.soup_auth_domain_get_type()), F: marshalAuthDomainer},
	})
}

// AuthDomainFilter: prototype for a AuthDomain filter; see
// soup_auth_domain_set_filter() for details.
type AuthDomainFilter func(domain AuthDomainer, msg *Message) (ok bool)

//export _gotk4_soup2_AuthDomainFilter
func _gotk4_soup2_AuthDomainFilter(arg0 *C.SoupAuthDomain, arg1 *C.SoupMessage, arg2 C.gpointer) (cret C.gboolean) {
	v := gbox.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var domain AuthDomainer // out
	var msg *Message        // out

	domain = (gextras.CastObject(externglib.Take(unsafe.Pointer(arg0)))).(AuthDomainer)
	msg = wrapMessage(externglib.Take(unsafe.Pointer(arg1)))

	fn := v.(AuthDomainFilter)
	ok := fn(domain, msg)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// AuthDomainGenericAuthCallback: prototype for a AuthDomain generic
// authentication callback.
//
// The callback should look up the user's password, call
// soup_auth_domain_check_password(), and use the return value from that method
// as its own return value.
//
// In general, for security reasons, it is preferable to use the
// auth-domain-specific auth callbacks (eg, AuthDomainBasicAuthCallback and
// AuthDomainDigestAuthCallback), because they don't require keeping a cleartext
// password database. Most users will use the same password for many different
// sites, meaning if any site with a cleartext password database is compromised,
// accounts on other servers might be compromised as well. For many of the cases
// where Server is used, this is not really relevant, but it may still be worth
// considering.
type AuthDomainGenericAuthCallback func(domain AuthDomainer, msg *Message, username string) (ok bool)

//export _gotk4_soup2_AuthDomainGenericAuthCallback
func _gotk4_soup2_AuthDomainGenericAuthCallback(arg0 *C.SoupAuthDomain, arg1 *C.SoupMessage, arg2 *C.char, arg3 C.gpointer) (cret C.gboolean) {
	v := gbox.Get(uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var domain AuthDomainer // out
	var msg *Message        // out
	var username string     // out

	domain = (gextras.CastObject(externglib.Take(unsafe.Pointer(arg0)))).(AuthDomainer)
	msg = wrapMessage(externglib.Take(unsafe.Pointer(arg1)))
	username = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	defer C.free(unsafe.Pointer(arg2))

	fn := v.(AuthDomainGenericAuthCallback)
	ok := fn(domain, msg, username)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// AuthDomainOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type AuthDomainOverrider interface {
	Accepts(msg *Message, header string) string
	// Challenge adds a "WWW-Authenticate" or "Proxy-Authenticate" header to
	// msg, requesting that the client authenticate, and sets msg's status
	// accordingly.
	//
	// This is used by Server internally and is probably of no use to anyone
	// else.
	Challenge(msg *Message) string
	// CheckPassword checks if msg authenticates to domain via username and
	// password. This would normally be called from a
	// AuthDomainGenericAuthCallback.
	CheckPassword(msg *Message, username string, password string) bool
}

type AuthDomain struct {
	*externglib.Object
}

var _ gextras.Nativer = (*AuthDomain)(nil)

// AuthDomainer describes AuthDomain's abstract methods.
type AuthDomainer interface {
	// Accepts checks if msg contains appropriate authorization for domain to
	// accept it.
	Accepts(msg *Message) string
	// AddPath adds path to domain, such that requests under path on domain's
	// server will require authentication (unless overridden by
	// soup_auth_domain_remove_path() or soup_auth_domain_set_filter()).
	AddPath(path string)
	// Challenge adds a "WWW-Authenticate" or "Proxy-Authenticate" header to
	// msg, requesting that the client authenticate, and sets msg's status
	// accordingly.
	Challenge(msg *Message)
	// CheckPassword checks if msg authenticates to domain via username and
	// password.
	CheckPassword(msg *Message, username string, password string) bool
	// Covers checks if domain requires msg to be authenticated (according to
	// its paths and filter function).
	Covers(msg *Message) bool
	// Realm gets the realm name associated with domain
	Realm() string
	// RemovePath removes path from domain, such that requests under path on
	// domain's server will NOT require authentication.
	RemovePath(path string)
	// SetFilter adds filter as an authentication filter to domain.
	SetFilter(filter AuthDomainFilter)
	// SetGenericAuthCallback sets auth_callback as an authentication-handling
	// callback for domain.
	SetGenericAuthCallback(authCallback AuthDomainGenericAuthCallback)
	TryGenericAuthCallback(msg *Message, username string) bool
}

var _ AuthDomainer = (*AuthDomain)(nil)

func wrapAuthDomain(obj *externglib.Object) *AuthDomain {
	return &AuthDomain{
		Object: obj,
	}
}

func marshalAuthDomainer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapAuthDomain(obj), nil
}

// Accepts checks if msg contains appropriate authorization for domain to accept
// it. Mirroring soup_auth_domain_covers(), this does not check whether or not
// domain <emphasis>cares</emphasis> if msg is authorized.
//
// This is used by Server internally and is probably of no use to anyone else.
func (domain *AuthDomain) Accepts(msg *Message) string {
	var _arg0 *C.SoupAuthDomain // out
	var _arg1 *C.SoupMessage    // out
	var _cret *C.char           // in

	_arg0 = (*C.SoupAuthDomain)(unsafe.Pointer(domain.Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	_cret = C.soup_auth_domain_accepts(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// AddPath adds path to domain, such that requests under path on domain's server
// will require authentication (unless overridden by
// soup_auth_domain_remove_path() or soup_auth_domain_set_filter()).
//
// You can also add paths by setting the SOUP_AUTH_DOMAIN_ADD_PATH property,
// which can also be used to add one or more paths at construct time.
func (domain *AuthDomain) AddPath(path string) {
	var _arg0 *C.SoupAuthDomain // out
	var _arg1 *C.char           // out

	_arg0 = (*C.SoupAuthDomain)(unsafe.Pointer(domain.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))

	C.soup_auth_domain_add_path(_arg0, _arg1)
}

// Challenge adds a "WWW-Authenticate" or "Proxy-Authenticate" header to msg,
// requesting that the client authenticate, and sets msg's status accordingly.
//
// This is used by Server internally and is probably of no use to anyone else.
func (domain *AuthDomain) Challenge(msg *Message) {
	var _arg0 *C.SoupAuthDomain // out
	var _arg1 *C.SoupMessage    // out

	_arg0 = (*C.SoupAuthDomain)(unsafe.Pointer(domain.Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	C.soup_auth_domain_challenge(_arg0, _arg1)
}

// CheckPassword checks if msg authenticates to domain via username and
// password. This would normally be called from a AuthDomainGenericAuthCallback.
func (domain *AuthDomain) CheckPassword(msg *Message, username string, password string) bool {
	var _arg0 *C.SoupAuthDomain // out
	var _arg1 *C.SoupMessage    // out
	var _arg2 *C.char           // out
	var _arg3 *C.char           // out
	var _cret C.gboolean        // in

	_arg0 = (*C.SoupAuthDomain)(unsafe.Pointer(domain.Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(username)))
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(password)))

	_cret = C.soup_auth_domain_check_password(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Covers checks if domain requires msg to be authenticated (according to its
// paths and filter function). This does not actually look at whether msg
// <emphasis>is</emphasis> authenticated, merely whether or not it needs to be.
//
// This is used by Server internally and is probably of no use to anyone else.
func (domain *AuthDomain) Covers(msg *Message) bool {
	var _arg0 *C.SoupAuthDomain // out
	var _arg1 *C.SoupMessage    // out
	var _cret C.gboolean        // in

	_arg0 = (*C.SoupAuthDomain)(unsafe.Pointer(domain.Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	_cret = C.soup_auth_domain_covers(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Realm gets the realm name associated with domain
func (domain *AuthDomain) Realm() string {
	var _arg0 *C.SoupAuthDomain // out
	var _cret *C.char           // in

	_arg0 = (*C.SoupAuthDomain)(unsafe.Pointer(domain.Native()))

	_cret = C.soup_auth_domain_get_realm(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// RemovePath removes path from domain, such that requests under path on
// domain's server will NOT require authentication.
//
// This is not simply an undo-er for soup_auth_domain_add_path(); it can be used
// to "carve out" a subtree that does not require authentication inside a
// hierarchy that does. Note also that unlike with soup_auth_domain_add_path(),
// this cannot be overridden by adding a filter, as filters can only bypass
// authentication that would otherwise be required, not require it where it
// would otherwise be unnecessary.
//
// You can also remove paths by setting the SOUP_AUTH_DOMAIN_REMOVE_PATH
// property, which can also be used to remove one or more paths at construct
// time.
func (domain *AuthDomain) RemovePath(path string) {
	var _arg0 *C.SoupAuthDomain // out
	var _arg1 *C.char           // out

	_arg0 = (*C.SoupAuthDomain)(unsafe.Pointer(domain.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))

	C.soup_auth_domain_remove_path(_arg0, _arg1)
}

// SetFilter adds filter as an authentication filter to domain. The filter gets
// a chance to bypass authentication for certain requests that would otherwise
// require it. Eg, it might check the message's path in some way that is too
// complicated to do via the other methods, or it might check the message's
// method, and allow GETs but not PUTs.
//
// The filter function returns TRUE if the request should still require
// authentication, or FALSE if authentication is unnecessary for this request.
//
// To help prevent security holes, your filter should return TRUE by default,
// and only return FALSE under specifically-tested circumstances, rather than
// the other way around. Eg, in the example above, where you want to
// authenticate PUTs but not GETs, you should check if the method is GET and
// return FALSE in that case, and then return TRUE for all other methods (rather
// than returning TRUE for PUT and FALSE for all other methods). This way if it
// turned out (now or later) that some paths supported additional methods
// besides GET and PUT, those methods would default to being NOT allowed for
// unauthenticated users.
//
// You can also set the filter by setting the SOUP_AUTH_DOMAIN_FILTER and
// SOUP_AUTH_DOMAIN_FILTER_DATA properties, which can also be used to set the
// filter at construct time.
func (domain *AuthDomain) SetFilter(filter AuthDomainFilter) {
	var _arg0 *C.SoupAuthDomain      // out
	var _arg1 C.SoupAuthDomainFilter // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.SoupAuthDomain)(unsafe.Pointer(domain.Native()))
	_arg1 = (*[0]byte)(C._gotk4_soup2_AuthDomainFilter)
	_arg2 = C.gpointer(gbox.Assign(filter))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.soup_auth_domain_set_filter(_arg0, _arg1, _arg2, _arg3)
}

// SetGenericAuthCallback sets auth_callback as an authentication-handling
// callback for domain. Whenever a request comes in to domain which cannot be
// authenticated via a domain-specific auth callback (eg,
// AuthDomainDigestAuthCallback), the generic auth callback will be invoked. See
// AuthDomainGenericAuthCallback for information on what the callback should do.
func (domain *AuthDomain) SetGenericAuthCallback(authCallback AuthDomainGenericAuthCallback) {
	var _arg0 *C.SoupAuthDomain                   // out
	var _arg1 C.SoupAuthDomainGenericAuthCallback // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.SoupAuthDomain)(unsafe.Pointer(domain.Native()))
	_arg1 = (*[0]byte)(C._gotk4_soup2_AuthDomainGenericAuthCallback)
	_arg2 = C.gpointer(gbox.Assign(authCallback))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.soup_auth_domain_set_generic_auth_callback(_arg0, _arg1, _arg2, _arg3)
}

func (domain *AuthDomain) TryGenericAuthCallback(msg *Message, username string) bool {
	var _arg0 *C.SoupAuthDomain // out
	var _arg1 *C.SoupMessage    // out
	var _arg2 *C.char           // out
	var _cret C.gboolean        // in

	_arg0 = (*C.SoupAuthDomain)(unsafe.Pointer(domain.Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(username)))

	_cret = C.soup_auth_domain_try_generic_auth_callback(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
