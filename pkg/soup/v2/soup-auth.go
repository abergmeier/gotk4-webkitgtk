// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: libsoup-2.4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <libsoup/soup.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.soup_auth_get_type()), F: marshalAuther},
	})
}

// AuthOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type AuthOverrider interface {
	// Authenticate: call this on an auth to authenticate it; normally this will
	// cause the auth's message to be requeued with the new authentication info.
	Authenticate(username string, password string)
	// CanAuthenticate tests if auth is able to authenticate by providing
	// credentials to the soup_auth_authenticate().
	CanAuthenticate() bool
	// Authorization generates an appropriate "Authorization" header for msg.
	// (The session will only call this if soup_auth_is_authenticated() returned
	// TRUE.)
	Authorization(msg *Message) string
	// IsAuthenticated tests if auth has been given a username and password
	IsAuthenticated() bool
	// IsReady tests if auth is ready to make a request for msg with. For most
	// auths, this is equivalent to soup_auth_is_authenticated(), but for some
	// auth types (eg, NTLM), the auth may be sendable (eg, as an authentication
	// request) even before it is authenticated.
	IsReady(msg *Message) bool
	// Update updates auth with the information from msg and auth_header,
	// possibly un-authenticating it. As with soup_auth_new(), this is normally
	// only used by Session.
	Update(msg *Message, authHeader *glib.HashTable) bool
}

// Auth: abstract base class for handling authentication. Specific HTTP
// Authentication mechanisms are implemented by its subclasses, but applications
// never need to be aware of the specific subclasses being used.
type Auth struct {
	*externglib.Object
}

var _ gextras.Nativer = (*Auth)(nil)

// Auther describes Auth's abstract methods.
type Auther interface {
	// Authenticate: call this on an auth to authenticate it; normally this will
	// cause the auth's message to be requeued with the new authentication info.
	Authenticate(username string, password string)
	// CanAuthenticate tests if auth is able to authenticate by providing
	// credentials to the soup_auth_authenticate().
	CanAuthenticate() bool
	Authorization(msg *Message) string
	// Host returns the host that auth is associated with.
	Host() string
	// Info gets an opaque identifier for auth, for use as a hash key or the
	// like.
	Info() string
	// Realm returns auth's realm.
	Realm() string
	SavedPassword(user string) string
	// SchemeName returns auth's scheme name.
	SchemeName() string
	HasSavedPassword(username string, password string)
	// IsAuthenticated tests if auth has been given a username and password
	IsAuthenticated() bool
	// IsForProxy tests whether or not auth is associated with a proxy server
	// rather than an "origin" server.
	IsForProxy() bool
	// IsReady tests if auth is ready to make a request for msg with.
	IsReady(msg *Message) bool
	SavePassword(username string, password string)
	// Update updates auth with the information from msg and auth_header,
	// possibly un-authenticating it.
	Update(msg *Message, authHeader string) bool
}

var _ Auther = (*Auth)(nil)

func wrapAuth(obj *externglib.Object) *Auth {
	return &Auth{
		Object: obj,
	}
}

func marshalAuther(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapAuth(obj), nil
}

// NewAuth creates a new Auth of type type with the information from msg and
// auth_header.
//
// This is called by Session; you will normally not create auths yourself.
func NewAuth(typ externglib.Type, msg *Message, authHeader string) *Auth {
	var _arg1 C.GType        // out
	var _arg2 *C.SoupMessage // out
	var _arg3 *C.char        // out
	var _cret *C.SoupAuth    // in

	_arg1 = C.GType(typ)
	_arg2 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(authHeader)))

	_cret = C.soup_auth_new(_arg1, _arg2, _arg3)

	var _auth *Auth // out

	_auth = wrapAuth(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _auth
}

// Authenticate: call this on an auth to authenticate it; normally this will
// cause the auth's message to be requeued with the new authentication info.
func (auth *Auth) Authenticate(username string, password string) {
	var _arg0 *C.SoupAuth // out
	var _arg1 *C.char     // out
	var _arg2 *C.char     // out

	_arg0 = (*C.SoupAuth)(unsafe.Pointer(auth.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(username)))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(password)))

	C.soup_auth_authenticate(_arg0, _arg1, _arg2)
}

// CanAuthenticate tests if auth is able to authenticate by providing
// credentials to the soup_auth_authenticate().
func (auth *Auth) CanAuthenticate() bool {
	var _arg0 *C.SoupAuth // out
	var _cret C.gboolean  // in

	_arg0 = (*C.SoupAuth)(unsafe.Pointer(auth.Native()))

	_cret = C.soup_auth_can_authenticate(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Authorization generates an appropriate "Authorization" header for msg. (The
// session will only call this if soup_auth_is_authenticated() returned TRUE.)
func (auth *Auth) Authorization(msg *Message) string {
	var _arg0 *C.SoupAuth    // out
	var _arg1 *C.SoupMessage // out
	var _cret *C.char        // in

	_arg0 = (*C.SoupAuth)(unsafe.Pointer(auth.Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	_cret = C.soup_auth_get_authorization(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Host returns the host that auth is associated with.
func (auth *Auth) Host() string {
	var _arg0 *C.SoupAuth // out
	var _cret *C.char     // in

	_arg0 = (*C.SoupAuth)(unsafe.Pointer(auth.Native()))

	_cret = C.soup_auth_get_host(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Info gets an opaque identifier for auth, for use as a hash key or the like.
// Auth objects from the same server with the same identifier refer to the same
// authentication domain (eg, the URLs associated with them take the same
// usernames and passwords).
func (auth *Auth) Info() string {
	var _arg0 *C.SoupAuth // out
	var _cret *C.char     // in

	_arg0 = (*C.SoupAuth)(unsafe.Pointer(auth.Native()))

	_cret = C.soup_auth_get_info(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Realm returns auth's realm. This is an identifier that distinguishes separate
// authentication spaces on a given server, and may be some string that is
// meaningful to the user. (Although it is probably not localized.)
func (auth *Auth) Realm() string {
	var _arg0 *C.SoupAuth // out
	var _cret *C.char     // in

	_arg0 = (*C.SoupAuth)(unsafe.Pointer(auth.Native()))

	_cret = C.soup_auth_get_realm(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

func (auth *Auth) SavedPassword(user string) string {
	var _arg0 *C.SoupAuth // out
	var _arg1 *C.char     // out
	var _cret *C.char     // in

	_arg0 = (*C.SoupAuth)(unsafe.Pointer(auth.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(user)))

	_cret = C.soup_auth_get_saved_password(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// SchemeName returns auth's scheme name. (Eg, "Basic", "Digest", or "NTLM")
func (auth *Auth) SchemeName() string {
	var _arg0 *C.SoupAuth // out
	var _cret *C.char     // in

	_arg0 = (*C.SoupAuth)(unsafe.Pointer(auth.Native()))

	_cret = C.soup_auth_get_scheme_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

func (auth *Auth) HasSavedPassword(username string, password string) {
	var _arg0 *C.SoupAuth // out
	var _arg1 *C.char     // out
	var _arg2 *C.char     // out

	_arg0 = (*C.SoupAuth)(unsafe.Pointer(auth.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(username)))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(password)))

	C.soup_auth_has_saved_password(_arg0, _arg1, _arg2)
}

// IsAuthenticated tests if auth has been given a username and password
func (auth *Auth) IsAuthenticated() bool {
	var _arg0 *C.SoupAuth // out
	var _cret C.gboolean  // in

	_arg0 = (*C.SoupAuth)(unsafe.Pointer(auth.Native()))

	_cret = C.soup_auth_is_authenticated(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsForProxy tests whether or not auth is associated with a proxy server rather
// than an "origin" server.
func (auth *Auth) IsForProxy() bool {
	var _arg0 *C.SoupAuth // out
	var _cret C.gboolean  // in

	_arg0 = (*C.SoupAuth)(unsafe.Pointer(auth.Native()))

	_cret = C.soup_auth_is_for_proxy(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsReady tests if auth is ready to make a request for msg with. For most
// auths, this is equivalent to soup_auth_is_authenticated(), but for some auth
// types (eg, NTLM), the auth may be sendable (eg, as an authentication request)
// even before it is authenticated.
func (auth *Auth) IsReady(msg *Message) bool {
	var _arg0 *C.SoupAuth    // out
	var _arg1 *C.SoupMessage // out
	var _cret C.gboolean     // in

	_arg0 = (*C.SoupAuth)(unsafe.Pointer(auth.Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	_cret = C.soup_auth_is_ready(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (auth *Auth) SavePassword(username string, password string) {
	var _arg0 *C.SoupAuth // out
	var _arg1 *C.char     // out
	var _arg2 *C.char     // out

	_arg0 = (*C.SoupAuth)(unsafe.Pointer(auth.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(username)))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(password)))

	C.soup_auth_save_password(_arg0, _arg1, _arg2)
}

// Update updates auth with the information from msg and auth_header, possibly
// un-authenticating it. As with soup_auth_new(), this is normally only used by
// Session.
func (auth *Auth) Update(msg *Message, authHeader string) bool {
	var _arg0 *C.SoupAuth    // out
	var _arg1 *C.SoupMessage // out
	var _arg2 *C.char        // out
	var _cret C.gboolean     // in

	_arg0 = (*C.SoupAuth)(unsafe.Pointer(auth.Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(authHeader)))

	_cret = C.soup_auth_update(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AuthNegotiateSupported indicates whether libsoup was built with GSSAPI
// support. If this is FALSE, SOUP_TYPE_AUTH_NEGOTIATE will still be defined and
// can still be added to a Session, but libsoup will never attempt to actually
// use this auth type.
func AuthNegotiateSupported() bool {
	var _cret C.gboolean // in

	_cret = C.soup_auth_negotiate_supported()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
