// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"fmt"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: libsoup-2.4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <libsoup/soup.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.soup_cookie_jar_accept_policy_get_type()), F: marshalCookieJarAcceptPolicy},
		{T: externglib.Type(C.soup_cookie_jar_get_type()), F: marshalCookieJarrer},
	})
}

// CookieJarAcceptPolicy: policy for accepting or rejecting cookies returned in
// responses.
type CookieJarAcceptPolicy int

const (
	// CookieJarAcceptAlways: accept all cookies unconditionally.
	CookieJarAcceptAlways CookieJarAcceptPolicy = iota
	// CookieJarAcceptNever: reject all cookies unconditionally.
	CookieJarAcceptNever
	// CookieJarAcceptNoThirdParty: accept all cookies set by the main document
	// loaded in the application using libsoup. An example of the most common
	// case, web browsers, would be: If http://www.example.com is the page
	// loaded, accept all cookies set by example.com, but if a resource from
	// http://www.third-party.com is loaded from that page reject any cookie
	// that it could try to set. For libsoup to be able to tell apart first
	// party cookies from the rest, the application must call
	// soup_message_set_first_party() on each outgoing Message, setting the URI
	// of the main document. If no first party is set in a message when this
	// policy is in effect, cookies will be assumed to be third party by
	// default.
	CookieJarAcceptNoThirdParty
	// CookieJarAcceptGrandfatheredThirdParty: accept all cookies set by the
	// main document loaded in the application using libsoup, and from domains
	// that have previously set at least one cookie when loaded as the main
	// document. An example of the most common case, web browsers, would be: if
	// http://www.example.com is the page loaded, accept all cookies set by
	// example.com, but if a resource from http://www.third-party.com is loaded
	// from that page, reject any cookie that it could try to set unless it
	// already has a cookie in the cookie jar. For libsoup to be able to tell
	// apart first party cookies from the rest, the application must call
	// soup_message_set_first_party() on each outgoing Message, setting the URI
	// of the main document. If no first party is set in a message when this
	// policy is in effect, cookies will be assumed to be third party by
	// default. Since 2.72.
	CookieJarAcceptGrandfatheredThirdParty
)

func marshalCookieJarAcceptPolicy(p uintptr) (interface{}, error) {
	return CookieJarAcceptPolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for CookieJarAcceptPolicy.
func (c CookieJarAcceptPolicy) String() string {
	switch c {
	case CookieJarAcceptAlways:
		return "Always"
	case CookieJarAcceptNever:
		return "Never"
	case CookieJarAcceptNoThirdParty:
		return "NoThirdParty"
	case CookieJarAcceptGrandfatheredThirdParty:
		return "GrandfatheredThirdParty"
	default:
		return fmt.Sprintf("CookieJarAcceptPolicy(%d)", c)
	}
}

// CookieJarOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type CookieJarOverrider interface {
	Changed(oldCookie *Cookie, newCookie *Cookie)
	// IsPersistent gets whether jar stores cookies persistenly.
	IsPersistent() bool
	// Save: this function exists for backward compatibility, but does not do
	// anything any more; cookie jars are saved automatically when they are
	// changed.
	//
	// Deprecated: This is a no-op.
	Save()
}

type CookieJar struct {
	*externglib.Object

	SessionFeature
}

var _ gextras.Nativer = (*CookieJar)(nil)

func wrapCookieJar(obj *externglib.Object) *CookieJar {
	return &CookieJar{
		Object: obj,
		SessionFeature: SessionFeature{
			Object: obj,
		},
	}
}

func marshalCookieJarrer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapCookieJar(obj), nil
}

// NewCookieJar creates a new CookieJar. The base CookieJar class does not
// support persistent storage of cookies; use a subclass for that.
func NewCookieJar() *CookieJar {
	var _cret *C.SoupCookieJar // in

	_cret = C.soup_cookie_jar_new()

	var _cookieJar *CookieJar // out

	_cookieJar = wrapCookieJar(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cookieJar
}

// AddCookie adds cookie to jar, emitting the 'changed' signal if we are
// modifying an existing cookie or adding a valid new cookie ('valid' means that
// the cookie's expire date is not in the past).
//
// cookie will be 'stolen' by the jar, so don't free it afterwards.
func (jar *CookieJar) AddCookie(cookie *Cookie) {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.SoupCookie    // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))
	_arg1 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	C.soup_cookie_jar_add_cookie(_arg0, _arg1)
}

// AddCookieFull adds cookie to jar, emitting the 'changed' signal if we are
// modifying an existing cookie or adding a valid new cookie ('valid' means that
// the cookie's expire date is not in the past).
//
// first_party will be used to reject cookies coming from third party resources
// in case such a security policy is set in the jar.
//
// uri will be used to reject setting or overwriting secure cookies from
// insecure origins. NULL is treated as secure.
//
// cookie will be 'stolen' by the jar, so don't free it afterwards.
func (jar *CookieJar) AddCookieFull(cookie *Cookie, uri *URI, firstParty *URI) {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.SoupCookie    // out
	var _arg2 *C.SoupURI       // out
	var _arg3 *C.SoupURI       // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))
	_arg1 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	_arg2 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(uri)))
	_arg3 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(firstParty)))

	C.soup_cookie_jar_add_cookie_full(_arg0, _arg1, _arg2, _arg3)
}

// AddCookieWithFirstParty adds cookie to jar, emitting the 'changed' signal if
// we are modifying an existing cookie or adding a valid new cookie ('valid'
// means that the cookie's expire date is not in the past).
//
// first_party will be used to reject cookies coming from third party resources
// in case such a security policy is set in the jar.
//
// cookie will be 'stolen' by the jar, so don't free it afterwards.
//
// For secure cookies to work properly you may want to use
// soup_cookie_jar_add_cookie_full().
func (jar *CookieJar) AddCookieWithFirstParty(firstParty *URI, cookie *Cookie) {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.SoupURI       // out
	var _arg2 *C.SoupCookie    // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))
	_arg1 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(firstParty)))
	_arg2 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	C.soup_cookie_jar_add_cookie_with_first_party(_arg0, _arg1, _arg2)
}

// DeleteCookie deletes cookie from jar, emitting the 'changed' signal.
func (jar *CookieJar) DeleteCookie(cookie *Cookie) {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.SoupCookie    // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))
	_arg1 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	C.soup_cookie_jar_delete_cookie(_arg0, _arg1)
}

// AcceptPolicy gets jar's CookieJarAcceptPolicy
func (jar *CookieJar) AcceptPolicy() CookieJarAcceptPolicy {
	var _arg0 *C.SoupCookieJar            // out
	var _cret C.SoupCookieJarAcceptPolicy // in

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))

	_cret = C.soup_cookie_jar_get_accept_policy(_arg0)

	var _cookieJarAcceptPolicy CookieJarAcceptPolicy // out

	_cookieJarAcceptPolicy = CookieJarAcceptPolicy(_cret)

	return _cookieJarAcceptPolicy
}

// Cookies retrieves (in Cookie-header form) the list of cookies that would be
// sent with a request to uri.
//
// If for_http is TRUE, the return value will include cookies marked "HttpOnly"
// (that is, cookies that the server wishes to keep hidden from client-side
// scripting operations such as the JavaScript document.cookies property). Since
// CookieJar sets the Cookie header itself when making the actual HTTP request,
// you should almost certainly be setting for_http to FALSE if you are calling
// this.
func (jar *CookieJar) Cookies(uri *URI, forHttp bool) string {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.SoupURI       // out
	var _arg2 C.gboolean       // out
	var _cret *C.char          // in

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))
	_arg1 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(uri)))
	if forHttp {
		_arg2 = C.TRUE
	}

	_cret = C.soup_cookie_jar_get_cookies(_arg0, _arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// IsPersistent gets whether jar stores cookies persistenly.
func (jar *CookieJar) IsPersistent() bool {
	var _arg0 *C.SoupCookieJar // out
	var _cret C.gboolean       // in

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))

	_cret = C.soup_cookie_jar_is_persistent(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Save: this function exists for backward compatibility, but does not do
// anything any more; cookie jars are saved automatically when they are changed.
//
// Deprecated: This is a no-op.
func (jar *CookieJar) Save() {
	var _arg0 *C.SoupCookieJar // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))

	C.soup_cookie_jar_save(_arg0)
}

// SetAcceptPolicy sets policy as the cookie acceptance policy for jar.
func (jar *CookieJar) SetAcceptPolicy(policy CookieJarAcceptPolicy) {
	var _arg0 *C.SoupCookieJar            // out
	var _arg1 C.SoupCookieJarAcceptPolicy // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))
	_arg1 = C.SoupCookieJarAcceptPolicy(policy)

	C.soup_cookie_jar_set_accept_policy(_arg0, _arg1)
}

// SetCookie adds cookie to jar, exactly as though it had appeared in a
// Set-Cookie header returned from a request to uri.
//
// Keep in mind that if the CookieJarAcceptPolicy set is either
// SOUP_COOKIE_JAR_ACCEPT_NO_THIRD_PARTY or
// SOUP_COOKIE_JAR_ACCEPT_GRANDFATHERED_THIRD_PARTY you'll need to use
// soup_cookie_jar_set_cookie_with_first_party(), otherwise the jar will have no
// way of knowing if the cookie is being set by a third party or not.
func (jar *CookieJar) SetCookie(uri *URI, cookie string) {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.SoupURI       // out
	var _arg2 *C.char          // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))
	_arg1 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(uri)))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(cookie)))

	C.soup_cookie_jar_set_cookie(_arg0, _arg1, _arg2)
}

// SetCookieWithFirstParty adds cookie to jar, exactly as though it had appeared
// in a Set-Cookie header returned from a request to uri. first_party will be
// used to reject cookies coming from third party resources in case such a
// security policy is set in the jar.
func (jar *CookieJar) SetCookieWithFirstParty(uri *URI, firstParty *URI, cookie string) {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.SoupURI       // out
	var _arg2 *C.SoupURI       // out
	var _arg3 *C.char          // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))
	_arg1 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(uri)))
	_arg2 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(firstParty)))
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(cookie)))

	C.soup_cookie_jar_set_cookie_with_first_party(_arg0, _arg1, _arg2, _arg3)
}
