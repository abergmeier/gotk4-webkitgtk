// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: libsoup-2.4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <libsoup/soup.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.soup_cookie_jar_accept_policy_get_type()), F: marshalCookieJarAcceptPolicy},
		{T: externglib.Type(C.soup_cookie_jar_get_type()), F: marshalCookieJarrer},
	})
}

// COOKIE_JAR_ACCEPT_POLICY alias for the CookieJar:accept-policy property.
const COOKIE_JAR_ACCEPT_POLICY = "accept-policy"

// COOKIE_JAR_READ_ONLY alias for the CookieJar:read-only property. (Whether or
// not the cookie jar is read-only.).
const COOKIE_JAR_READ_ONLY = "read-only"

// CookieJarAcceptPolicy: policy for accepting or rejecting cookies returned in
// responses.
type CookieJarAcceptPolicy C.gint

const (
	// CookieJarAcceptAlways: accept all cookies unconditionally.
	CookieJarAcceptAlways CookieJarAcceptPolicy = iota
	// CookieJarAcceptNever: reject all cookies unconditionally.
	CookieJarAcceptNever
	// CookieJarAcceptNoThirdParty: accept all cookies set by the main document
	// loaded in the application using libsoup. An example of the most common
	// case, web browsers, would be: If http://www.example.com is the page
	// loaded, accept all cookies set by example.com, but if a resource from
	// http://www.third-party.com is loaded from that page reject any cookie
	// that it could try to set. For libsoup to be able to tell apart first
	// party cookies from the rest, the application must call
	// soup_message_set_first_party() on each outgoing Message, setting the URI
	// of the main document. If no first party is set in a message when this
	// policy is in effect, cookies will be assumed to be third party by
	// default.
	CookieJarAcceptNoThirdParty
	// CookieJarAcceptGrandfatheredThirdParty: accept all cookies set by the
	// main document loaded in the application using libsoup, and from domains
	// that have previously set at least one cookie when loaded as the main
	// document. An example of the most common case, web browsers, would be: if
	// http://www.example.com is the page loaded, accept all cookies set by
	// example.com, but if a resource from http://www.third-party.com is loaded
	// from that page, reject any cookie that it could try to set unless it
	// already has a cookie in the cookie jar. For libsoup to be able to tell
	// apart first party cookies from the rest, the application must call
	// soup_message_set_first_party() on each outgoing Message, setting the URI
	// of the main document. If no first party is set in a message when this
	// policy is in effect, cookies will be assumed to be third party by
	// default. Since 2.72.
	CookieJarAcceptGrandfatheredThirdParty
)

func marshalCookieJarAcceptPolicy(p uintptr) (interface{}, error) {
	return CookieJarAcceptPolicy(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CookieJarAcceptPolicy.
func (c CookieJarAcceptPolicy) String() string {
	switch c {
	case CookieJarAcceptAlways:
		return "Always"
	case CookieJarAcceptNever:
		return "Never"
	case CookieJarAcceptNoThirdParty:
		return "NoThirdParty"
	case CookieJarAcceptGrandfatheredThirdParty:
		return "GrandfatheredThirdParty"
	default:
		return fmt.Sprintf("CookieJarAcceptPolicy(%d)", c)
	}
}

// CookieJarOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type CookieJarOverrider interface {
	Changed(oldCookie, newCookie *Cookie)
	// IsPersistent gets whether jar stores cookies persistenly.
	IsPersistent() bool
	// Save: this function exists for backward compatibility, but does not do
	// anything any more; cookie jars are saved automatically when they are
	// changed.
	//
	// Deprecated: This is a no-op.
	Save()
}

type CookieJar struct {
	*externglib.Object

	SessionFeature
}

var (
	_ externglib.Objector = (*CookieJar)(nil)
)

func wrapCookieJar(obj *externglib.Object) *CookieJar {
	return &CookieJar{
		Object: obj,
		SessionFeature: SessionFeature{
			Object: obj,
		},
	}
}

func marshalCookieJarrer(p uintptr) (interface{}, error) {
	return wrapCookieJar(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewCookieJar creates a new CookieJar. The base CookieJar class does not
// support persistent storage of cookies; use a subclass for that.
func NewCookieJar() *CookieJar {
	var _cret *C.SoupCookieJar // in

	_cret = C.soup_cookie_jar_new()

	var _cookieJar *CookieJar // out

	_cookieJar = wrapCookieJar(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cookieJar
}

// AddCookie adds cookie to jar, emitting the 'changed' signal if we are
// modifying an existing cookie or adding a valid new cookie ('valid' means that
// the cookie's expire date is not in the past).
//
// cookie will be 'stolen' by the jar, so don't free it afterwards.
//
// The function takes the following parameters:
//
//    - cookie: Cookie.
//
func (jar *CookieJar) AddCookie(cookie *Cookie) {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.SoupCookie    // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))
	_arg1 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(cookie)), nil)

	C.soup_cookie_jar_add_cookie(_arg0, _arg1)
	runtime.KeepAlive(jar)
	runtime.KeepAlive(cookie)
}

// AddCookieFull adds cookie to jar, emitting the 'changed' signal if we are
// modifying an existing cookie or adding a valid new cookie ('valid' means that
// the cookie's expire date is not in the past).
//
// first_party will be used to reject cookies coming from third party resources
// in case such a security policy is set in the jar.
//
// uri will be used to reject setting or overwriting secure cookies from
// insecure origins. NULL is treated as secure.
//
// cookie will be 'stolen' by the jar, so don't free it afterwards.
//
// The function takes the following parameters:
//
//    - cookie: Cookie.
//    - uri: URI setting the cookie.
//    - firstParty: URI for the main document.
//
func (jar *CookieJar) AddCookieFull(cookie *Cookie, uri, firstParty *URI) {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.SoupCookie    // out
	var _arg2 *C.SoupURI       // out
	var _arg3 *C.SoupURI       // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))
	_arg1 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(cookie)), nil)
	if uri != nil {
		_arg2 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	if firstParty != nil {
		_arg3 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(firstParty)))
	}

	C.soup_cookie_jar_add_cookie_full(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(jar)
	runtime.KeepAlive(cookie)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(firstParty)
}

// AddCookieWithFirstParty adds cookie to jar, emitting the 'changed' signal if
// we are modifying an existing cookie or adding a valid new cookie ('valid'
// means that the cookie's expire date is not in the past).
//
// first_party will be used to reject cookies coming from third party resources
// in case such a security policy is set in the jar.
//
// cookie will be 'stolen' by the jar, so don't free it afterwards.
//
// For secure cookies to work properly you may want to use
// soup_cookie_jar_add_cookie_full().
//
// The function takes the following parameters:
//
//    - firstParty: URI for the main document.
//    - cookie: Cookie.
//
func (jar *CookieJar) AddCookieWithFirstParty(firstParty *URI, cookie *Cookie) {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.SoupURI       // out
	var _arg2 *C.SoupCookie    // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))
	_arg1 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(firstParty)))
	_arg2 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(cookie)), nil)

	C.soup_cookie_jar_add_cookie_with_first_party(_arg0, _arg1, _arg2)
	runtime.KeepAlive(jar)
	runtime.KeepAlive(firstParty)
	runtime.KeepAlive(cookie)
}

// AllCookies constructs a List with every cookie inside the jar. The cookies in
// the list are a copy of the original, so you have to free them when you are
// done with them.
func (jar *CookieJar) AllCookies() []*Cookie {
	var _arg0 *C.SoupCookieJar // out
	var _cret *C.GSList        // in

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))

	_cret = C.soup_cookie_jar_all_cookies(_arg0)
	runtime.KeepAlive(jar)

	var _sList []*Cookie // out

	_sList = make([]*Cookie, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.SoupCookie)(v)
		var dst *Cookie // out
		dst = (*Cookie)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.soup_cookie_free((*C.SoupCookie)(intern.C))
			},
		)
		_sList = append(_sList, dst)
	})

	return _sList
}

// DeleteCookie deletes cookie from jar, emitting the 'changed' signal.
//
// The function takes the following parameters:
//
//    - cookie: Cookie.
//
func (jar *CookieJar) DeleteCookie(cookie *Cookie) {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.SoupCookie    // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))
	_arg1 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	C.soup_cookie_jar_delete_cookie(_arg0, _arg1)
	runtime.KeepAlive(jar)
	runtime.KeepAlive(cookie)
}

// AcceptPolicy gets jar's CookieJarAcceptPolicy.
func (jar *CookieJar) AcceptPolicy() CookieJarAcceptPolicy {
	var _arg0 *C.SoupCookieJar            // out
	var _cret C.SoupCookieJarAcceptPolicy // in

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))

	_cret = C.soup_cookie_jar_get_accept_policy(_arg0)
	runtime.KeepAlive(jar)

	var _cookieJarAcceptPolicy CookieJarAcceptPolicy // out

	_cookieJarAcceptPolicy = CookieJarAcceptPolicy(_cret)

	return _cookieJarAcceptPolicy
}

// CookieList retrieves the list of cookies that would be sent with a request to
// uri as a List of Cookie objects.
//
// If for_http is TRUE, the return value will include cookies marked "HttpOnly"
// (that is, cookies that the server wishes to keep hidden from client-side
// scripting operations such as the JavaScript document.cookies property). Since
// CookieJar sets the Cookie header itself when making the actual HTTP request,
// you should almost certainly be setting for_http to FALSE if you are calling
// this.
//
// The function takes the following parameters:
//
//    - uri: URI.
//    - forHttp: whether or not the return value is being passed directly to an
//    HTTP operation.
//
func (jar *CookieJar) CookieList(uri *URI, forHttp bool) []*Cookie {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.SoupURI       // out
	var _arg2 C.gboolean       // out
	var _cret *C.GSList        // in

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))
	_arg1 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(uri)))
	if forHttp {
		_arg2 = C.TRUE
	}

	_cret = C.soup_cookie_jar_get_cookie_list(_arg0, _arg1, _arg2)
	runtime.KeepAlive(jar)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(forHttp)

	var _sList []*Cookie // out

	_sList = make([]*Cookie, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.SoupCookie)(v)
		var dst *Cookie // out
		dst = (*Cookie)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.soup_cookie_free((*C.SoupCookie)(intern.C))
			},
		)
		_sList = append(_sList, dst)
	})

	return _sList
}

// CookieListWithSameSiteInfo: this is an extended version of
// soup_cookie_jar_get_cookie_list() that provides more information required to
// use SameSite cookies. See the SameSite cookies spec
// (https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00) for more
// detailed information.
//
// The function takes the following parameters:
//
//    - uri: URI.
//    - topLevel for the top level document.
//    - siteForCookies indicating the origin to get cookies for.
//    - forHttp: whether or not the return value is being passed directly to an
//    HTTP operation.
//    - isSafeMethod: if the HTTP method is safe, as defined by RFC 7231,
//    ignored when for_http is FALSE.
//    - isTopLevelNavigation: whether or not the HTTP request is part of top
//    level navigation.
//
func (jar *CookieJar) CookieListWithSameSiteInfo(uri, topLevel, siteForCookies *URI, forHttp, isSafeMethod, isTopLevelNavigation bool) []*Cookie {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.SoupURI       // out
	var _arg2 *C.SoupURI       // out
	var _arg3 *C.SoupURI       // out
	var _arg4 C.gboolean       // out
	var _arg5 C.gboolean       // out
	var _arg6 C.gboolean       // out
	var _cret *C.GSList        // in

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))
	_arg1 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(uri)))
	if topLevel != nil {
		_arg2 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(topLevel)))
	}
	if siteForCookies != nil {
		_arg3 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(siteForCookies)))
	}
	if forHttp {
		_arg4 = C.TRUE
	}
	if isSafeMethod {
		_arg5 = C.TRUE
	}
	if isTopLevelNavigation {
		_arg6 = C.TRUE
	}

	_cret = C.soup_cookie_jar_get_cookie_list_with_same_site_info(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(jar)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(topLevel)
	runtime.KeepAlive(siteForCookies)
	runtime.KeepAlive(forHttp)
	runtime.KeepAlive(isSafeMethod)
	runtime.KeepAlive(isTopLevelNavigation)

	var _sList []*Cookie // out

	_sList = make([]*Cookie, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.SoupCookie)(v)
		var dst *Cookie // out
		dst = (*Cookie)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.soup_cookie_free((*C.SoupCookie)(intern.C))
			},
		)
		_sList = append(_sList, dst)
	})

	return _sList
}

// Cookies retrieves (in Cookie-header form) the list of cookies that would be
// sent with a request to uri.
//
// If for_http is TRUE, the return value will include cookies marked "HttpOnly"
// (that is, cookies that the server wishes to keep hidden from client-side
// scripting operations such as the JavaScript document.cookies property). Since
// CookieJar sets the Cookie header itself when making the actual HTTP request,
// you should almost certainly be setting for_http to FALSE if you are calling
// this.
//
// The function takes the following parameters:
//
//    - uri: URI.
//    - forHttp: whether or not the return value is being passed directly to an
//    HTTP operation.
//
func (jar *CookieJar) Cookies(uri *URI, forHttp bool) string {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.SoupURI       // out
	var _arg2 C.gboolean       // out
	var _cret *C.char          // in

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))
	_arg1 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(uri)))
	if forHttp {
		_arg2 = C.TRUE
	}

	_cret = C.soup_cookie_jar_get_cookies(_arg0, _arg1, _arg2)
	runtime.KeepAlive(jar)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(forHttp)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// IsPersistent gets whether jar stores cookies persistenly.
func (jar *CookieJar) IsPersistent() bool {
	var _arg0 *C.SoupCookieJar // out
	var _cret C.gboolean       // in

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))

	_cret = C.soup_cookie_jar_is_persistent(_arg0)
	runtime.KeepAlive(jar)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Save: this function exists for backward compatibility, but does not do
// anything any more; cookie jars are saved automatically when they are changed.
//
// Deprecated: This is a no-op.
func (jar *CookieJar) Save() {
	var _arg0 *C.SoupCookieJar // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))

	C.soup_cookie_jar_save(_arg0)
	runtime.KeepAlive(jar)
}

// SetAcceptPolicy sets policy as the cookie acceptance policy for jar.
//
// The function takes the following parameters:
//
//    - policy: CookieJarAcceptPolicy.
//
func (jar *CookieJar) SetAcceptPolicy(policy CookieJarAcceptPolicy) {
	var _arg0 *C.SoupCookieJar            // out
	var _arg1 C.SoupCookieJarAcceptPolicy // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))
	_arg1 = C.SoupCookieJarAcceptPolicy(policy)

	C.soup_cookie_jar_set_accept_policy(_arg0, _arg1)
	runtime.KeepAlive(jar)
	runtime.KeepAlive(policy)
}

// SetCookie adds cookie to jar, exactly as though it had appeared in a
// Set-Cookie header returned from a request to uri.
//
// Keep in mind that if the CookieJarAcceptPolicy set is either
// SOUP_COOKIE_JAR_ACCEPT_NO_THIRD_PARTY or
// SOUP_COOKIE_JAR_ACCEPT_GRANDFATHERED_THIRD_PARTY you'll need to use
// soup_cookie_jar_set_cookie_with_first_party(), otherwise the jar will have no
// way of knowing if the cookie is being set by a third party or not.
//
// The function takes the following parameters:
//
//    - uri: URI setting the cookie.
//    - cookie: stringified cookie to set.
//
func (jar *CookieJar) SetCookie(uri *URI, cookie string) {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.SoupURI       // out
	var _arg2 *C.char          // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))
	_arg1 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(uri)))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(cookie)))
	defer C.free(unsafe.Pointer(_arg2))

	C.soup_cookie_jar_set_cookie(_arg0, _arg1, _arg2)
	runtime.KeepAlive(jar)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(cookie)
}

// SetCookieWithFirstParty adds cookie to jar, exactly as though it had appeared
// in a Set-Cookie header returned from a request to uri. first_party will be
// used to reject cookies coming from third party resources in case such a
// security policy is set in the jar.
//
// The function takes the following parameters:
//
//    - uri: URI setting the cookie.
//    - firstParty: URI for the main document.
//    - cookie: stringified cookie to set.
//
func (jar *CookieJar) SetCookieWithFirstParty(uri, firstParty *URI, cookie string) {
	var _arg0 *C.SoupCookieJar // out
	var _arg1 *C.SoupURI       // out
	var _arg2 *C.SoupURI       // out
	var _arg3 *C.char          // out

	_arg0 = (*C.SoupCookieJar)(unsafe.Pointer(jar.Native()))
	_arg1 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(uri)))
	_arg2 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(firstParty)))
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(cookie)))
	defer C.free(unsafe.Pointer(_arg3))

	C.soup_cookie_jar_set_cookie_with_first_party(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(jar)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(firstParty)
	runtime.KeepAlive(cookie)
}

// ConnectChanged: emitted when jar changes. If a cookie has been added,
// new_cookie will contain the newly-added cookie and old_cookie will be NULL.
// If a cookie has been deleted, old_cookie will contain the to-be-deleted
// cookie and new_cookie will be NULL. If a cookie has been changed, old_cookie
// will contain its old value, and new_cookie its new value.
func (jar *CookieJar) ConnectChanged(f func(oldCookie, newCookie *Cookie)) externglib.SignalHandle {
	return jar.Connect("changed", f)
}
