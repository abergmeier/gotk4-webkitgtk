// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: libsoup-2.4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <libsoup/soup.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.soup_cookie_get_type()), F: marshalCookie},
	})
}

// Cookie: HTTP cookie.
//
// name and value will be set for all cookies. If the cookie is generated from a
// string that appears to have no name, then name will be the empty string.
//
// domain and path give the host or domain, and path within that host/domain, to
// restrict this cookie to. If domain starts with ".", that indicates a domain
// (which matches the string after the ".", or any hostname that has domain as a
// suffix). Otherwise, it is a hostname and must match exactly.
//
// expires will be non-NULL if the cookie uses either the original "expires"
// attribute, or the newer "max-age" attribute. If expires is NULL, it indicates
// that neither "expires" nor "max-age" was specified, and the cookie expires at
// the end of the session.
//
// If http_only is set, the cookie should not be exposed to untrusted code (eg,
// javascript), so as to minimize the danger posed by cross-site scripting
// attacks.
type Cookie struct {
	nocopy gextras.NoCopy
	native *C.SoupCookie
}

func marshalCookie(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return &Cookie{native: (*C.SoupCookie)(unsafe.Pointer(b))}, nil
}

// NewCookie constructs a struct Cookie.
func NewCookie(name string, value string, domain string, path string, maxAge int) *Cookie {
	var _arg1 *C.char       // out
	var _arg2 *C.char       // out
	var _arg3 *C.char       // out
	var _arg4 *C.char       // out
	var _arg5 C.int         // out
	var _cret *C.SoupCookie // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(value)))
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(domain)))
	_arg4 = (*C.char)(unsafe.Pointer(C.CString(path)))
	_arg5 = C.int(maxAge)

	_cret = C.soup_cookie_new(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _cookie *Cookie // out

	_cookie = (*Cookie)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_cookie, func(v *Cookie) {
		C.soup_cookie_free((*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(v))))
	})

	return _cookie
}

// AppliesToURI tests if cookie should be sent to uri.
//
// (At the moment, this does not check that cookie's domain matches uri, because
// it assumes that the caller has already done that. But don't rely on that; it
// may change in the future.)
func (cookie *Cookie) AppliesToURI(uri *URI) bool {
	var _arg0 *C.SoupCookie // out
	var _arg1 *C.SoupURI    // out
	var _cret C.gboolean    // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	_arg1 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.soup_cookie_applies_to_uri(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Copy copies cookie.
func (cookie *Cookie) Copy() *Cookie {
	var _arg0 *C.SoupCookie // out
	var _cret *C.SoupCookie // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	_cret = C.soup_cookie_copy(_arg0)

	var _ret *Cookie // out

	_ret = (*Cookie)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_ret, func(v *Cookie) {
		C.soup_cookie_free((*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(v))))
	})

	return _ret
}

// DomainMatches checks if the cookie's domain and host match in the sense that
// cookie should be sent when making a request to host, or that cookie should be
// accepted when receiving a response from host.
func (cookie *Cookie) DomainMatches(host string) bool {
	var _arg0 *C.SoupCookie // out
	var _arg1 *C.char       // out
	var _cret C.gboolean    // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(host)))

	_cret = C.soup_cookie_domain_matches(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Equal tests if cookie1 and cookie2 are equal.
//
// Note that currently, this does not check that the cookie domains match. This
// may change in the future.
func (cookie1 *Cookie) Equal(cookie2 *Cookie) bool {
	var _arg0 *C.SoupCookie // out
	var _arg1 *C.SoupCookie // out
	var _cret C.gboolean    // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie1)))
	_arg1 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie2)))

	_cret = C.soup_cookie_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Free frees cookie
func (cookie *Cookie) free() {
	var _arg0 *C.SoupCookie // out

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	C.soup_cookie_free(_arg0)
}

// Domain gets cookie's domain
func (cookie *Cookie) Domain() string {
	var _arg0 *C.SoupCookie // out
	var _cret *C.char       // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	_cret = C.soup_cookie_get_domain(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Expires gets cookie's expiration time.
func (cookie *Cookie) Expires() *Date {
	var _arg0 *C.SoupCookie // out
	var _cret *C.SoupDate   // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	_cret = C.soup_cookie_get_expires(_arg0)

	var _date *Date // out

	_date = (*Date)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _date
}

// HttpOnly gets cookie's HttpOnly attribute
func (cookie *Cookie) HttpOnly() bool {
	var _arg0 *C.SoupCookie // out
	var _cret C.gboolean    // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	_cret = C.soup_cookie_get_http_only(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Name gets cookie's name
func (cookie *Cookie) Name() string {
	var _arg0 *C.SoupCookie // out
	var _cret *C.char       // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	_cret = C.soup_cookie_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Path gets cookie's path
func (cookie *Cookie) Path() string {
	var _arg0 *C.SoupCookie // out
	var _cret *C.char       // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	_cret = C.soup_cookie_get_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

func (cookie *Cookie) SameSitePolicy() SameSitePolicy {
	var _arg0 *C.SoupCookie        // out
	var _cret C.SoupSameSitePolicy // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	_cret = C.soup_cookie_get_same_site_policy(_arg0)

	var _sameSitePolicy SameSitePolicy // out

	_sameSitePolicy = SameSitePolicy(_cret)

	return _sameSitePolicy
}

// Secure gets cookie's secure attribute
func (cookie *Cookie) Secure() bool {
	var _arg0 *C.SoupCookie // out
	var _cret C.gboolean    // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	_cret = C.soup_cookie_get_secure(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Value gets cookie's value
func (cookie *Cookie) Value() string {
	var _arg0 *C.SoupCookie // out
	var _cret *C.char       // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	_cret = C.soup_cookie_get_value(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// SetDomain sets cookie's domain to domain
func (cookie *Cookie) SetDomain(domain string) {
	var _arg0 *C.SoupCookie // out
	var _arg1 *C.char       // out

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))

	C.soup_cookie_set_domain(_arg0, _arg1)
}

// SetExpires sets cookie's expiration time to expires. If expires is NULL,
// cookie will be a session cookie and will expire at the end of the client's
// session.
//
// (This sets the same property as soup_cookie_set_max_age().)
func (cookie *Cookie) SetExpires(expires *Date) {
	var _arg0 *C.SoupCookie // out
	var _arg1 *C.SoupDate   // out

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	_arg1 = (*C.SoupDate)(gextras.StructNative(unsafe.Pointer(expires)))

	C.soup_cookie_set_expires(_arg0, _arg1)
}

// SetHttpOnly sets cookie's HttpOnly attribute to http_only. If TRUE, cookie
// will be marked as "http only", meaning it should not be exposed to web page
// scripts or other untrusted code.
func (cookie *Cookie) SetHttpOnly(httpOnly bool) {
	var _arg0 *C.SoupCookie // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	if httpOnly {
		_arg1 = C.TRUE
	}

	C.soup_cookie_set_http_only(_arg0, _arg1)
}

// SetMaxAge sets cookie's max age to max_age. If max_age is -1, the cookie is a
// session cookie, and will expire at the end of the client's session.
// Otherwise, it is the number of seconds until the cookie expires. You can use
// the constants SOUP_COOKIE_MAX_AGE_ONE_HOUR, SOUP_COOKIE_MAX_AGE_ONE_DAY,
// SOUP_COOKIE_MAX_AGE_ONE_WEEK and SOUP_COOKIE_MAX_AGE_ONE_YEAR (or multiples
// thereof) to calculate this value. (A value of 0 indicates that the cookie
// should be considered already-expired.)
//
// (This sets the same property as soup_cookie_set_expires().)
func (cookie *Cookie) SetMaxAge(maxAge int) {
	var _arg0 *C.SoupCookie // out
	var _arg1 C.int         // out

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	_arg1 = C.int(maxAge)

	C.soup_cookie_set_max_age(_arg0, _arg1)
}

// SetName sets cookie's name to name
func (cookie *Cookie) SetName(name string) {
	var _arg0 *C.SoupCookie // out
	var _arg1 *C.char       // out

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))

	C.soup_cookie_set_name(_arg0, _arg1)
}

// SetPath sets cookie's path to path
func (cookie *Cookie) SetPath(path string) {
	var _arg0 *C.SoupCookie // out
	var _arg1 *C.char       // out

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))

	C.soup_cookie_set_path(_arg0, _arg1)
}

// SetSameSitePolicy: when used in conjunction with
// soup_cookie_jar_get_cookie_list_with_same_site_info() this sets the policy of
// when this cookie should be exposed.
func (cookie *Cookie) SetSameSitePolicy(policy SameSitePolicy) {
	var _arg0 *C.SoupCookie        // out
	var _arg1 C.SoupSameSitePolicy // out

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	_arg1 = C.SoupSameSitePolicy(policy)

	C.soup_cookie_set_same_site_policy(_arg0, _arg1)
}

// SetSecure sets cookie's secure attribute to secure. If TRUE, cookie will only
// be transmitted from the client to the server over secure (https) connections.
func (cookie *Cookie) SetSecure(secure bool) {
	var _arg0 *C.SoupCookie // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	if secure {
		_arg1 = C.TRUE
	}

	C.soup_cookie_set_secure(_arg0, _arg1)
}

// SetValue sets cookie's value to value
func (cookie *Cookie) SetValue(value string) {
	var _arg0 *C.SoupCookie // out
	var _arg1 *C.char       // out

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(value)))

	C.soup_cookie_set_value(_arg0, _arg1)
}

// ToCookieHeader serializes cookie in the format used by the Cookie header (ie,
// for returning a cookie from a Session to a server).
func (cookie *Cookie) ToCookieHeader() string {
	var _arg0 *C.SoupCookie // out
	var _cret *C.char       // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	_cret = C.soup_cookie_to_cookie_header(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ToSetCookieHeader serializes cookie in the format used by the Set-Cookie
// header (ie, for sending a cookie from a Server to a client).
func (cookie *Cookie) ToSetCookieHeader() string {
	var _arg0 *C.SoupCookie // out
	var _cret *C.char       // in

	_arg0 = (*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(cookie)))

	_cret = C.soup_cookie_to_set_cookie_header(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// CookieParse parses header and returns a Cookie. (If header contains multiple
// cookies, only the first one will be parsed.)
//
// If header does not have "path" or "domain" attributes, they will be defaulted
// from origin. If origin is NULL, path will default to "/", but domain will be
// left as NULL. Note that this is not a valid state for a Cookie, and you will
// need to fill in some appropriate string for the domain if you want to
// actually make use of the cookie.
func CookieParse(header string, origin *URI) *Cookie {
	var _arg1 *C.char       // out
	var _arg2 *C.SoupURI    // out
	var _cret *C.SoupCookie // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(header)))
	_arg2 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(origin)))

	_cret = C.soup_cookie_parse(_arg1, _arg2)

	var _cookie *Cookie // out

	_cookie = (*Cookie)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_cookie, func(v *Cookie) {
		C.soup_cookie_free((*C.SoupCookie)(gextras.StructNative(unsafe.Pointer(v))))
	})

	return _cookie
}
