// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: libsoup-2.4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <libsoup/soup.h>
import "C"

// FormDecode decodes form, which is an urlencoded dataset as defined in the
// HTML 4.01 spec.
func FormDecode(encodedForm string) *glib.HashTable {
	var _arg1 *C.char       // out
	var _cret *C.GHashTable // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(encodedForm)))

	_cret = C.soup_form_decode(_arg1)

	var _hashTable *glib.HashTable // out

	_hashTable = (*glib.HashTable)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_hashTable, func(v *glib.HashTable) {
		C.free(gextras.StructNative(unsafe.Pointer(v)))
	})

	return _hashTable
}

// FormDecodeMultipart decodes the "multipart/form-data" request in msg; this is
// a convenience method for the case when you have a single file upload control
// in a form. (Or when you don't have any file upload controls, but are still
// using "multipart/form-data" anyway.) Pass the name of the file upload control
// in file_control_name, and soup_form_decode_multipart() will extract the
// uploaded file data into filename, content_type, and file. All of the other
// form control data will be returned (as strings, as with soup_form_decode())
// in the returned Table.
//
// You may pass NULL for filename, content_type and/or file if you do not care
// about those fields. soup_form_decode_multipart() may also return NULL in
// those fields if the client did not provide that information. You must free
// the returned filename and content-type with g_free(), and the returned file
// data with soup_buffer_free().
//
// If you have a form with more than one file upload control, you will need to
// decode it manually, using soup_multipart_new_from_message() and
// soup_multipart_get_part().
func FormDecodeMultipart(msg *Message, fileControlName string) (filename string, contentType string, file *Buffer, hashTable *glib.HashTable) {
	var _arg1 *C.SoupMessage // out
	var _arg2 *C.char        // out
	var _arg3 *C.char        // in
	var _arg4 *C.char        // in
	var _arg5 *C.SoupBuffer  // in
	var _cret *C.GHashTable  // in

	_arg1 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(fileControlName)))

	_cret = C.soup_form_decode_multipart(_arg1, _arg2, &_arg3, &_arg4, &_arg5)

	var _filename string           // out
	var _contentType string        // out
	var _file *Buffer              // out
	var _hashTable *glib.HashTable // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
	defer C.free(unsafe.Pointer(_arg3))
	_contentType = C.GoString((*C.gchar)(unsafe.Pointer(_arg4)))
	defer C.free(unsafe.Pointer(_arg4))
	_file = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_arg5)))
	runtime.SetFinalizer(_file, func(v *Buffer) {
		C.soup_buffer_free((*C.SoupBuffer)(gextras.StructNative(unsafe.Pointer(v))))
	})
	_hashTable = (*glib.HashTable)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_hashTable, func(v *glib.HashTable) {
		C.free(gextras.StructNative(unsafe.Pointer(v)))
	})

	return _filename, _contentType, _file, _hashTable
}

// FormEncodeHash encodes form_data_set into a value of type
// "application/x-www-form-urlencoded", as defined in the HTML 4.01 spec.
//
// Note that the HTML spec states that "The control names/values are listed in
// the order they appear in the document." Since this method takes a hash table,
// it cannot enforce that; if you care about the ordering of the form fields,
// use soup_form_encode_datalist().
func FormEncodeHash(formDataSet *glib.HashTable) string {
	var _arg1 *C.GHashTable // out
	var _cret *C.char       // in

	_arg1 = (*C.GHashTable)(gextras.StructNative(unsafe.Pointer(formDataSet)))

	_cret = C.soup_form_encode_hash(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FormRequestNewFromHash creates a new SoupMessage and sets it up to send
// form_data_set to uri via method, as with soup_form_request_new().
func FormRequestNewFromHash(method string, uri string, formDataSet *glib.HashTable) *Message {
	var _arg1 *C.char        // out
	var _arg2 *C.char        // out
	var _arg3 *C.GHashTable  // out
	var _cret *C.SoupMessage // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(method)))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	_arg3 = (*C.GHashTable)(gextras.StructNative(unsafe.Pointer(formDataSet)))

	_cret = C.soup_form_request_new_from_hash(_arg1, _arg2, _arg3)

	var _message *Message // out

	_message = wrapMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _message
}

// FormRequestNewFromMultipart creates a new SoupMessage and sets it up to send
// multipart to uri via POST.
//
// To send a <literal>"multipart/form-data"</literal> POST, first create a
// Multipart, using SOUP_FORM_MIME_TYPE_MULTIPART as the MIME type. Then use
// soup_multipart_append_form_string() and soup_multipart_append_form_file() to
// add the value of each form control to the multipart. (These are just
// convenience methods, and you can use soup_multipart_append_part() if you need
// greater control over the part headers.) Finally, call
// soup_form_request_new_from_multipart() to serialize the multipart structure
// and create a Message.
func FormRequestNewFromMultipart(uri string, multipart *Multipart) *Message {
	var _arg1 *C.char          // out
	var _arg2 *C.SoupMultipart // out
	var _cret *C.SoupMessage   // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	_arg2 = (*C.SoupMultipart)(gextras.StructNative(unsafe.Pointer(multipart)))

	_cret = C.soup_form_request_new_from_multipart(_arg1, _arg2)

	var _message *Message // out

	_message = wrapMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _message
}
