// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <libsoup/soup.h>
import "C"

// FORM_MIME_TYPE_MULTIPART: macro containing the value
// <literal>"multipart/form-data"</literal>; the MIME type used for posting form
// data that contains files to be uploaded.
const FORM_MIME_TYPE_MULTIPART = "multipart/form-data"

// FORM_MIME_TYPE_URLENCODED: macro containing the value
// <literal>"application/x-www-form-urlencoded"</literal>; the default MIME type
// for POSTing HTML form data.
const FORM_MIME_TYPE_URLENCODED = "application/x-www-form-urlencoded"

// FormDecode decodes form, which is an urlencoded dataset as defined in the
// HTML 4.01 spec.
//
// The function takes the following parameters:
//
//    - encodedForm: data of type "application/x-www-form-urlencoded".
//
// The function returns the following values:
//
//    - hashTable: hash table containing the name/value pairs from encoded_form,
//      which you can free with g_hash_table_destroy().
//
func FormDecode(encodedForm string) map[string]string {
	var _arg1 *C.char       // out
	var _cret *C.GHashTable // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(encodedForm)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.soup_form_decode(_arg1)
	runtime.KeepAlive(encodedForm)

	var _hashTable map[string]string // out

	_hashTable = make(map[string]string, gextras.HashTableSize(unsafe.Pointer(_cret)))
	gextras.MoveHashTable(unsafe.Pointer(_cret), true, func(k, v unsafe.Pointer) {
		ksrc := *(**C.gchar)(k)
		vsrc := *(**C.gchar)(v)
		var kdst string // out
		var vdst string // out
		kdst = C.GoString((*C.gchar)(unsafe.Pointer(ksrc)))
		vdst = C.GoString((*C.gchar)(unsafe.Pointer(vsrc)))
		_hashTable[kdst] = vdst
	})

	return _hashTable
}

// FormEncodeHash encodes form_data_set into a value of type
// "application/x-www-form-urlencoded", as defined in the HTML 4.01 spec.
//
// Note that the HTML spec states that "The control names/values are listed in
// the order they appear in the document." Since this method takes a hash table,
// it cannot enforce that; if you care about the ordering of the form fields,
// use soup_form_encode_datalist().
//
// The function takes the following parameters:
//
//    - formDataSet: hash table containing name/value pairs (as strings).
//
// The function returns the following values:
//
//    - utf8: encoded form.
//
func FormEncodeHash(formDataSet map[string]string) string {
	var _arg1 *C.GHashTable // out
	var _cret *C.char       // in

	_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range formDataSet {
		var kdst *C.gchar // out
		var vdst *C.gchar // out
		kdst = (*C.gchar)(unsafe.Pointer(C.CString(ksrc)))
		defer C.free(unsafe.Pointer(kdst))
		vdst = (*C.gchar)(unsafe.Pointer(C.CString(vsrc)))
		defer C.free(unsafe.Pointer(vdst))
		C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg1)

	_cret = C.soup_form_encode_hash(_arg1)
	runtime.KeepAlive(formDataSet)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FormRequestNewFromHash creates a new SoupMessage and sets it up to send
// form_data_set to uri via method, as with soup_form_request_new().
//
// The function takes the following parameters:
//
//    - method: HTTP method, either "GET" or "POST".
//    - uri: URI to send the form data to.
//    - formDataSet: data to send to uri.
//
// The function returns the following values:
//
//    - message: new SoupMessage.
//
func FormRequestNewFromHash(method, uri string, formDataSet map[string]string) *Message {
	var _arg1 *C.char        // out
	var _arg2 *C.char        // out
	var _arg3 *C.GHashTable  // out
	var _cret *C.SoupMessage // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(method)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range formDataSet {
		var kdst *C.gchar // out
		var vdst *C.gchar // out
		kdst = (*C.gchar)(unsafe.Pointer(C.CString(ksrc)))
		defer C.free(unsafe.Pointer(kdst))
		vdst = (*C.gchar)(unsafe.Pointer(C.CString(vsrc)))
		defer C.free(unsafe.Pointer(vdst))
		C.g_hash_table_insert(_arg3, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg3)

	_cret = C.soup_form_request_new_from_hash(_arg1, _arg2, _arg3)
	runtime.KeepAlive(method)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(formDataSet)

	var _message *Message // out

	_message = wrapMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _message
}

// FormRequestNewFromMultipart creates a new SoupMessage and sets it up to send
// multipart to uri via POST.
//
// To send a <literal>"multipart/form-data"</literal> POST, first create a
// Multipart, using SOUP_FORM_MIME_TYPE_MULTIPART as the MIME type. Then use
// soup_multipart_append_form_string() and soup_multipart_append_form_file() to
// add the value of each form control to the multipart. (These are just
// convenience methods, and you can use soup_multipart_append_part() if you need
// greater control over the part headers.) Finally, call
// soup_form_request_new_from_multipart() to serialize the multipart structure
// and create a Message.
//
// The function takes the following parameters:
//
//    - uri: URI to send the form data to.
//    - multipart: "multipart/form-data" Multipart.
//
// The function returns the following values:
//
//    - message: new SoupMessage.
//
func FormRequestNewFromMultipart(uri string, multipart *Multipart) *Message {
	var _arg1 *C.char          // out
	var _arg2 *C.SoupMultipart // out
	var _cret *C.SoupMessage   // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.SoupMultipart)(gextras.StructNative(unsafe.Pointer(multipart)))

	_cret = C.soup_form_request_new_from_multipart(_arg1, _arg2)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(multipart)

	var _message *Message // out

	_message = wrapMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _message
}
