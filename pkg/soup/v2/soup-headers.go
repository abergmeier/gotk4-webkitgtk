// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
)

// #cgo pkg-config: libsoup-2.4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <libsoup/soup.h>
import "C"

// HeaderContains parses header to see if it contains the token token (matched
// case-insensitively). Note that this can't be used with lists that have
// qvalues.
func HeaderContains(header string, token string) bool {
	var _arg1 *C.char    // out
	var _arg2 *C.char    // out
	var _cret C.gboolean // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(header)))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(token)))

	_cret = C.soup_header_contains(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HeadersParse parses the headers of an HTTP request or response in str and
// stores the results in dest. Beware that dest may be modified even on failure.
//
// This is a low-level method; normally you would use
// soup_headers_parse_request() or soup_headers_parse_response().
func HeadersParse(str string, len int, dest *MessageHeaders) bool {
	var _arg1 *C.char               // out
	var _arg2 C.int                 // out
	var _arg3 *C.SoupMessageHeaders // out
	var _cret C.gboolean            // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	_arg2 = C.int(len)
	_arg3 = (*C.SoupMessageHeaders)(gextras.StructNative(unsafe.Pointer(dest)))

	_cret = C.soup_headers_parse(_arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HeadersParseRequest parses the headers of an HTTP request in str and stores
// the results in req_method, req_path, ver, and req_headers.
//
// Beware that req_headers may be modified even on failure.
func HeadersParseRequest(str string, len int, reqHeaders *MessageHeaders) (reqMethod string, reqPath string, ver HTTPVersion, guint uint) {
	var _arg1 *C.char               // out
	var _arg2 C.int                 // out
	var _arg3 *C.SoupMessageHeaders // out
	var _arg4 *C.char               // in
	var _arg5 *C.char               // in
	var _arg6 C.SoupHTTPVersion     // in
	var _cret C.guint               // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	_arg2 = C.int(len)
	_arg3 = (*C.SoupMessageHeaders)(gextras.StructNative(unsafe.Pointer(reqHeaders)))

	_cret = C.soup_headers_parse_request(_arg1, _arg2, _arg3, &_arg4, &_arg5, &_arg6)

	var _reqMethod string // out
	var _reqPath string   // out
	var _ver HTTPVersion  // out
	var _guint uint       // out

	_reqMethod = C.GoString((*C.gchar)(unsafe.Pointer(_arg4)))
	defer C.free(unsafe.Pointer(_arg4))
	_reqPath = C.GoString((*C.gchar)(unsafe.Pointer(_arg5)))
	defer C.free(unsafe.Pointer(_arg5))
	_ver = HTTPVersion(_arg6)
	_guint = uint(_cret)

	return _reqMethod, _reqPath, _ver, _guint
}

// HeadersParseResponse parses the headers of an HTTP response in str and stores
// the results in ver, status_code, reason_phrase, and headers.
//
// Beware that headers may be modified even on failure.
func HeadersParseResponse(str string, len int, headers *MessageHeaders) (HTTPVersion, uint, string, bool) {
	var _arg1 *C.char               // out
	var _arg2 C.int                 // out
	var _arg3 *C.SoupMessageHeaders // out
	var _arg4 C.SoupHTTPVersion     // in
	var _arg5 C.guint               // in
	var _arg6 *C.char               // in
	var _cret C.gboolean            // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	_arg2 = C.int(len)
	_arg3 = (*C.SoupMessageHeaders)(gextras.StructNative(unsafe.Pointer(headers)))

	_cret = C.soup_headers_parse_response(_arg1, _arg2, _arg3, &_arg4, &_arg5, &_arg6)

	var _ver HTTPVersion     // out
	var _statusCode uint     // out
	var _reasonPhrase string // out
	var _ok bool             // out

	_ver = HTTPVersion(_arg4)
	_statusCode = uint(_arg5)
	_reasonPhrase = C.GoString((*C.gchar)(unsafe.Pointer(_arg6)))
	defer C.free(unsafe.Pointer(_arg6))
	if _cret != 0 {
		_ok = true
	}

	return _ver, _statusCode, _reasonPhrase, _ok
}

// HeadersParseStatusLine parses the HTTP Status-Line string in status_line into
// ver, status_code, and reason_phrase. status_line must be terminated by either
// "\0" or "\r\n".
func HeadersParseStatusLine(statusLine string) (HTTPVersion, uint, string, bool) {
	var _arg1 *C.char           // out
	var _arg2 C.SoupHTTPVersion // in
	var _arg3 C.guint           // in
	var _arg4 *C.char           // in
	var _cret C.gboolean        // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(statusLine)))

	_cret = C.soup_headers_parse_status_line(_arg1, &_arg2, &_arg3, &_arg4)

	var _ver HTTPVersion     // out
	var _statusCode uint     // out
	var _reasonPhrase string // out
	var _ok bool             // out

	_ver = HTTPVersion(_arg2)
	_statusCode = uint(_arg3)
	_reasonPhrase = C.GoString((*C.gchar)(unsafe.Pointer(_arg4)))
	defer C.free(unsafe.Pointer(_arg4))
	if _cret != 0 {
		_ok = true
	}

	return _ver, _statusCode, _reasonPhrase, _ok
}
