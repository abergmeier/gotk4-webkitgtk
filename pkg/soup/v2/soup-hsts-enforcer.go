// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: libsoup-2.4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <libsoup/soup.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.soup_hsts_enforcer_get_type()), F: marshalHSTSEnforcerer},
	})
}

// HSTSEnforcerOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type HSTSEnforcerOverrider interface {
	Changed(oldPolicy *HSTSPolicy, newPolicy *HSTSPolicy)
	// HasValidPolicy gets whether hsts_enforcer has a currently valid policy
	// for domain.
	HasValidPolicy(domain string) bool
	HstsEnforced(message *Message)
	// IsPersistent gets whether hsts_enforcer stores policies persistenly.
	IsPersistent() bool
}

type HSTSEnforcer struct {
	*externglib.Object

	SessionFeature
}

var _ gextras.Nativer = (*HSTSEnforcer)(nil)

func wrapHSTSEnforcer(obj *externglib.Object) *HSTSEnforcer {
	return &HSTSEnforcer{
		Object: obj,
		SessionFeature: SessionFeature{
			Object: obj,
		},
	}
}

func marshalHSTSEnforcerer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapHSTSEnforcer(obj), nil
}

// NewHSTSEnforcer creates a new HSTSEnforcer. The base HSTSEnforcer class does
// not support persistent storage of HSTS policies, see HSTSEnforcerDB for that.
func NewHSTSEnforcer() *HSTSEnforcer {
	var _cret *C.SoupHSTSEnforcer // in

	_cret = C.soup_hsts_enforcer_new()

	var _hstsEnforcer *HSTSEnforcer // out

	_hstsEnforcer = wrapHSTSEnforcer(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _hstsEnforcer
}

// Domains gets a list of domains for which there are policies in enforcer.
func (hstsEnforcer *HSTSEnforcer) Domains(sessionPolicies bool) *externglib.List {
	var _arg0 *C.SoupHSTSEnforcer // out
	var _arg1 C.gboolean          // out
	var _cret *C.GList            // in

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(hstsEnforcer.Native()))
	if sessionPolicies {
		_arg1 = C.TRUE
	}

	_cret = C.soup_hsts_enforcer_get_domains(_arg0, _arg1)

	var _list *externglib.List // out

	_list = externglib.WrapList(uintptr(unsafe.Pointer(_cret)))
	_list.AttachFinalizer(func(v uintptr) {
		C.free(unsafe.Pointer(v))
	})

	return _list
}

// Policies gets a list with the policies in enforcer.
func (hstsEnforcer *HSTSEnforcer) Policies(sessionPolicies bool) *externglib.List {
	var _arg0 *C.SoupHSTSEnforcer // out
	var _arg1 C.gboolean          // out
	var _cret *C.GList            // in

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(hstsEnforcer.Native()))
	if sessionPolicies {
		_arg1 = C.TRUE
	}

	_cret = C.soup_hsts_enforcer_get_policies(_arg0, _arg1)

	var _list *externglib.List // out

	_list = externglib.WrapList(uintptr(unsafe.Pointer(_cret)))
	_list.DataWrapper(func(_p unsafe.Pointer) interface{} {
		src := (*C.SoupHSTSPolicy)(_p)
		var dst HSTSPolicy // out
		dst = *(*HSTSPolicy)(gextras.NewStructNative(unsafe.Pointer(src)))
		return dst
	})
	_list.AttachFinalizer(func(v uintptr) {
		C.soup_hsts_policy_free((*C.SoupHSTSPolicy)(unsafe.Pointer(v)))
	})

	return _list
}

// HasValidPolicy gets whether hsts_enforcer has a currently valid policy for
// domain.
func (hstsEnforcer *HSTSEnforcer) HasValidPolicy(domain string) bool {
	var _arg0 *C.SoupHSTSEnforcer // out
	var _arg1 *C.char             // out
	var _cret C.gboolean          // in

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(hstsEnforcer.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))

	_cret = C.soup_hsts_enforcer_has_valid_policy(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsPersistent gets whether hsts_enforcer stores policies persistenly.
func (hstsEnforcer *HSTSEnforcer) IsPersistent() bool {
	var _arg0 *C.SoupHSTSEnforcer // out
	var _cret C.gboolean          // in

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(hstsEnforcer.Native()))

	_cret = C.soup_hsts_enforcer_is_persistent(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetPolicy sets policy to hsts_enforcer. If policy is expired, any existing
// HSTS policy for its host will be removed instead. If a policy existed for
// this host, it will be replaced. Otherwise, the new policy will be inserted.
// If the policy is a session policy, that is, one created with
// soup_hsts_policy_new_session_policy(), the policy will not expire and will be
// enforced during the lifetime of hsts_enforcer's Session.
func (hstsEnforcer *HSTSEnforcer) SetPolicy(policy *HSTSPolicy) {
	var _arg0 *C.SoupHSTSEnforcer // out
	var _arg1 *C.SoupHSTSPolicy   // out

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(hstsEnforcer.Native()))
	_arg1 = (*C.SoupHSTSPolicy)(gextras.StructNative(unsafe.Pointer(policy)))

	C.soup_hsts_enforcer_set_policy(_arg0, _arg1)
}

// SetSessionPolicy sets a session policy for domain. A session policy is a
// policy that is permanent to the lifetime of hsts_enforcer's Session and
// doesn't expire.
func (hstsEnforcer *HSTSEnforcer) SetSessionPolicy(domain string, includeSubdomains bool) {
	var _arg0 *C.SoupHSTSEnforcer // out
	var _arg1 *C.char             // out
	var _arg2 C.gboolean          // out

	_arg0 = (*C.SoupHSTSEnforcer)(unsafe.Pointer(hstsEnforcer.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
	if includeSubdomains {
		_arg2 = C.TRUE
	}

	C.soup_hsts_enforcer_set_session_policy(_arg0, _arg1, _arg2)
}
