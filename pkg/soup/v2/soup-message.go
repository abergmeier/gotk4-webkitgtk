// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"fmt"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: libsoup-2.4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <libsoup/soup.h>
// SoupBuffer* _gotk4_soup2_ChunkAllocator(SoupMessage*, gsize, gpointer);
// extern void callbackDelete(gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.soup_http_version_get_type()), F: marshalHTTPVersion},
		{T: externglib.Type(C.soup_message_priority_get_type()), F: marshalMessagePriority},
		{T: externglib.Type(C.soup_message_flags_get_type()), F: marshalMessageFlags},
		{T: externglib.Type(C.soup_message_get_type()), F: marshalMessager},
	})
}

// HTTPVersion indicates the HTTP protocol version being used.
type HTTPVersion int

const (
	// Http10: HTTP 1.0 (RFC 1945)
	Http10 HTTPVersion = iota
	// Http11: HTTP 1.1 (RFC 2616)
	Http11
)

func marshalHTTPVersion(p uintptr) (interface{}, error) {
	return HTTPVersion(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for HTTPVersion.
func (h HTTPVersion) String() string {
	switch h {
	case Http10:
		return "Http10"
	case Http11:
		return "Http11"
	default:
		return fmt.Sprintf("HTTPVersion(%d)", h)
	}
}

// MessagePriority priorities that can be set on a Message to instruct the
// message queue to process it before any other message with lower priority.
type MessagePriority int

const (
	// MessagePriorityVeryLow: lowest priority, the messages with this priority
	// will be the last ones to be attended.
	MessagePriorityVeryLow MessagePriority = iota
	// MessagePriorityLow: use this for low priority messages, a Message with
	// the default priority will be processed first.
	MessagePriorityLow
	// MessagePriorityNormal: default priotity, this is the priority assigned to
	// the Message by default.
	MessagePriorityNormal
	// MessagePriorityHigh: high priority, a Message with this priority will be
	// processed before the ones with the default priority.
	MessagePriorityHigh
	// MessagePriorityVeryHigh: highest priority, use this for very urgent
	// Message as they will be the first ones to be attended.
	MessagePriorityVeryHigh
)

func marshalMessagePriority(p uintptr) (interface{}, error) {
	return MessagePriority(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for MessagePriority.
func (m MessagePriority) String() string {
	switch m {
	case MessagePriorityVeryLow:
		return "VeryLow"
	case MessagePriorityLow:
		return "Low"
	case MessagePriorityNormal:
		return "Normal"
	case MessagePriorityHigh:
		return "High"
	case MessagePriorityVeryHigh:
		return "VeryHigh"
	default:
		return fmt.Sprintf("MessagePriority(%d)", m)
	}
}

// MessageFlags various flags that can be set on a Message to alter its
// behavior.
type MessageFlags int

const (
	// MessageNoRedirect: session should not follow redirect (3xx) responses
	// received by this message.
	MessageNoRedirect MessageFlags = 0b10
	// MessageCanRebuild: caller will rebuild the request body if the message is
	// restarted; see soup_message_body_set_accumulate() for more details.
	MessageCanRebuild MessageFlags = 0b100
	// MessageOverwriteChunks: deprecated: equivalent to calling
	// soup_message_body_set_accumulate() on the incoming message body (ie,
	// Message:response_body for a client-side request), passing FALSE.
	MessageOverwriteChunks MessageFlags = 0b1000
	// MessageContentDecoded: set by ContentDecoder to indicate that it has
	// removed the Content-Encoding on a message (and so headers such as
	// Content-Length may no longer accurately describe the body).
	MessageContentDecoded MessageFlags = 0b10000
	// MessageCertificateTrusted: if set after an https response has been
	// received, indicates that the server's SSL certificate is trusted
	// according to the session's CA.
	MessageCertificateTrusted MessageFlags = 0b100000
	// MessageNewConnection requests that the message should be sent on a
	// newly-created connection, not reusing an existing persistent connection.
	// Note that messages with non-idempotent Message:method<!-- -->s behave
	// this way by default, unless UP_MESSAGE_IDEMPOTENT is set.
	MessageNewConnection MessageFlags = 0b1000000
	// MessageIdempotent: message is considered idempotent, regardless its
	// Message:method, and allows reuse of existing idle connections, instead of
	// always requiring a new one, unless UP_MESSAGE_NEW_CONNECTION is set.
	MessageIdempotent MessageFlags = 0b10000000
	// MessageIgnoreConnectionLimits: request that a new connection is created
	// for the message if there aren't idle connections available and it's not
	// possible to create new connections due to any of the connection limits
	// has been reached. If a dedicated connection is eventually created for
	// this message, it will be dropped when the message finishes. Since 2.50
	MessageIgnoreConnectionLimits MessageFlags = 0b100000000
	// MessageDoNotUseAuthCache should not use the credentials cache for this
	// message, neither to use cached credentials to automatically authenticate
	// this message nor to cache the credentials after the message is
	// successfully authenticated. This applies to both server and proxy
	// authentication. Note that Session::authenticate signal will be emitted,
	// if you want to disable authentication for a message use
	// soup_message_disable_feature() passing UP_TYPE_AUTH_MANAGER instead.
	// Since 2.58
	MessageDoNotUseAuthCache MessageFlags = 0b1000000000
)

func marshalMessageFlags(p uintptr) (interface{}, error) {
	return MessageFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the names in string for MessageFlags.
func (m MessageFlags) String() string {
	if m == 0 {
		return "MessageFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(200)

	for m != 0 {
		next := m & (m - 1)
		bit := m - next

		switch bit {
		case MessageNoRedirect:
			builder.WriteString("NoRedirect|")
		case MessageCanRebuild:
			builder.WriteString("CanRebuild|")
		case MessageOverwriteChunks:
			builder.WriteString("OverwriteChunks|")
		case MessageContentDecoded:
			builder.WriteString("ContentDecoded|")
		case MessageCertificateTrusted:
			builder.WriteString("CertificateTrusted|")
		case MessageNewConnection:
			builder.WriteString("NewConnection|")
		case MessageIdempotent:
			builder.WriteString("Idempotent|")
		case MessageIgnoreConnectionLimits:
			builder.WriteString("IgnoreConnectionLimits|")
		case MessageDoNotUseAuthCache:
			builder.WriteString("DoNotUseAuthCache|")
		default:
			builder.WriteString(fmt.Sprintf("MessageFlags(0b%b)|", bit))
		}

		m = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// ChunkAllocator: prototype for a chunk allocation callback. This should
// allocate a new Buffer and return it for the I/O layer to read message body
// data off the network into.
//
// If max_len is non-0, it indicates the maximum number of bytes that could be
// read, based on what is known about the message size. Note that this might be
// a very large number, and you should not simply try to allocate that many
// bytes blindly. If max_len is 0, that means that libsoup does not know how
// many bytes remain to be read, and the allocator should return a buffer of a
// size that it finds convenient.
//
// If the allocator returns NULL, the message will be paused. It is up to the
// application to make sure that it gets unpaused when it becomes possible to
// allocate a new buffer.
//
// Deprecated: Use Request if you want to read into your own buffers.
type ChunkAllocator func(msg *Message, maxLen uint) (buffer *Buffer)

//export _gotk4_soup2_ChunkAllocator
func _gotk4_soup2_ChunkAllocator(arg0 *C.SoupMessage, arg1 C.gsize, arg2 C.gpointer) (cret *C.SoupBuffer) {
	v := gbox.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var msg *Message // out
	var maxLen uint  // out

	msg = wrapMessage(externglib.Take(unsafe.Pointer(arg0)))
	maxLen = uint(arg1)

	fn := v.(ChunkAllocator)
	buffer := fn(msg, maxLen)

	cret = (*C.SoupBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	return cret
}

// MessageOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type MessageOverrider interface {
	Finished()
	GotBody()
	GotChunk(chunk *Buffer)
	GotHeaders()
	GotInformational()
	Restarted()
	Starting()
	WroteBody()
	WroteChunk()
	WroteHeaders()
	WroteInformational()
}

// Message represents an HTTP message being sent or received.
//
// status_code will normally be a Status value, eg, SOUP_STATUS_OK, though of
// course it might actually be an unknown status code. reason_phrase is the
// actual text returned from the server, which may or may not correspond to the
// "standard" description of status_code. At any rate, it is almost certainly
// not localized, and not very descriptive even if it is in the user's language;
// you should not use reason_phrase in user-visible messages. Rather, you should
// look at status_code, and determine an end-user-appropriate message based on
// that and on what you were trying to do.
//
// As described in the MessageBody documentation, the request_body and
// response_body <literal>data</literal> fields will not necessarily be filled
// in at all times. When the body fields are filled in, they will be terminated
// with a '\0' byte (which is not included in the <literal>length</literal>), so
// you can use them as ordinary C strings (assuming that you know that the body
// doesn't have any other '\0' bytes).
//
// For a client-side Message, request_body's <literal>data</literal> is usually
// filled in right before libsoup writes the request to the network, but you
// should not count on this; use soup_message_body_flatten() if you want to
// ensure that <literal>data</literal> is filled in. If you are not using
// Request to read the response, then response_body's <literal>data</literal>
// will be filled in before Message::finished is emitted. (If you are using
// Request, then the message body is not accumulated by default, so
// response_body's <literal>data</literal> will always be NULL.)
//
// For a server-side Message, request_body's data will be filled in before
// Message::got_body is emitted.
//
// To prevent the data field from being filled in at all (eg, if you are
// handling the data from a Message::got_chunk, and so don't need to see it all
// at the end), call soup_message_body_set_accumulate() on response_body or
// request_body as appropriate, passing FALSE.
type Message struct {
	*externglib.Object
}

var _ gextras.Nativer = (*Message)(nil)

func wrapMessage(obj *externglib.Object) *Message {
	return &Message{
		Object: obj,
	}
}

func marshalMessager(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapMessage(obj), nil
}

// NewMessage creates a new empty Message, which will connect to uri
func NewMessage(method string, uriString string) *Message {
	var _arg1 *C.char        // out
	var _arg2 *C.char        // out
	var _cret *C.SoupMessage // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(method)))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(uriString)))

	_cret = C.soup_message_new(_arg1, _arg2)

	var _message *Message // out

	_message = wrapMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _message
}

// NewMessageFromURI creates a new empty Message, which will connect to uri
func NewMessageFromURI(method string, uri *URI) *Message {
	var _arg1 *C.char        // out
	var _arg2 *C.SoupURI     // out
	var _cret *C.SoupMessage // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(method)))
	_arg2 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.soup_message_new_from_uri(_arg1, _arg2)

	var _message *Message // out

	_message = wrapMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _message
}

func (msg *Message) ContentSniffed(contentType string, params *glib.HashTable) {
	var _arg0 *C.SoupMessage // out
	var _arg1 *C.char        // out
	var _arg2 *C.GHashTable  // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	_arg2 = (*C.GHashTable)(gextras.StructNative(unsafe.Pointer(params)))

	C.soup_message_content_sniffed(_arg0, _arg1, _arg2)
}

// DisableFeature: this disables the actions of SessionFeature<!-- -->s with the
// given feature_type (or a subclass of that type) on msg, so that msg is
// processed as though the feature(s) hadn't been added to the session. Eg,
// passing UP_TYPE_CONTENT_SNIFFER for feature_type will disable Content-Type
// sniffing on the message.
//
// You must call this before queueing msg on a session; calling it on a message
// that has already been queued is undefined. In particular, you cannot call
// this on a message that is being requeued after a redirect or authentication.
func (msg *Message) DisableFeature(featureType externglib.Type) {
	var _arg0 *C.SoupMessage // out
	var _arg1 C.GType        // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg1 = C.GType(featureType)

	C.soup_message_disable_feature(_arg0, _arg1)
}

func (msg *Message) Finished() {
	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	C.soup_message_finished(_arg0)
}

// Address gets the address msg's URI points to. After first setting the URI on
// a message, this will be unresolved, although the message's session will
// resolve it before sending the message.
func (msg *Message) Address() *Address {
	var _arg0 *C.SoupMessage // out
	var _cret *C.SoupAddress // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	_cret = C.soup_message_get_address(_arg0)

	var _address *Address // out

	_address = wrapAddress(externglib.Take(unsafe.Pointer(_cret)))

	return _address
}

// FirstParty gets msg's first-party URI
func (msg *Message) FirstParty() *URI {
	var _arg0 *C.SoupMessage // out
	var _cret *C.SoupURI     // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	_cret = C.soup_message_get_first_party(_arg0)

	var _urI *URI // out

	_urI = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _urI
}

// Flags gets the flags on msg
func (msg *Message) Flags() MessageFlags {
	var _arg0 *C.SoupMessage     // out
	var _cret C.SoupMessageFlags // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	_cret = C.soup_message_get_flags(_arg0)

	var _messageFlags MessageFlags // out

	_messageFlags = MessageFlags(_cret)

	return _messageFlags
}

// HttpVersion gets the HTTP version of msg. This is the minimum of the version
// from the request and the version from the response.
func (msg *Message) HttpVersion() HTTPVersion {
	var _arg0 *C.SoupMessage    // out
	var _cret C.SoupHTTPVersion // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	_cret = C.soup_message_get_http_version(_arg0)

	var _httpVersion HTTPVersion // out

	_httpVersion = HTTPVersion(_cret)

	return _httpVersion
}

// HttpsStatus: if msg is using https (or attempted to use https but got
// SOUP_STATUS_SSL_FAILED), this retrieves the Certificate associated with its
// connection, and the CertificateFlags showing what problems, if any, have been
// found with that certificate.
//
// <note><para>This is only meaningful with messages processed by a Session and
// is not useful for messages received by a Server</para></note>
func (msg *Message) HttpsStatus() (*gio.TLSCertificate, gio.TLSCertificateFlags, bool) {
	var _arg0 *C.SoupMessage         // out
	var _arg1 *C.GTlsCertificate     // in
	var _arg2 C.GTlsCertificateFlags // in
	var _cret C.gboolean             // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	_cret = C.soup_message_get_https_status(_arg0, &_arg1, &_arg2)

	var _certificate *gio.TLSCertificate // out
	var _errors gio.TLSCertificateFlags  // out
	var _ok bool                         // out

	{
		obj := externglib.Take(unsafe.Pointer(_arg1))
		_certificate = &gio.TLSCertificate{
			Object: obj,
		}
	}
	_errors = gio.TLSCertificateFlags(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _certificate, _errors, _ok
}

func (msg *Message) IsTopLevelNavigation() bool {
	var _arg0 *C.SoupMessage // out
	var _cret C.gboolean     // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	_cret = C.soup_message_get_is_top_level_navigation(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Priority retrieves the MessagePriority. If not set this value defaults to
// UP_MESSAGE_PRIORITY_NORMAL.
func (msg *Message) Priority() MessagePriority {
	var _arg0 *C.SoupMessage        // out
	var _cret C.SoupMessagePriority // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	_cret = C.soup_message_get_priority(_arg0)

	var _messagePriority MessagePriority // out

	_messagePriority = MessagePriority(_cret)

	return _messagePriority
}

// SiteForCookies gets msg's site for cookies URI
func (msg *Message) SiteForCookies() *URI {
	var _arg0 *C.SoupMessage // out
	var _cret *C.SoupURI     // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	_cret = C.soup_message_get_site_for_cookies(_arg0)

	var _urI *URI // out

	_urI = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _urI
}

// SoupRequest: if msg is associated with a Request, this returns that request.
// Otherwise it returns NULL.
func (msg *Message) SoupRequest() *Request {
	var _arg0 *C.SoupMessage // out
	var _cret *C.SoupRequest // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	_cret = C.soup_message_get_soup_request(_arg0)

	var _request *Request // out

	_request = wrapRequest(externglib.Take(unsafe.Pointer(_cret)))

	return _request
}

// URI gets msg's URI
func (msg *Message) URI() *URI {
	var _arg0 *C.SoupMessage // out
	var _cret *C.SoupURI     // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	_cret = C.soup_message_get_uri(_arg0)

	var _urI *URI // out

	_urI = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _urI
}

func (msg *Message) GotBody() {
	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	C.soup_message_got_body(_arg0)
}

func (msg *Message) GotChunk(chunk *Buffer) {
	var _arg0 *C.SoupMessage // out
	var _arg1 *C.SoupBuffer  // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg1 = (*C.SoupBuffer)(gextras.StructNative(unsafe.Pointer(chunk)))

	C.soup_message_got_chunk(_arg0, _arg1)
}

func (msg *Message) GotHeaders() {
	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	C.soup_message_got_headers(_arg0)
}

func (msg *Message) GotInformational() {
	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	C.soup_message_got_informational(_arg0)
}

// IsFeatureDisabled: get whether SessionFeature<!-- -->s of the given
// feature_type (or a subclass of that type) are disabled on msg. See
// soup_message_disable_feature().
func (msg *Message) IsFeatureDisabled(featureType externglib.Type) bool {
	var _arg0 *C.SoupMessage // out
	var _arg1 C.GType        // out
	var _cret C.gboolean     // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg1 = C.GType(featureType)

	_cret = C.soup_message_is_feature_disabled(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsKeepalive determines whether or not msg's connection can be kept alive for
// further requests after processing msg, based on the HTTP version, Connection
// header, etc.
func (msg *Message) IsKeepalive() bool {
	var _arg0 *C.SoupMessage // out
	var _cret C.gboolean     // in

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	_cret = C.soup_message_is_keepalive(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (msg *Message) Restarted() {
	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	C.soup_message_restarted(_arg0)
}

// SetChunkAllocator sets an alternate chunk-allocation function to use when
// reading msg's body when using the traditional (ie, non-Request<!-- -->-based)
// API. Every time data is available to read, libsoup will call allocator, which
// should return a Buffer. (See ChunkAllocator for additional details.) Libsoup
// will then read data from the network into that buffer, and update the
// buffer's <literal>length</literal> to indicate how much data it read.
//
// Generally, a custom chunk allocator would be used in conjunction with
// soup_message_body_set_accumulate() FALSE and Message::got_chunk, as part of a
// strategy to avoid unnecessary copying of data. However, you cannot assume
// that every call to the allocator will be followed by a call to your
// Message::got_chunk handler; if an I/O error occurs, then the buffer will be
// unreffed without ever having been used. If your buffer-allocation strategy
// requires special cleanup, use soup_buffer_new_with_owner() rather than doing
// the cleanup from the Message::got_chunk handler.
//
// The other thing to remember when using non-accumulating message bodies is
// that the buffer passed to the Message::got_chunk handler will be unreffed
// after the handler returns, just as it would be in the non-custom-allocated
// case. If you want to hand the chunk data off to some other part of your
// program to use later, you'll need to ref the Buffer (or its owner, in the
// soup_buffer_new_with_owner() case) to ensure that the data remains valid.
//
// Deprecated: Request provides a much simpler API that lets you read the
// response directly into your own buffers without needing to mess with
// callbacks, pausing/unpausing, etc.
func (msg *Message) SetChunkAllocator(allocator ChunkAllocator) {
	var _arg0 *C.SoupMessage       // out
	var _arg1 C.SoupChunkAllocator // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg1 = (*[0]byte)(C._gotk4_soup2_ChunkAllocator)
	_arg2 = C.gpointer(gbox.Assign(allocator))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.soup_message_set_chunk_allocator(_arg0, _arg1, _arg2, _arg3)
}

// SetFirstParty sets first_party as the main document URI for msg. For details
// of when and how this is used refer to the documentation for
// CookieJarAcceptPolicy.
func (msg *Message) SetFirstParty(firstParty *URI) {
	var _arg0 *C.SoupMessage // out
	var _arg1 *C.SoupURI     // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg1 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(firstParty)))

	C.soup_message_set_first_party(_arg0, _arg1)
}

// SetFlags sets the specified flags on msg.
func (msg *Message) SetFlags(flags MessageFlags) {
	var _arg0 *C.SoupMessage     // out
	var _arg1 C.SoupMessageFlags // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg1 = C.SoupMessageFlags(flags)

	C.soup_message_set_flags(_arg0, _arg1)
}

// SetHttpVersion sets the HTTP version on msg. The default version is
// SOUP_HTTP_1_1. Setting it to SOUP_HTTP_1_0 will prevent certain functionality
// from being used.
func (msg *Message) SetHttpVersion(version HTTPVersion) {
	var _arg0 *C.SoupMessage    // out
	var _arg1 C.SoupHTTPVersion // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg1 = C.SoupHTTPVersion(version)

	C.soup_message_set_http_version(_arg0, _arg1)
}

// SetIsTopLevelNavigation: see the same-site spec
// (https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00) for more
// information.
func (msg *Message) SetIsTopLevelNavigation(isTopLevelNavigation bool) {
	var _arg0 *C.SoupMessage // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	if isTopLevelNavigation {
		_arg1 = C.TRUE
	}

	C.soup_message_set_is_top_level_navigation(_arg0, _arg1)
}

// SetPriority sets the priority of a message. Note that this won't have any
// effect unless used before the message is added to the session's message
// processing queue.
//
// The message will be placed just before any other previously added message
// with lower priority (messages with the same priority are processed on a FIFO
// basis).
//
// Setting priorities does not currently work with SessionSync (or with
// synchronous messages on a plain Session) because in the synchronous/blocking
// case, priority ends up being determined semi-randomly by thread scheduling.
func (msg *Message) SetPriority(priority MessagePriority) {
	var _arg0 *C.SoupMessage        // out
	var _arg1 C.SoupMessagePriority // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg1 = C.SoupMessagePriority(priority)

	C.soup_message_set_priority(_arg0, _arg1)
}

// SetRedirect sets msg's status_code to status_code and adds a Location header
// pointing to redirect_uri. Use this from a Server when you want to redirect
// the client to another URI.
//
// redirect_uri can be a relative URI, in which case it is interpreted relative
// to msg's current URI. In particular, if redirect_uri is just a path, it will
// replace the path <emphasis>and query</emphasis> of msg's URI.
func (msg *Message) SetRedirect(statusCode uint, redirectUri string) {
	var _arg0 *C.SoupMessage // out
	var _arg1 C.guint        // out
	var _arg2 *C.char        // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg1 = C.guint(statusCode)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(redirectUri)))

	C.soup_message_set_redirect(_arg0, _arg1, _arg2)
}

// SetRequest: convenience function to set the request body of a Message. If
// content_type is NULL, the request body must be empty as well.
func (msg *Message) SetRequest(contentType string, reqUse MemoryUse, reqBody []byte) {
	var _arg0 *C.SoupMessage  // out
	var _arg1 *C.char         // out
	var _arg2 C.SoupMemoryUse // out
	var _arg3 *C.char
	var _arg4 C.gsize

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	_arg2 = C.SoupMemoryUse(reqUse)
	_arg4 = (C.gsize)(len(reqBody))
	if len(reqBody) > 0 {
		_arg3 = (*C.char)(unsafe.Pointer(&reqBody[0]))
	}

	C.soup_message_set_request(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// SetResponse: convenience function to set the response body of a Message. If
// content_type is NULL, the response body must be empty as well.
func (msg *Message) SetResponse(contentType string, respUse MemoryUse, respBody []byte) {
	var _arg0 *C.SoupMessage  // out
	var _arg1 *C.char         // out
	var _arg2 C.SoupMemoryUse // out
	var _arg3 *C.char
	var _arg4 C.gsize

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	_arg2 = C.SoupMemoryUse(respUse)
	_arg4 = (C.gsize)(len(respBody))
	if len(respBody) > 0 {
		_arg3 = (*C.char)(unsafe.Pointer(&respBody[0]))
	}

	C.soup_message_set_response(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// SetSiteForCookies sets site_for_cookies as the policy URL for same-site
// cookies for msg.
//
// It is either the URL of the top-level document or NULL depending on whether
// the registrable domain of this document's URL matches the registrable domain
// of its parent's/opener's URL. For the top-level document it is set to the
// document's URL.
//
// See the same-site spec
// (https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00) for more
// information.
func (msg *Message) SetSiteForCookies(siteForCookies *URI) {
	var _arg0 *C.SoupMessage // out
	var _arg1 *C.SoupURI     // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg1 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(siteForCookies)))

	C.soup_message_set_site_for_cookies(_arg0, _arg1)
}

// SetStatus sets msg's status code to status_code. If status_code is a known
// value, it will also set msg's reason_phrase.
func (msg *Message) SetStatus(statusCode uint) {
	var _arg0 *C.SoupMessage // out
	var _arg1 C.guint        // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg1 = C.guint(statusCode)

	C.soup_message_set_status(_arg0, _arg1)
}

// SetStatusFull sets msg's status code and reason phrase.
func (msg *Message) SetStatusFull(statusCode uint, reasonPhrase string) {
	var _arg0 *C.SoupMessage // out
	var _arg1 C.guint        // out
	var _arg2 *C.char        // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg1 = C.guint(statusCode)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(reasonPhrase)))

	C.soup_message_set_status_full(_arg0, _arg1, _arg2)
}

// SetURI sets msg's URI to uri. If msg has already been sent and you want to
// re-send it with the new URI, you need to call soup_session_requeue_message().
func (msg *Message) SetURI(uri *URI) {
	var _arg0 *C.SoupMessage // out
	var _arg1 *C.SoupURI     // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg1 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(uri)))

	C.soup_message_set_uri(_arg0, _arg1)
}

func (msg *Message) Starting() {
	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	C.soup_message_starting(_arg0)
}

func (msg *Message) WroteBody() {
	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	C.soup_message_wrote_body(_arg0)
}

func (msg *Message) WroteBodyData(chunk *Buffer) {
	var _arg0 *C.SoupMessage // out
	var _arg1 *C.SoupBuffer  // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg1 = (*C.SoupBuffer)(gextras.StructNative(unsafe.Pointer(chunk)))

	C.soup_message_wrote_body_data(_arg0, _arg1)
}

func (msg *Message) WroteChunk() {
	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	C.soup_message_wrote_chunk(_arg0)
}

func (msg *Message) WroteHeaders() {
	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	C.soup_message_wrote_headers(_arg0)
}

func (msg *Message) WroteInformational() {
	var _arg0 *C.SoupMessage // out

	_arg0 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	C.soup_message_wrote_informational(_arg0)
}
