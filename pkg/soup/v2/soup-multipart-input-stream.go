// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #cgo pkg-config: libsoup-2.4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <libsoup/soup.h>
// void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.soup_multipart_input_stream_get_type()), F: marshalMultipartInputStreamer},
	})
}

type MultipartInputStream struct {
	gio.FilterInputStream

	gio.PollableInputStream
	*externglib.Object
}

func wrapMultipartInputStream(obj *externglib.Object) *MultipartInputStream {
	return &MultipartInputStream{
		FilterInputStream: gio.FilterInputStream{
			InputStream: gio.InputStream{
				Object: obj,
			},
		},
		PollableInputStream: gio.PollableInputStream{
			InputStream: gio.InputStream{
				Object: obj,
			},
		},
		Object: obj,
	}
}

func marshalMultipartInputStreamer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapMultipartInputStream(obj), nil
}

// NewMultipartInputStream creates a new MultipartInputStream that wraps the
// Stream obtained by sending the Request. Reads should not be done directly
// through this object, use the input streams returned by
// soup_multipart_input_stream_next_part() or its async counterpart instead.
func NewMultipartInputStream(msg *Message, baseStream gio.InputStreamer) *MultipartInputStream {
	var _arg1 *C.SoupMessage              // out
	var _arg2 *C.GInputStream             // out
	var _cret *C.SoupMultipartInputStream // in

	_arg1 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg2 = (*C.GInputStream)(unsafe.Pointer(baseStream.Native()))

	_cret = C.soup_multipart_input_stream_new(_arg1, _arg2)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(baseStream)

	var _multipartInputStream *MultipartInputStream // out

	_multipartInputStream = wrapMultipartInputStream(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _multipartInputStream
}

// Headers obtains the headers for the part currently being processed. Note that
// the MessageHeaders that are returned are owned by the MultipartInputStream
// and will be replaced when a call is made to
// soup_multipart_input_stream_next_part() or its async counterpart, so if
// keeping the headers is required, a copy must be made.
//
// Note that if a part had no headers at all an empty MessageHeaders will be
// returned.
func (multipart *MultipartInputStream) Headers() *MessageHeaders {
	var _arg0 *C.SoupMultipartInputStream // out
	var _cret *C.SoupMessageHeaders       // in

	_arg0 = (*C.SoupMultipartInputStream)(unsafe.Pointer(multipart.Native()))

	_cret = C.soup_multipart_input_stream_get_headers(_arg0)
	runtime.KeepAlive(multipart)

	var _messageHeaders *MessageHeaders // out

	if _cret != nil {
		_messageHeaders = (*MessageHeaders)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _messageHeaders
}

// NextPart obtains an input stream for the next part. When dealing with a
// multipart response the input stream needs to be wrapped in a
// MultipartInputStream and this function or its async counterpart need to be
// called to obtain the first part for reading.
//
// After calling this function, soup_multipart_input_stream_get_headers() can be
// used to obtain the headers for the first part. A read of 0 bytes indicates
// the end of the part; a new call to this function should be done at that
// point, to obtain the next part.
func (multipart *MultipartInputStream) NextPart(ctx context.Context) (gio.InputStreamer, error) {
	var _arg0 *C.SoupMultipartInputStream // out
	var _arg1 *C.GCancellable             // out
	var _cret *C.GInputStream             // in
	var _cerr *C.GError                   // in

	_arg0 = (*C.SoupMultipartInputStream)(unsafe.Pointer(multipart.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.soup_multipart_input_stream_next_part(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(multipart)
	runtime.KeepAlive(ctx)

	var _inputStream gio.InputStreamer // out
	var _goerr error                   // out

	if _cret != nil {
		_inputStream = (externglib.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(gio.InputStreamer)
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _inputStream, _goerr
}

// NextPartAsync obtains a Stream for the next request. See
// soup_multipart_input_stream_next_part() for details on the workflow.
func (multipart *MultipartInputStream) NextPartAsync(ctx context.Context, ioPriority int32, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SoupMultipartInputStream // out
	var _arg2 *C.GCancellable             // out
	var _arg1 C.int                       // out
	var _arg3 C.GAsyncReadyCallback       // out
	var _arg4 C.gpointer

	_arg0 = (*C.SoupMultipartInputStream)(unsafe.Pointer(multipart.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.soup_multipart_input_stream_next_part_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(multipart)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// NextPartFinish finishes an asynchronous request for the next part.
func (multipart *MultipartInputStream) NextPartFinish(result gio.AsyncResulter) (gio.InputStreamer, error) {
	var _arg0 *C.SoupMultipartInputStream // out
	var _arg1 *C.GAsyncResult             // out
	var _cret *C.GInputStream             // in
	var _cerr *C.GError                   // in

	_arg0 = (*C.SoupMultipartInputStream)(unsafe.Pointer(multipart.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.soup_multipart_input_stream_next_part_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(multipart)
	runtime.KeepAlive(result)

	var _inputStream gio.InputStreamer // out
	var _goerr error                   // out

	if _cret != nil {
		_inputStream = (externglib.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(gio.InputStreamer)
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _inputStream, _goerr
}
