// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: libsoup-2.4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <libsoup/soup.h>
// extern void callbackDelete(gpointer);
// void _gotk4_soup2_ServerCallback(SoupServer*, SoupMessage*, char*, GHashTable*, SoupClientContext*, gpointer);
// void _gotk4_soup2_ServerWebsocketCallback(SoupServer*, SoupWebsocketConnection*, char*, SoupClientContext*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.soup_server_listen_options_get_type()), F: marshalServerListenOptions},
		{T: externglib.Type(C.soup_server_get_type()), F: marshalServerer},
		{T: externglib.Type(C.soup_client_context_get_type()), F: marshalClientContext},
	})
}

// SERVER_ADD_WEBSOCKET_EXTENSION alias for the Server:add-websocket-extension
// property, qv.
const SERVER_ADD_WEBSOCKET_EXTENSION = "add-websocket-extension"

// SERVER_ASYNC_CONTEXT alias for the deprecated Server:async-context property,
// qv.
//
// Deprecated: The new API uses the thread-default Context rather than having an
// explicitly-specified one.
const SERVER_ASYNC_CONTEXT = "async-context"

// SERVER_HTTPS_ALIASES alias for the Server:https-aliases property, qv.
const SERVER_HTTPS_ALIASES = "https-aliases"

// SERVER_HTTP_ALIASES alias for the Server:http-aliases property, qv.
const SERVER_HTTP_ALIASES = "http-aliases"

// SERVER_INTERFACE alias for the Server:interface property, qv.
//
// Deprecated: Servers can listen on multiple interfaces at once now. Use
// soup_server_listen(), etc, to listen on an interface, and
// soup_server_get_uris() to see what addresses are being listened on.
const SERVER_INTERFACE = "interface"

// SERVER_PORT alias for the deprecated Server:port property, qv.
//
// Deprecated: Servers can listen on multiple interfaces at once now. Use
// soup_server_listen(), etc, to listen on a port, and soup_server_get_uris() to
// see what ports are being listened on.
const SERVER_PORT = "port"

// SERVER_RAW_PATHS alias for the Server:raw-paths property. (If TRUE,
// percent-encoding in the Request-URI path will not be automatically decoded.)
const SERVER_RAW_PATHS = "raw-paths"

// SERVER_REMOVE_WEBSOCKET_EXTENSION alias for the
// Server:remove-websocket-extension property, qv.
const SERVER_REMOVE_WEBSOCKET_EXTENSION = "remove-websocket-extension"

// SERVER_SERVER_HEADER alias for the Server:server-header property, qv.
const SERVER_SERVER_HEADER = "server-header"

// SERVER_SSL_CERT_FILE alias for the Server:ssl-cert-file property, qv.
//
// Deprecated: use Server:tls-certificate or soup_server_set_ssl_certificate().
const SERVER_SSL_CERT_FILE = "ssl-cert-file"

// SERVER_SSL_KEY_FILE alias for the Server:ssl-key-file property, qv.
//
// Deprecated: use Server:tls-certificate or soup_server_set_ssl_certificate().
const SERVER_SSL_KEY_FILE = "ssl-key-file"

// SERVER_TLS_CERTIFICATE alias for the Server:tls-certificate property, qv.
const SERVER_TLS_CERTIFICATE = "tls-certificate"

// ServerListenOptions options to pass to soup_server_listen(), etc.
//
// SOUP_SERVER_LISTEN_IPV4_ONLY and SOUP_SERVER_LISTEN_IPV6_ONLY only make sense
// with soup_server_listen_all() and soup_server_listen_local(), not plain
// soup_server_listen() (which simply listens on whatever kind of socket you
// give it). And you cannot specify both of them in a single call.
type ServerListenOptions int

const (
	// ServerListenHttps: listen for https connections rather than plain http.
	ServerListenHttps ServerListenOptions = 0b1
	// ServerListenIPv4Only: only listen on IPv4 interfaces.
	ServerListenIPv4Only ServerListenOptions = 0b10
	// ServerListenIPv6Only: only listen on IPv6 interfaces.
	ServerListenIPv6Only ServerListenOptions = 0b100
)

func marshalServerListenOptions(p uintptr) (interface{}, error) {
	return ServerListenOptions(C.g_value_get_flags((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the names in string for ServerListenOptions.
func (s ServerListenOptions) String() string {
	if s == 0 {
		return "ServerListenOptions(0)"
	}

	var builder strings.Builder
	builder.Grow(59)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case ServerListenHttps:
			builder.WriteString("Https|")
		case ServerListenIPv4Only:
			builder.WriteString("IPv4Only|")
		case ServerListenIPv6Only:
			builder.WriteString("IPv6Only|")
		default:
			builder.WriteString(fmt.Sprintf("ServerListenOptions(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s ServerListenOptions) Has(other ServerListenOptions) bool {
	return (s & other) == other
}

// ServerCallback: callback used to handle requests to a Server.
//
// path and query contain the likewise-named components of the Request-URI,
// subject to certain assumptions. By default, Server decodes all
// percent-encoding in the URI path, such that "/foo%<!-- -->2Fbar" is treated
// the same as "/foo/bar". If your server is serving resources in some
// non-POSIX-filesystem namespace, you may want to distinguish those as two
// distinct paths. In that case, you can set the SOUP_SERVER_RAW_PATHS property
// when creating the Server, and it will leave those characters undecoded. (You
// may want to call soup_uri_normalize() to decode any percent-encoded
// characters that you aren't handling specially.)
//
// query contains the query component of the Request-URI parsed according to the
// rules for HTML form handling. Although this is the only commonly-used query
// string format in HTTP, there is nothing that actually requires that HTTP URIs
// use that format; if your server needs to use some other format, you can just
// ignore query, and call soup_message_get_uri() and parse the URI's query field
// yourself.
//
// See soup_server_add_handler() and soup_server_add_early_handler() for details
// of what handlers can/should do.
type ServerCallback func(server *Server, msg *Message, path string, query map[string]string, client *ClientContext)

//export _gotk4_soup2_ServerCallback
func _gotk4_soup2_ServerCallback(arg0 *C.SoupServer, arg1 *C.SoupMessage, arg2 *C.char, arg3 *C.GHashTable, arg4 *C.SoupClientContext, arg5 C.gpointer) {
	v := gbox.Get(uintptr(arg5))
	if v == nil {
		panic(`callback not found`)
	}

	var server *Server          // out
	var msg *Message            // out
	var path string             // out
	var query map[string]string // out
	var client *ClientContext   // out

	server = wrapServer(externglib.Take(unsafe.Pointer(arg0)))
	msg = wrapMessage(externglib.Take(unsafe.Pointer(arg1)))
	path = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	if arg3 != nil {
		query = make(map[string]string, gextras.HashTableSize(unsafe.Pointer(arg3)))
		gextras.MoveHashTable(unsafe.Pointer(arg3), false, func(k, v unsafe.Pointer) {
			ksrc := *(**C.gchar)(k)
			vsrc := *(**C.gchar)(v)
			var kdst string // out
			var vdst string // out
			kdst = C.GoString((*C.gchar)(unsafe.Pointer(ksrc)))
			vdst = C.GoString((*C.gchar)(unsafe.Pointer(vsrc)))
			query[kdst] = vdst
		})
	}
	client = (*ClientContext)(gextras.NewStructNative(unsafe.Pointer(arg4)))

	fn := v.(ServerCallback)
	fn(server, msg, path, query, client)
}

// ServerWebsocketCallback: callback used to handle WebSocket requests to a
// Server. The callback will be invoked after sending the handshake response
// back to the client (and is only invoked if the handshake was successful).
//
// path contains the path of the Request-URI, subject to the same rules as
// ServerCallback (qv).
type ServerWebsocketCallback func(server *Server, connection *WebsocketConnection, path string, client *ClientContext)

//export _gotk4_soup2_ServerWebsocketCallback
func _gotk4_soup2_ServerWebsocketCallback(arg0 *C.SoupServer, arg1 *C.SoupWebsocketConnection, arg2 *C.char, arg3 *C.SoupClientContext, arg4 C.gpointer) {
	v := gbox.Get(uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var server *Server                  // out
	var connection *WebsocketConnection // out
	var path string                     // out
	var client *ClientContext           // out

	server = wrapServer(externglib.Take(unsafe.Pointer(arg0)))
	connection = wrapWebsocketConnection(externglib.Take(unsafe.Pointer(arg1)))
	path = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	client = (*ClientContext)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	fn := v.(ServerWebsocketCallback)
	fn(server, connection, path, client)
}

// ServerOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type ServerOverrider interface {
	RequestAborted(msg *Message, client *ClientContext)
	RequestFinished(msg *Message, client *ClientContext)
	RequestRead(msg *Message, client *ClientContext)
	RequestStarted(msg *Message, client *ClientContext)
}

type Server struct {
	*externglib.Object
}

func wrapServer(obj *externglib.Object) *Server {
	return &Server{
		Object: obj,
	}
}

func marshalServerer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapServer(obj), nil
}

// AcceptIostream: add a new client stream to the server.
func (server *Server) AcceptIostream(stream gio.IOStreamer, localAddr gio.SocketAddresser, remoteAddr gio.SocketAddresser) error {
	var _arg0 *C.SoupServer     // out
	var _arg1 *C.GIOStream      // out
	var _arg2 *C.GSocketAddress // out
	var _arg3 *C.GSocketAddress // out
	var _cerr *C.GError         // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))
	_arg1 = (*C.GIOStream)(unsafe.Pointer(stream.Native()))
	if localAddr != nil {
		_arg2 = (*C.GSocketAddress)(unsafe.Pointer(localAddr.Native()))
	}
	if remoteAddr != nil {
		_arg3 = (*C.GSocketAddress)(unsafe.Pointer(remoteAddr.Native()))
	}

	C.soup_server_accept_iostream(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(server)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(localAddr)
	runtime.KeepAlive(remoteAddr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// AddAuthDomain adds an authentication domain to server. Each auth domain will
// have the chance to require authentication for each request that comes in;
// normally auth domains will require authentication for requests on certain
// paths that they have been set up to watch, or that meet other criteria set by
// the caller. If an auth domain determines that a request requires
// authentication (and the request doesn't contain authentication), server will
// automatically reject the request with an appropriate status (401 Unauthorized
// or 407 Proxy Authentication Required). If the request used the "100-continue"
// Expectation, server will reject it before the request body is sent.
func (server *Server) AddAuthDomain(authDomain AuthDomainer) {
	var _arg0 *C.SoupServer     // out
	var _arg1 *C.SoupAuthDomain // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))
	_arg1 = (*C.SoupAuthDomain)(unsafe.Pointer(authDomain.Native()))

	C.soup_server_add_auth_domain(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(authDomain)
}

// AddEarlyHandler adds an "early" handler to server for requests under path.
// Note that "normal" and "early" handlers are matched up together, so if you
// add a normal handler for "/foo" and an early handler for "/foo/bar", then a
// request to "/foo/bar" (or any path below it) will run only the early handler.
// (But if you add both handlers at the same path, then both will get run.)
//
// For requests under path (that have not already been assigned a status code by
// a AuthDomain or a signal handler), callback will be invoked after receiving
// the request headers, but before receiving the request body; the message's
// Message:method and Message:request-headers fields will be filled in.
//
// Early handlers are generally used for processing requests with request bodies
// in a streaming fashion. If you determine that the request will contain a
// message body, normally you would call soup_message_body_set_accumulate() on
// the message's Message:request-body to turn off request-body accumulation, and
// connect to the message's Message::got-chunk signal to process each chunk as
// it comes in.
//
// To complete the message processing after the full message body has been read,
// you can either also connect to Message::got-body, or else you can register a
// non-early handler for path as well. As long as you have not set the
// Message:status-code by the time Message::got-body is emitted, the non-early
// handler will be run as well.
func (server *Server) AddEarlyHandler(path string, callback ServerCallback) {
	var _arg0 *C.SoupServer        // out
	var _arg1 *C.char              // out
	var _arg2 C.SoupServerCallback // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))
	if path != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*[0]byte)(C._gotk4_soup2_ServerCallback)
	_arg3 = C.gpointer(gbox.Assign(callback))
	_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.soup_server_add_early_handler(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(server)
	runtime.KeepAlive(path)
	runtime.KeepAlive(callback)
}

// AddHandler adds a handler to server for requests under path. If path is NULL
// or "/", then this will be the default handler for all requests that don't
// have a more specific handler. (Note though that if you want to handle
// requests to the special "*" URI, you must explicitly register a handler for
// "*"; the default handler will not be used for that case.)
//
// For requests under path (that have not already been assigned a status code by
// a AuthDomain, an early ServerHandler, or a signal handler), callback will be
// invoked after receiving the request body; the message's Message:method,
// Message:request-headers, and Message:request-body fields will be filled in.
//
// After determining what to do with the request, the callback must at a minimum
// call soup_message_set_status() (or soup_message_set_status_full()) on the
// message to set the response status code. Additionally, it may set response
// headers and/or fill in the response body.
//
// If the callback cannot fully fill in the response before returning (eg, if it
// needs to wait for information from a database, or another network server), it
// should call soup_server_pause_message() to tell server to not send the
// response right away. When the response is ready, call
// soup_server_unpause_message() to cause it to be sent.
//
// To send the response body a bit at a time using "chunked" encoding, first
// call soup_message_headers_set_encoding() to set SOUP_ENCODING_CHUNKED on the
// Message:response-headers. Then call soup_message_body_append() (or
// soup_message_body_append_buffer()) to append each chunk as it becomes ready,
// and soup_server_unpause_message() to make sure it's running. (The server will
// automatically pause the message if it is using chunked encoding but no more
// chunks are available.) When you are done, call soup_message_body_complete()
// to indicate that no more chunks are coming.
func (server *Server) AddHandler(path string, callback ServerCallback) {
	var _arg0 *C.SoupServer        // out
	var _arg1 *C.char              // out
	var _arg2 C.SoupServerCallback // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))
	if path != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*[0]byte)(C._gotk4_soup2_ServerCallback)
	_arg3 = C.gpointer(gbox.Assign(callback))
	_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.soup_server_add_handler(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(server)
	runtime.KeepAlive(path)
	runtime.KeepAlive(callback)
}

// AddWebsocketExtension: add support for a WebSocket extension of the given
// extension_type. When a WebSocket client requests an extension of
// extension_type, a new WebsocketExtension of type extension_type will be
// created to handle the request.
//
// You can also add support for a WebSocket extension to the server at construct
// time by using the SOUP_SERVER_ADD_WEBSOCKET_EXTENSION property. Note that
// WebsocketExtensionDeflate is supported by default, use
// soup_server_remove_websocket_extension() if you want to disable it.
func (server *Server) AddWebsocketExtension(extensionType externglib.Type) {
	var _arg0 *C.SoupServer // out
	var _arg1 C.GType       // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))
	_arg1 = C.GType(extensionType)

	C.soup_server_add_websocket_extension(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(extensionType)
}

// AddWebsocketHandler adds a WebSocket handler to server for requests under
// path. (If path is NULL or "/", then this will be the default handler for all
// requests that don't have a more specific handler.)
//
// When a path has a WebSocket handler registered, server will check incoming
// requests for WebSocket handshakes after all other handlers have run (unless
// some earlier handler has already set a status code on the message), and
// update the request's status, response headers, and response body accordingly.
//
// If origin is non-NULL, then only requests containing a matching "Origin"
// header will be accepted. If protocols is non-NULL, then only requests
// containing a compatible "Sec-WebSocket-Protocols" header will be accepted.
// More complicated requirements can be handled by adding a normal handler to
// path, and having it perform whatever checks are needed (possibly calling
// soup_server_check_websocket_handshake() one or more times), and setting a
// failure status code if the handshake should be rejected.
func (server *Server) AddWebsocketHandler(path string, origin string, protocols []string, callback ServerWebsocketCallback) {
	var _arg0 *C.SoupServer                 // out
	var _arg1 *C.char                       // out
	var _arg2 *C.char                       // out
	var _arg3 **C.char                      // out
	var _arg4 C.SoupServerWebsocketCallback // out
	var _arg5 C.gpointer
	var _arg6 C.GDestroyNotify

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))
	if path != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if origin != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(origin)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	{
		_arg3 = (**C.char)(C.malloc(C.ulong(len(protocols)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg3))
		{
			out := unsafe.Slice(_arg3, len(protocols)+1)
			var zero *C.char
			out[len(protocols)] = zero
			for i := range protocols {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(protocols[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	_arg4 = (*[0]byte)(C._gotk4_soup2_ServerWebsocketCallback)
	_arg5 = C.gpointer(gbox.Assign(callback))
	_arg6 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.soup_server_add_websocket_handler(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(server)
	runtime.KeepAlive(path)
	runtime.KeepAlive(origin)
	runtime.KeepAlive(protocols)
	runtime.KeepAlive(callback)
}

// Disconnect closes and frees server's listening sockets. If you are using the
// old Server APIs, this also includes the effect of soup_server_quit().
//
// Note that if there are currently requests in progress on server, that they
// will continue to be processed if server's Context is still running.
//
// You can call soup_server_listen(), etc, after calling this function if you
// want to start listening again.
func (server *Server) Disconnect() {
	var _arg0 *C.SoupServer // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))

	C.soup_server_disconnect(_arg0)
	runtime.KeepAlive(server)
}

// AsyncContext gets server's async_context, if you are using the old API. (With
// the new API, the server runs in the thread's thread-default Context,
// regardless of what this method returns.)
//
// This does not add a ref to the context, so you will need to ref it yourself
// if you want it to outlive its server.
//
// Deprecated: If you are using soup_server_listen(), etc, then the server
// listens on the thread-default Context, and this property is ignored.
func (server *Server) AsyncContext() *glib.MainContext {
	var _arg0 *C.SoupServer   // out
	var _cret *C.GMainContext // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))

	_cret = C.soup_server_get_async_context(_arg0)
	runtime.KeepAlive(server)

	var _mainContext *glib.MainContext // out

	if _cret != nil {
		_mainContext = (*glib.MainContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_main_context_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_mainContext)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_main_context_unref((*C.GMainContext)(intern.C))
			},
		)
	}

	return _mainContext
}

// Listener gets server's listening socket, if you are using the old API.
//
// You should treat this socket as read-only; writing to it or modifiying it may
// cause server to malfunction.
//
// Deprecated: If you are using soup_server_listen(), etc, then use
// soup_server_get_listeners() to get a list of all listening sockets, but note
// that that function returns #GSockets, not Sockets.
func (server *Server) Listener() *Socket {
	var _arg0 *C.SoupServer // out
	var _cret *C.SoupSocket // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))

	_cret = C.soup_server_get_listener(_arg0)
	runtime.KeepAlive(server)

	var _socket *Socket // out

	_socket = wrapSocket(externglib.Take(unsafe.Pointer(_cret)))

	return _socket
}

// Listeners gets server's list of listening sockets.
//
// You should treat these sockets as read-only; writing to or modifiying any of
// these sockets may cause server to malfunction.
//
// (Beware that in contrast to the old soup_server_get_listener(), this function
// returns #GSockets, not Sockets.)
func (server *Server) Listeners() []gio.Socket {
	var _arg0 *C.SoupServer // out
	var _cret *C.GSList     // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))

	_cret = C.soup_server_get_listeners(_arg0)
	runtime.KeepAlive(server)

	var _sList []gio.Socket // out

	_sList = make([]gio.Socket, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GSocket)(v)
		var dst gio.Socket // out
		{
			obj := externglib.Take(unsafe.Pointer(src))
			dst = gio.Socket{
				Object: obj,
				DatagramBased: gio.DatagramBased{
					Object: obj,
				},
				Initable: gio.Initable{
					Object: obj,
				},
			}
		}
		_sList = append(_sList, dst)
	})

	return _sList
}

// Port gets the TCP port that server is listening on, if you are using the old
// API.
//
// Deprecated: If you are using soup_server_listen(), etc, then use
// soup_server_get_uris() to get a list of all listening addresses.
func (server *Server) Port() uint {
	var _arg0 *C.SoupServer // out
	var _cret C.guint       // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))

	_cret = C.soup_server_get_port(_arg0)
	runtime.KeepAlive(server)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// URIs gets a list of URIs corresponding to the interfaces server is listening
// on. These will contain IP addresses, not hostnames, and will also indicate
// whether the given listener is http or https.
//
// Note that if you used soup_server_listen_all(), the returned URIs will use
// the addresses <literal>0.0.0.0</literal> and <literal>::</literal>, rather
// than actually returning separate URIs for each interface on the system.
func (server *Server) URIs() []URI {
	var _arg0 *C.SoupServer // out
	var _cret *C.GSList     // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))

	_cret = C.soup_server_get_uris(_arg0)
	runtime.KeepAlive(server)

	var _sList []URI // out

	_sList = make([]URI, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.SoupURI)(v)
		var dst URI // out
		dst = *(*URI)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(&dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.soup_uri_free((*C.SoupURI)(intern.C))
			},
		)
		_sList = append(_sList, dst)
	})

	return _sList
}

// IsHttps checks whether server is capable of https.
//
// In order for a server to run https, you must call
// soup_server_set_ssl_cert_file(), or set the Server:tls-certificate property,
// to provide it with a certificate to use.
//
// If you are using the deprecated single-listener APIs, then a return value of
// TRUE indicates that the Server serves https exclusively. If you are using
// soup_server_listen(), etc, then a TRUE return value merely indicates that the
// server is <emphasis>able</emphasis> to do https, regardless of whether it
// actually currently is or not. Use soup_server_get_uris() to see if it
// currently has any https listeners.
func (server *Server) IsHttps() bool {
	var _arg0 *C.SoupServer // out
	var _cret C.gboolean    // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))

	_cret = C.soup_server_is_https(_arg0)
	runtime.KeepAlive(server)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Listen: this attempts to set up server to listen for connections on address.
//
// If options includes SOUP_SERVER_LISTEN_HTTPS, and server has been configured
// for TLS, then server will listen for https connections on this port.
// Otherwise it will listen for plain http.
//
// You may call this method (along with the other "listen" methods) any number
// of times on a server, if you want to listen on multiple ports, or set up both
// http and https service.
//
// After calling this method, server will begin accepting and processing
// connections as soon as the appropriate Context is run.
//
// Note that Server never makes use of dual IPv4/IPv6 sockets; if address is an
// IPv6 address, it will only accept IPv6 connections. You must configure IPv4
// listening separately.
func (server *Server) Listen(address gio.SocketAddresser, options ServerListenOptions) error {
	var _arg0 *C.SoupServer             // out
	var _arg1 *C.GSocketAddress         // out
	var _arg2 C.SoupServerListenOptions // out
	var _cerr *C.GError                 // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))
	_arg1 = (*C.GSocketAddress)(unsafe.Pointer(address.Native()))
	_arg2 = C.SoupServerListenOptions(options)

	C.soup_server_listen(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(server)
	runtime.KeepAlive(address)
	runtime.KeepAlive(options)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ListenAll: this attempts to set up server to listen for connections on all
// interfaces on the system. (That is, it listens on the addresses
// <literal>0.0.0.0</literal> and/or <literal>::</literal>, depending on whether
// options includes SOUP_SERVER_LISTEN_IPV4_ONLY, SOUP_SERVER_LISTEN_IPV6_ONLY,
// or neither.) If port is specified, server will listen on that port. If it is
// 0, server will find an unused port to listen on. (In that case, you can use
// soup_server_get_uris() to find out what port it ended up choosing.)
//
// See soup_server_listen() for more details.
func (server *Server) ListenAll(port uint, options ServerListenOptions) error {
	var _arg0 *C.SoupServer             // out
	var _arg1 C.guint                   // out
	var _arg2 C.SoupServerListenOptions // out
	var _cerr *C.GError                 // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))
	_arg1 = C.guint(port)
	_arg2 = C.SoupServerListenOptions(options)

	C.soup_server_listen_all(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(server)
	runtime.KeepAlive(port)
	runtime.KeepAlive(options)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ListenFd: this attempts to set up server to listen for connections on fd.
//
// See soup_server_listen() for more details.
//
// Note that server will close fd when you free it or call
// soup_server_disconnect().
func (server *Server) ListenFd(fd int, options ServerListenOptions) error {
	var _arg0 *C.SoupServer             // out
	var _arg1 C.int                     // out
	var _arg2 C.SoupServerListenOptions // out
	var _cerr *C.GError                 // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))
	_arg1 = C.int(fd)
	_arg2 = C.SoupServerListenOptions(options)

	C.soup_server_listen_fd(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(server)
	runtime.KeepAlive(fd)
	runtime.KeepAlive(options)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ListenLocal: this attempts to set up server to listen for connections on
// "localhost" (that is, <literal>127.0.0.1</literal> and/or
// <literal>::1</literal>, depending on whether options includes
// SOUP_SERVER_LISTEN_IPV4_ONLY, SOUP_SERVER_LISTEN_IPV6_ONLY, or neither). If
// port is specified, server will listen on that port. If it is 0, server will
// find an unused port to listen on. (In that case, you can use
// soup_server_get_uris() to find out what port it ended up choosing.)
//
// See soup_server_listen() for more details.
func (server *Server) ListenLocal(port uint, options ServerListenOptions) error {
	var _arg0 *C.SoupServer             // out
	var _arg1 C.guint                   // out
	var _arg2 C.SoupServerListenOptions // out
	var _cerr *C.GError                 // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))
	_arg1 = C.guint(port)
	_arg2 = C.SoupServerListenOptions(options)

	C.soup_server_listen_local(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(server)
	runtime.KeepAlive(port)
	runtime.KeepAlive(options)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ListenSocket: this attempts to set up server to listen for connections on
// socket.
//
// See soup_server_listen() for more details.
func (server *Server) ListenSocket(socket *gio.Socket, options ServerListenOptions) error {
	var _arg0 *C.SoupServer             // out
	var _arg1 *C.GSocket                // out
	var _arg2 C.SoupServerListenOptions // out
	var _cerr *C.GError                 // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))
	_arg1 = (*C.GSocket)(unsafe.Pointer(socket.Native()))
	_arg2 = C.SoupServerListenOptions(options)

	C.soup_server_listen_socket(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(server)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(options)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// PauseMessage pauses I/O on msg. This can be used when you need to return from
// the server handler without having the full response ready yet. Use
// soup_server_unpause_message() to resume I/O.
//
// This must only be called on Messages which were created by the Server and are
// currently doing I/O, such as those passed into a ServerCallback or emitted in
// a Server::request-read signal.
func (server *Server) PauseMessage(msg *Message) {
	var _arg0 *C.SoupServer  // out
	var _arg1 *C.SoupMessage // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	C.soup_server_pause_message(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(msg)
}

// Quit stops processing for server, if you are using the old API. Call this to
// clean up after soup_server_run_async(), or to terminate a call to
// soup_server_run().
//
// Note that messages currently in progress will continue to be handled, if the
// main loop associated with the server is resumed or kept running.
//
// server is still in a working state after this call; you can start and stop a
// server as many times as you want.
//
// Deprecated: When using soup_server_listen(), etc, the server will always
// listen for connections, and will process them whenever the thread-default
// Context is running.
func (server *Server) Quit() {
	var _arg0 *C.SoupServer // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))

	C.soup_server_quit(_arg0)
	runtime.KeepAlive(server)
}

// RemoveAuthDomain removes auth_domain from server.
func (server *Server) RemoveAuthDomain(authDomain AuthDomainer) {
	var _arg0 *C.SoupServer     // out
	var _arg1 *C.SoupAuthDomain // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))
	_arg1 = (*C.SoupAuthDomain)(unsafe.Pointer(authDomain.Native()))

	C.soup_server_remove_auth_domain(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(authDomain)
}

// RemoveHandler removes all handlers (early and normal) registered at path.
func (server *Server) RemoveHandler(path string) {
	var _arg0 *C.SoupServer // out
	var _arg1 *C.char       // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	C.soup_server_remove_handler(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(path)
}

// RemoveWebsocketExtension removes support for WebSocket extension of type
// extension_type (or any subclass of extension_type) from server. You can also
// remove extensions enabled by default from the server at construct time by
// using the SOUP_SERVER_REMOVE_WEBSOCKET_EXTENSION property.
func (server *Server) RemoveWebsocketExtension(extensionType externglib.Type) {
	var _arg0 *C.SoupServer // out
	var _arg1 C.GType       // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))
	_arg1 = C.GType(extensionType)

	C.soup_server_remove_websocket_extension(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(extensionType)
}

// Run starts server, if you are using the old API, causing it to listen for and
// process incoming connections. Unlike soup_server_run_async(), this creates a
// Loop and runs it, and it will not return until someone calls
// soup_server_quit() to stop the server.
//
// Deprecated: When using soup_server_listen(), etc, the server will always
// listen for connections, and will process them whenever the thread-default
// Context is running.
func (server *Server) Run() {
	var _arg0 *C.SoupServer // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))

	C.soup_server_run(_arg0)
	runtime.KeepAlive(server)
}

// RunAsync starts server, if you are using the old API, causing it to listen
// for and process incoming connections.
//
// The server runs in server's Context. It will not actually perform any
// processing unless the appropriate main loop is running. In the simple case
// where you did not set the server's SOUP_SERVER_ASYNC_CONTEXT property, this
// means the server will run whenever the glib main loop is running.
//
// Deprecated: When using soup_server_listen(), etc, the server will always
// listen for connections, and will process them whenever the thread-default
// Context is running.
func (server *Server) RunAsync() {
	var _arg0 *C.SoupServer // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))

	C.soup_server_run_async(_arg0)
	runtime.KeepAlive(server)
}

// SetSSLCertFile sets server up to do https, using the SSL/TLS certificate
// specified by ssl_cert_file and ssl_key_file (which may point to the same
// file).
//
// Alternatively, you can set the Server:tls-certificate property at
// construction time, if you already have a Certificate.
func (server *Server) SetSSLCertFile(sslCertFile string, sslKeyFile string) error {
	var _arg0 *C.SoupServer // out
	var _arg1 *C.char       // out
	var _arg2 *C.char       // out
	var _cerr *C.GError     // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(sslCertFile)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(sslKeyFile)))
	defer C.free(unsafe.Pointer(_arg2))

	C.soup_server_set_ssl_cert_file(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(server)
	runtime.KeepAlive(sslCertFile)
	runtime.KeepAlive(sslKeyFile)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// UnpauseMessage resumes I/O on msg. Use this to resume after calling
// soup_server_pause_message(), or after adding a new chunk to a chunked
// response.
//
// I/O won't actually resume until you return to the main loop.
//
// This must only be called on Messages which were created by the Server and are
// currently doing I/O, such as those passed into a ServerCallback or emitted in
// a Server::request-read signal.
func (server *Server) UnpauseMessage(msg *Message) {
	var _arg0 *C.SoupServer  // out
	var _arg1 *C.SoupMessage // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(server.Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	C.soup_server_unpause_message(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(msg)
}

// ClientContext provides additional information about the client making a
// particular request. In particular, you can use
// soup_client_context_get_auth_domain() and soup_client_context_get_auth_user()
// to determine if HTTP authentication was used successfully.
//
// soup_client_context_get_remote_address() and/or
// soup_client_context_get_host() can be used to get information for logging or
// debugging purposes. soup_client_context_get_gsocket() may also be of use in
// some situations (eg, tracking when multiple requests are made on the same
// connection).
//
// An instance of this type is always passed by reference.
type ClientContext struct {
	*clientContext
}

// clientContext is the struct that's finalized.
type clientContext struct {
	native *C.SoupClientContext
}

func marshalClientContext(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return &ClientContext{&clientContext{(*C.SoupClientContext)(unsafe.Pointer(b))}}, nil
}

// Address retrieves the Address associated with the remote end of a connection.
//
// Deprecated: Use soup_client_context_get_remote_address(), which returns a
// Address.
func (client *ClientContext) Address() *Address {
	var _arg0 *C.SoupClientContext // out
	var _cret *C.SoupAddress       // in

	_arg0 = (*C.SoupClientContext)(gextras.StructNative(unsafe.Pointer(client)))

	_cret = C.soup_client_context_get_address(_arg0)
	runtime.KeepAlive(client)

	var _address *Address // out

	if _cret != nil {
		_address = wrapAddress(externglib.Take(unsafe.Pointer(_cret)))
	}

	return _address
}

// AuthDomain checks whether the request associated with client has been
// authenticated, and if so returns the AuthDomain that authenticated it.
func (client *ClientContext) AuthDomain() AuthDomainer {
	var _arg0 *C.SoupClientContext // out
	var _cret *C.SoupAuthDomain    // in

	_arg0 = (*C.SoupClientContext)(gextras.StructNative(unsafe.Pointer(client)))

	_cret = C.soup_client_context_get_auth_domain(_arg0)
	runtime.KeepAlive(client)

	var _authDomain AuthDomainer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			rv, ok := (externglib.CastObject(object)).(AuthDomainer)
			if !ok {
				panic("object of type " + object.TypeFromInstance().String() + " is not soup.AuthDomainer")
			}
			_authDomain = rv
		}
	}

	return _authDomain
}

// AuthUser checks whether the request associated with client has been
// authenticated, and if so returns the username that the client authenticated
// as.
func (client *ClientContext) AuthUser() string {
	var _arg0 *C.SoupClientContext // out
	var _cret *C.char              // in

	_arg0 = (*C.SoupClientContext)(gextras.StructNative(unsafe.Pointer(client)))

	_cret = C.soup_client_context_get_auth_user(_arg0)
	runtime.KeepAlive(client)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Gsocket retrieves the #GSocket that client is associated with.
//
// If you are using this method to observe when multiple requests are made on
// the same persistent HTTP connection (eg, as the ntlm-test test program does),
// you will need to pay attention to socket destruction as well (eg, by using
// weak references), so that you do not get fooled when the allocator reuses the
// memory address of a previously-destroyed socket to represent a new socket.
func (client *ClientContext) Gsocket() *gio.Socket {
	var _arg0 *C.SoupClientContext // out
	var _cret *C.GSocket           // in

	_arg0 = (*C.SoupClientContext)(gextras.StructNative(unsafe.Pointer(client)))

	_cret = C.soup_client_context_get_gsocket(_arg0)
	runtime.KeepAlive(client)

	var _socket *gio.Socket // out

	if _cret != nil {
		{
			obj := externglib.Take(unsafe.Pointer(_cret))
			_socket = &gio.Socket{
				Object: obj,
				DatagramBased: gio.DatagramBased{
					Object: obj,
				},
				Initable: gio.Initable{
					Object: obj,
				},
			}
		}
	}

	return _socket
}

// Host retrieves the IP address associated with the remote end of a connection.
func (client *ClientContext) Host() string {
	var _arg0 *C.SoupClientContext // out
	var _cret *C.char              // in

	_arg0 = (*C.SoupClientContext)(gextras.StructNative(unsafe.Pointer(client)))

	_cret = C.soup_client_context_get_host(_arg0)
	runtime.KeepAlive(client)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// LocalAddress retrieves the Address associated with the local end of a
// connection.
func (client *ClientContext) LocalAddress() gio.SocketAddresser {
	var _arg0 *C.SoupClientContext // out
	var _cret *C.GSocketAddress    // in

	_arg0 = (*C.SoupClientContext)(gextras.StructNative(unsafe.Pointer(client)))

	_cret = C.soup_client_context_get_local_address(_arg0)
	runtime.KeepAlive(client)

	var _socketAddress gio.SocketAddresser // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			rv, ok := (externglib.CastObject(object)).(gio.SocketAddresser)
			if !ok {
				panic("object of type " + object.TypeFromInstance().String() + " is not gio.SocketAddresser")
			}
			_socketAddress = rv
		}
	}

	return _socketAddress
}

// RemoteAddress retrieves the Address associated with the remote end of a
// connection.
func (client *ClientContext) RemoteAddress() gio.SocketAddresser {
	var _arg0 *C.SoupClientContext // out
	var _cret *C.GSocketAddress    // in

	_arg0 = (*C.SoupClientContext)(gextras.StructNative(unsafe.Pointer(client)))

	_cret = C.soup_client_context_get_remote_address(_arg0)
	runtime.KeepAlive(client)

	var _socketAddress gio.SocketAddresser // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			rv, ok := (externglib.CastObject(object)).(gio.SocketAddresser)
			if !ok {
				panic("object of type " + object.TypeFromInstance().String() + " is not gio.SocketAddresser")
			}
			_socketAddress = rv
		}
	}

	return _socketAddress
}

// Socket retrieves the Socket that client is associated with.
//
// If you are using this method to observe when multiple requests are made on
// the same persistent HTTP connection (eg, as the ntlm-test test program does),
// you will need to pay attention to socket destruction as well (either by using
// weak references, or by connecting to the Socket::disconnected signal), so
// that you do not get fooled when the allocator reuses the memory address of a
// previously-destroyed socket to represent a new socket.
//
// Deprecated: use soup_client_context_get_gsocket(), which returns a #GSocket.
func (client *ClientContext) Socket() *Socket {
	var _arg0 *C.SoupClientContext // out
	var _cret *C.SoupSocket        // in

	_arg0 = (*C.SoupClientContext)(gextras.StructNative(unsafe.Pointer(client)))

	_cret = C.soup_client_context_get_socket(_arg0)
	runtime.KeepAlive(client)

	var _socket *Socket // out

	_socket = wrapSocket(externglib.Take(unsafe.Pointer(_cret)))

	return _socket
}

// StealConnection: "Steals" the HTTP connection associated with client from its
// Server. This happens immediately, regardless of the current state of the
// connection; if the response to the current Message has not yet finished being
// sent, then it will be discarded; you can steal the connection from a
// Message:wrote-informational or Message:wrote-body signal handler if you need
// to wait for part or all of the response to be sent.
//
// Note that when calling this function from C, client will most likely be freed
// as a side effect.
func (client *ClientContext) StealConnection() gio.IOStreamer {
	var _arg0 *C.SoupClientContext // out
	var _cret *C.GIOStream         // in

	_arg0 = (*C.SoupClientContext)(gextras.StructNative(unsafe.Pointer(client)))

	_cret = C.soup_client_context_steal_connection(_arg0)
	runtime.KeepAlive(client)

	var _ioStream gio.IOStreamer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.IOStreamer is nil")
		}

		object := externglib.AssumeOwnership(objptr)
		rv, ok := (externglib.CastObject(object)).(gio.IOStreamer)
		if !ok {
			panic("object of type " + object.TypeFromInstance().String() + " is not gio.IOStreamer")
		}
		_ioStream = rv
	}

	return _ioStream
}
