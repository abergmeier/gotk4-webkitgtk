// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: libsoup-2.4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <libsoup/soup.h>
// void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
// void _gotk4_soup2_AddressCallback(SoupAddress*, guint, gpointer);
// void _gotk4_soup2_SessionCallback(SoupSession*, SoupMessage*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.soup_request_error_get_type()), F: marshalRequestError},
		{T: externglib.Type(C.soup_session_get_type()), F: marshalSessioner},
	})
}

// RequestError: Request error.
type RequestError int

const (
	// RequestErrorBadURI: URI could not be parsed
	RequestErrorBadURI RequestError = iota
	// RequestErrorUnsupportedURIScheme: URI scheme is not supported by this
	// Session
	RequestErrorUnsupportedURIScheme
	// RequestErrorParsing server's response could not be parsed
	RequestErrorParsing
	// RequestErrorEncoding server's response was in an unsupported format
	RequestErrorEncoding
)

func marshalRequestError(p uintptr) (interface{}, error) {
	return RequestError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for RequestError.
func (r RequestError) String() string {
	switch r {
	case RequestErrorBadURI:
		return "BadURI"
	case RequestErrorUnsupportedURIScheme:
		return "UnsupportedURIScheme"
	case RequestErrorParsing:
		return "Parsing"
	case RequestErrorEncoding:
		return "Encoding"
	default:
		return fmt.Sprintf("RequestError(%d)", r)
	}
}

// SessionCallback: prototype for the callback passed to
// soup_session_queue_message(), qv.
type SessionCallback func(session *Session, msg *Message)

//export _gotk4_soup2_SessionCallback
func _gotk4_soup2_SessionCallback(arg0 *C.SoupSession, arg1 *C.SoupMessage, arg2 C.gpointer) {
	v := gbox.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var session *Session // out
	var msg *Message     // out

	session = wrapSession(externglib.Take(unsafe.Pointer(arg0)))
	msg = wrapMessage(externglib.Take(unsafe.Pointer(arg1)))

	fn := v.(SessionCallback)
	fn(session, msg)
}

// SessionConnectProgressCallback: prototype for the progress callback passed to
// soup_session_connect_async().
type SessionConnectProgressCallback func(session *Session, event gio.SocketClientEvent, connection *gio.IOStream)

//export _gotk4_soup2_SessionConnectProgressCallback
func _gotk4_soup2_SessionConnectProgressCallback(arg0 *C.SoupSession, arg1 C.GSocketClientEvent, arg2 *C.GIOStream, arg3 C.gpointer) {
	v := gbox.Get(uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var session *Session            // out
	var event gio.SocketClientEvent // out
	var connection *gio.IOStream    // out

	session = wrapSession(externglib.Take(unsafe.Pointer(arg0)))
	event = gio.SocketClientEvent(arg1)
	{
		obj := externglib.Take(unsafe.Pointer(arg2))
		connection = &gio.IOStream{
			Object: obj,
		}
	}

	fn := v.(SessionConnectProgressCallback)
	fn(session, event, connection)
}

// SessionOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type SessionOverrider interface {
	AuthRequired(msg *Message, auth Auther, retrying bool)
	Authenticate(msg *Message, auth Auther, retrying bool)
	// CancelMessage causes session to immediately finish processing msg
	// (regardless of its current state) with a final status_code of
	// status_code. You may call this at any time after handing msg off to
	// session; if session has started sending the request but has not yet
	// received the complete response, then it will close the request's
	// connection. Note that with requests that have side effects (eg,
	// <literal>POST</literal>, <literal>PUT</literal>,
	// <literal>DELETE</literal>) it is possible that you might cancel the
	// request after the server acts on it, but before it returns a response,
	// leaving the remote resource in an unknown state.
	//
	// If the message is cancelled while its response body is being read, then
	// the response body in msg will be left partially-filled-in. The response
	// headers, on the other hand, will always be either empty or complete.
	//
	// Beware that with the deprecated SessionAsync, messages queued with
	// soup_session_queue_message() will have their callbacks invoked before
	// soup_session_cancel_message() returns. The plain Session does not have
	// this behavior; cancelling an asynchronous message will merely queue its
	// callback to be run after returning to the main loop.
	CancelMessage(msg *Message, statusCode uint)
	FlushQueue()
	Kick()
	// QueueMessage queues the message msg for asynchronously sending the
	// request and receiving a response in the current thread-default Context.
	// If msg has been processed before, any resources related to the time it
	// was last sent are freed.
	//
	// Upon message completion, the callback specified in callback will be
	// invoked. If after returning from this callback the message has not been
	// requeued, msg will be unreffed.
	//
	// (The behavior above applies to a plain Session; if you are using
	// SessionAsync or SessionSync, then the Context that is used depends on the
	// settings of Session:async-context and Session:use-thread-context, and for
	// SessionSync, the message will actually be sent and processed in another
	// thread, with only the final callback occurring in the indicated Context.)
	//
	// Contrast this method with soup_session_send_async(), which also
	// asynchronously sends a message, but returns before reading the response
	// body, and allows you to read the response via a Stream.
	QueueMessage(msg *Message, callback SessionCallback)
	RequestStarted(msg *Message, socket *Socket)
	// RequeueMessage: this causes msg to be placed back on the queue to be
	// attempted again.
	RequeueMessage(msg *Message)
	// SendMessage: synchronously send msg. This call will not return until the
	// transfer is finished successfully or there is an unrecoverable error.
	//
	// Unlike with soup_session_queue_message(), msg is not freed upon return.
	//
	// (Note that if you call this method on a SessionAsync, it will still use
	// asynchronous I/O internally, running the glib main loop to process the
	// message, which may also cause other events to be processed.)
	//
	// Contrast this method with soup_session_send(), which also synchronously
	// sends a message, but returns before reading the response body, and allows
	// you to read the response via a Stream.
	SendMessage(msg *Message) uint
}

type Session struct {
	*externglib.Object
}

var _ gextras.Nativer = (*Session)(nil)

func wrapSession(obj *externglib.Object) *Session {
	return &Session{
		Object: obj,
	}
}

func marshalSessioner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapSession(obj), nil
}

// NewSession creates a Session with the default options.
func NewSession() *Session {
	var _cret *C.SoupSession // in

	_cret = C.soup_session_new()

	var _session *Session // out

	_session = wrapSession(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _session
}

// Abort cancels all pending requests in session and closes all idle persistent
// connections.
//
// The message cancellation has the same semantics as with
// soup_session_cancel_message(); asynchronous requests on a SessionAsync will
// have their callback called before soup_session_abort() returns. Requests on a
// plain Session will not.
func (session *Session) Abort() {
	var _arg0 *C.SoupSession // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))

	C.soup_session_abort(_arg0)
}

// AddFeature adds feature's functionality to session. You can also add a
// feature to the session at construct time by using the
// SOUP_SESSION_ADD_FEATURE property.
//
// See the main Session documentation for information on what features are
// present in sessions by default.
func (session *Session) AddFeature(feature SessionFeaturer) {
	var _arg0 *C.SoupSession        // out
	var _arg1 *C.SoupSessionFeature // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = (*C.SoupSessionFeature)(unsafe.Pointer((feature).(gextras.Nativer).Native()))

	C.soup_session_add_feature(_arg0, _arg1)
}

// AddFeatureByType: if feature_type is the type of a class that implements
// SessionFeature, this creates a new feature of that type and adds it to
// session as with soup_session_add_feature(). You can use this when you don't
// need to customize the new feature in any way.
//
// If feature_type is not a SessionFeature type, this gives each existing
// feature on session the chance to accept feature_type as a "subfeature". This
// can be used to add new Auth or Request types, for instance.
//
// You can also add a feature to the session at construct time by using the
// SOUP_SESSION_ADD_FEATURE_BY_TYPE property.
//
// See the main Session documentation for information on what features are
// present in sessions by default.
func (session *Session) AddFeatureByType(featureType externglib.Type) {
	var _arg0 *C.SoupSession // out
	var _arg1 C.GType        // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = C.GType(featureType)

	C.soup_session_add_feature_by_type(_arg0, _arg1)
}

// CancelMessage causes session to immediately finish processing msg (regardless
// of its current state) with a final status_code of status_code. You may call
// this at any time after handing msg off to session; if session has started
// sending the request but has not yet received the complete response, then it
// will close the request's connection. Note that with requests that have side
// effects (eg, <literal>POST</literal>, <literal>PUT</literal>,
// <literal>DELETE</literal>) it is possible that you might cancel the request
// after the server acts on it, but before it returns a response, leaving the
// remote resource in an unknown state.
//
// If the message is cancelled while its response body is being read, then the
// response body in msg will be left partially-filled-in. The response headers,
// on the other hand, will always be either empty or complete.
//
// Beware that with the deprecated SessionAsync, messages queued with
// soup_session_queue_message() will have their callbacks invoked before
// soup_session_cancel_message() returns. The plain Session does not have this
// behavior; cancelling an asynchronous message will merely queue its callback
// to be run after returning to the main loop.
func (session *Session) CancelMessage(msg *Message, statusCode uint) {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out
	var _arg2 C.guint        // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg2 = C.guint(statusCode)

	C.soup_session_cancel_message(_arg0, _arg1, _arg2)
}

// ConnectFinish gets the OStream created for the connection to communicate with
// the server.
func (session *Session) ConnectFinish(result gio.AsyncResulter) (*gio.IOStream, error) {
	var _arg0 *C.SoupSession  // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GIOStream    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((result).(gextras.Nativer).Native()))

	_cret = C.soup_session_connect_finish(_arg0, _arg1, &_cerr)

	var _ioStream *gio.IOStream // out
	var _goerr error            // out

	{
		obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
		_ioStream = &gio.IOStream{
			Object: obj,
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _ioStream, _goerr
}

// AsyncContext gets session's Session:async-context. This does not add a ref to
// the context, so you will need to ref it yourself if you want it to outlive
// its session.
//
// For a modern Session, this will always just return the thread-default
// Context, and so is not especially useful.
func (session *Session) AsyncContext() *glib.MainContext {
	var _arg0 *C.SoupSession  // out
	var _cret *C.GMainContext // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))

	_cret = C.soup_session_get_async_context(_arg0)

	var _mainContext *glib.MainContext // out

	_mainContext = (*glib.MainContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_mainContext, func(v *glib.MainContext) {
		C.g_main_context_unref((*C.GMainContext)(gextras.StructNative(unsafe.Pointer(v))))
	})

	return _mainContext
}

// Feature gets the first feature in session of type feature_type. For features
// where there may be more than one feature of a given type, use
// soup_session_get_features().
func (session *Session) Feature(featureType externglib.Type) *SessionFeature {
	var _arg0 *C.SoupSession        // out
	var _arg1 C.GType               // out
	var _cret *C.SoupSessionFeature // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = C.GType(featureType)

	_cret = C.soup_session_get_feature(_arg0, _arg1)

	var _sessionFeature *SessionFeature // out

	_sessionFeature = wrapSessionFeature(externglib.Take(unsafe.Pointer(_cret)))

	return _sessionFeature
}

// FeatureForMessage gets the first feature in session of type feature_type,
// provided that it is not disabled for msg. As with soup_session_get_feature(),
// this should only be used for features where feature_type is only expected to
// match a single feature. In particular, if there are two matching features,
// and the first is disabled on msg, and the second is not, then this will
// return NULL, not the second feature.
func (session *Session) FeatureForMessage(featureType externglib.Type, msg *Message) *SessionFeature {
	var _arg0 *C.SoupSession        // out
	var _arg1 C.GType               // out
	var _arg2 *C.SoupMessage        // out
	var _cret *C.SoupSessionFeature // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = C.GType(featureType)
	_arg2 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	_cret = C.soup_session_get_feature_for_message(_arg0, _arg1, _arg2)

	var _sessionFeature *SessionFeature // out

	_sessionFeature = wrapSessionFeature(externglib.Take(unsafe.Pointer(_cret)))

	return _sessionFeature
}

// HasFeature tests if session has at a feature of type feature_type (which can
// be the type of either a SessionFeature, or else a subtype of some class
// managed by another feature, such as Auth or Request).
func (session *Session) HasFeature(featureType externglib.Type) bool {
	var _arg0 *C.SoupSession // out
	var _arg1 C.GType        // out
	var _cret C.gboolean     // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = C.GType(featureType)

	_cret = C.soup_session_has_feature(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PauseMessage pauses HTTP I/O on msg. Call soup_session_unpause_message() to
// resume I/O.
//
// This may only be called for asynchronous messages (those sent on a
// SessionAsync or using soup_session_queue_message()).
func (session *Session) PauseMessage(msg *Message) {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	C.soup_session_pause_message(_arg0, _arg1)
}

// PrefetchDns tells session that an URI from the given hostname may be
// requested shortly, and so the session can try to prepare by resolving the
// domain name in advance, in order to work more quickly once the URI is
// actually requested.
//
// If cancellable is non-NULL, it can be used to cancel the resolution. callback
// will still be invoked in this case, with a status of SOUP_STATUS_CANCELLED.
func (session *Session) PrefetchDns(hostname string, cancellable *gio.Cancellable, callback AddressCallback) {
	var _arg0 *C.SoupSession        // out
	var _arg1 *C.char               // out
	var _arg2 *C.GCancellable       // out
	var _arg3 C.SoupAddressCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(hostname)))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg3 = (*[0]byte)(C._gotk4_soup2_AddressCallback)
	_arg4 = C.gpointer(gbox.AssignOnce(callback))

	C.soup_session_prefetch_dns(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// PrepareForURI tells session that uri may be requested shortly, and so the
// session can try to prepare (resolving the domain name, obtaining proxy
// address, etc.) in order to work more quickly once the URI is actually
// requested.
//
// Deprecated: use soup_session_prefetch_dns() instead.
func (session *Session) PrepareForURI(uri *URI) {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupURI     // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(uri)))

	C.soup_session_prepare_for_uri(_arg0, _arg1)
}

// QueueMessage queues the message msg for asynchronously sending the request
// and receiving a response in the current thread-default Context. If msg has
// been processed before, any resources related to the time it was last sent are
// freed.
//
// Upon message completion, the callback specified in callback will be invoked.
// If after returning from this callback the message has not been requeued, msg
// will be unreffed.
//
// (The behavior above applies to a plain Session; if you are using SessionAsync
// or SessionSync, then the Context that is used depends on the settings of
// Session:async-context and Session:use-thread-context, and for SessionSync,
// the message will actually be sent and processed in another thread, with only
// the final callback occurring in the indicated Context.)
//
// Contrast this method with soup_session_send_async(), which also
// asynchronously sends a message, but returns before reading the response body,
// and allows you to read the response via a Stream.
func (session *Session) QueueMessage(msg *Message, callback SessionCallback) {
	var _arg0 *C.SoupSession        // out
	var _arg1 *C.SoupMessage        // out
	var _arg2 C.SoupSessionCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg2 = (*[0]byte)(C._gotk4_soup2_SessionCallback)
	_arg3 = C.gpointer(gbox.AssignOnce(callback))

	C.soup_session_queue_message(_arg0, _arg1, _arg2, _arg3)
}

// RedirectMessage updates msg's URI according to its status code and "Location"
// header, and requeues it on session. Use this when you have set
// SOUP_MESSAGE_NO_REDIRECT on a message, but have decided to allow a particular
// redirection to occur, or if you want to allow a redirection that Session will
// not perform automatically (eg, redirecting a non-safe method such as DELETE).
//
// If msg's status code indicates that it should be retried as a GET request,
// then msg will be modified accordingly.
//
// If msg has already been redirected too many times, this will cause it to fail
// with SOUP_STATUS_TOO_MANY_REDIRECTS.
func (session *Session) RedirectMessage(msg *Message) bool {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out
	var _cret C.gboolean     // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	_cret = C.soup_session_redirect_message(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveFeature removes feature's functionality from session.
func (session *Session) RemoveFeature(feature SessionFeaturer) {
	var _arg0 *C.SoupSession        // out
	var _arg1 *C.SoupSessionFeature // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = (*C.SoupSessionFeature)(unsafe.Pointer((feature).(gextras.Nativer).Native()))

	C.soup_session_remove_feature(_arg0, _arg1)
}

// RemoveFeatureByType removes all features of type feature_type (or any
// subclass of feature_type) from session. You can also remove standard features
// from the session at construct time by using the
// SOUP_SESSION_REMOVE_FEATURE_BY_TYPE property.
func (session *Session) RemoveFeatureByType(featureType externglib.Type) {
	var _arg0 *C.SoupSession // out
	var _arg1 C.GType        // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = C.GType(featureType)

	C.soup_session_remove_feature_by_type(_arg0, _arg1)
}

// Request creates a Request for retrieving uri_string.
func (session *Session) Request(uriString string) (*Request, error) {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.char        // out
	var _cret *C.SoupRequest // in
	var _cerr *C.GError      // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uriString)))

	_cret = C.soup_session_request(_arg0, _arg1, &_cerr)

	var _request *Request // out
	var _goerr error      // out

	_request = wrapRequest(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _request, _goerr
}

// RequestHttp creates a Request for retrieving uri_string, which must be an
// "http" or "https" URI (or another protocol listed in session's
// Session:http-aliases or Session:https-aliases).
func (session *Session) RequestHttp(method string, uriString string) (*RequestHTTP, error) {
	var _arg0 *C.SoupSession     // out
	var _arg1 *C.char            // out
	var _arg2 *C.char            // out
	var _cret *C.SoupRequestHTTP // in
	var _cerr *C.GError          // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(method)))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(uriString)))

	_cret = C.soup_session_request_http(_arg0, _arg1, _arg2, &_cerr)

	var _requestHTTP *RequestHTTP // out
	var _goerr error              // out

	_requestHTTP = wrapRequestHTTP(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _requestHTTP, _goerr
}

// RequestHttpURI creates a Request for retrieving uri, which must be an "http"
// or "https" URI (or another protocol listed in session's Session:http-aliases
// or Session:https-aliases).
func (session *Session) RequestHttpURI(method string, uri *URI) (*RequestHTTP, error) {
	var _arg0 *C.SoupSession     // out
	var _arg1 *C.char            // out
	var _arg2 *C.SoupURI         // out
	var _cret *C.SoupRequestHTTP // in
	var _cerr *C.GError          // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(method)))
	_arg2 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.soup_session_request_http_uri(_arg0, _arg1, _arg2, &_cerr)

	var _requestHTTP *RequestHTTP // out
	var _goerr error              // out

	_requestHTTP = wrapRequestHTTP(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _requestHTTP, _goerr
}

// RequestURI creates a Request for retrieving uri.
func (session *Session) RequestURI(uri *URI) (*Request, error) {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupURI     // out
	var _cret *C.SoupRequest // in
	var _cerr *C.GError      // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = (*C.SoupURI)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.soup_session_request_uri(_arg0, _arg1, &_cerr)

	var _request *Request // out
	var _goerr error      // out

	_request = wrapRequest(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _request, _goerr
}

// RequeueMessage: this causes msg to be placed back on the queue to be
// attempted again.
func (session *Session) RequeueMessage(msg *Message) {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	C.soup_session_requeue_message(_arg0, _arg1)
}

// Send: synchronously sends msg and waits for the beginning of a response. On
// success, a Stream will be returned which you can use to read the response
// body. ("Success" here means only that an HTTP response was received and
// understood; it does not necessarily mean that a 2xx class status code was
// received.)
//
// If non-NULL, cancellable can be used to cancel the request;
// soup_session_send() will return a G_IO_ERROR_CANCELLED error. Note that with
// requests that have side effects (eg, <literal>POST</literal>,
// <literal>PUT</literal>, <literal>DELETE</literal>) it is possible that you
// might cancel the request after the server acts on it, but before it returns a
// response, leaving the remote resource in an unknown state.
//
// If msg is requeued due to a redirect or authentication, the initial
// (3xx/401/407) response body will be suppressed, and soup_session_send() will
// only return once a final response has been received.
//
// Contrast this method with soup_session_send_message(), which also
// synchronously sends a Message, but doesn't return until the response has been
// completely read.
//
// (Note that this method cannot be called on the deprecated SessionAsync
// subclass.)
func (session *Session) Send(msg *Message, cancellable *gio.Cancellable) (*gio.InputStream, error) {
	var _arg0 *C.SoupSession  // out
	var _arg1 *C.SoupMessage  // out
	var _arg2 *C.GCancellable // out
	var _cret *C.GInputStream // in
	var _cerr *C.GError       // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.soup_session_send(_arg0, _arg1, _arg2, &_cerr)

	var _inputStream *gio.InputStream // out
	var _goerr error                  // out

	{
		obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
		_inputStream = &gio.InputStream{
			Object: obj,
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _inputStream, _goerr
}

// SendAsync: asynchronously sends msg and waits for the beginning of a
// response. When callback is called, then either msg has been sent, and its
// response headers received, or else an error has occurred. Call
// soup_session_send_finish() to get a Stream for reading the response body.
//
// See soup_session_send() for more details on the general semantics.
//
// Contrast this method with soup_session_queue_message(), which also
// asynchronously sends a Message, but doesn't invoke its callback until the
// response has been completely read.
//
// (Note that this method cannot be called on the deprecated SessionSync
// subclass, and can only be called on SessionAsync if you have set the
// Session:use-thread-context property.)
func (session *Session) SendAsync(msg *Message, cancellable *gio.Cancellable, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SoupSession        // out
	var _arg1 *C.SoupMessage        // out
	var _arg2 *C.GCancellable       // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg4 = C.gpointer(gbox.AssignOnce(callback))

	C.soup_session_send_async(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// SendFinish gets the response to a soup_session_send_async() call and (if
// successful), returns a Stream that can be used to read the response body.
func (session *Session) SendFinish(result gio.AsyncResulter) (*gio.InputStream, error) {
	var _arg0 *C.SoupSession  // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GInputStream // in
	var _cerr *C.GError       // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((result).(gextras.Nativer).Native()))

	_cret = C.soup_session_send_finish(_arg0, _arg1, &_cerr)

	var _inputStream *gio.InputStream // out
	var _goerr error                  // out

	{
		obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
		_inputStream = &gio.InputStream{
			Object: obj,
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _inputStream, _goerr
}

// SendMessage: synchronously send msg. This call will not return until the
// transfer is finished successfully or there is an unrecoverable error.
//
// Unlike with soup_session_queue_message(), msg is not freed upon return.
//
// (Note that if you call this method on a SessionAsync, it will still use
// asynchronous I/O internally, running the glib main loop to process the
// message, which may also cause other events to be processed.)
//
// Contrast this method with soup_session_send(), which also synchronously sends
// a message, but returns before reading the response body, and allows you to
// read the response via a Stream.
func (session *Session) SendMessage(msg *Message) uint {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out
	var _cret C.guint        // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	_cret = C.soup_session_send_message(_arg0, _arg1)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// StealConnection: "Steals" the HTTP connection associated with msg from
// session. This happens immediately, regardless of the current state of the
// connection, and msg's callback will not be called. You can steal the
// connection from a Message signal handler if you need to wait for part or all
// of the response to be received first.
//
// Calling this function may cause msg to be freed if you are not holding any
// other reference to it.
func (session *Session) StealConnection(msg *Message) *gio.IOStream {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out
	var _cret *C.GIOStream   // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	_cret = C.soup_session_steal_connection(_arg0, _arg1)

	var _ioStream *gio.IOStream // out

	{
		obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
		_ioStream = &gio.IOStream{
			Object: obj,
		}
	}

	return _ioStream
}

// UnpauseMessage resumes HTTP I/O on msg. Use this to resume after calling
// soup_session_pause_message().
//
// If msg is being sent via blocking I/O, this will resume reading or writing
// immediately. If msg is using non-blocking I/O, then reading or writing won't
// resume until you return to the main loop.
//
// This may only be called for asynchronous messages (those sent on a
// SessionAsync or using soup_session_queue_message()).
func (session *Session) UnpauseMessage(msg *Message) {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	C.soup_session_unpause_message(_arg0, _arg1)
}

// WebsocketConnectAsync: asynchronously creates a WebsocketConnection to
// communicate with a remote server.
//
// All necessary WebSocket-related headers will be added to msg, and it will
// then be sent and asynchronously processed normally (including handling of
// redirection and HTTP authentication).
//
// If the server returns "101 Switching Protocols", then msg's status code and
// response headers will be updated, and then the WebSocket handshake will be
// completed. On success, soup_session_websocket_connect_finish() will return a
// new WebsocketConnection. On failure it will return a #GError.
//
// If the server returns a status other than "101 Switching Protocols", then msg
// will contain the complete response headers and body from the server's
// response, and soup_session_websocket_connect_finish() will return
// SOUP_WEBSOCKET_ERROR_NOT_WEBSOCKET.
func (session *Session) WebsocketConnectAsync(msg *Message, origin string, protocols []string, cancellable *gio.Cancellable, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out
	var _arg2 *C.char        // out
	var _arg3 **C.char
	var _arg4 *C.GCancellable       // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(origin)))
	{
		_arg3 = (**C.char)(C.malloc(C.ulong(len(protocols)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
		{
			out := unsafe.Slice(_arg3, len(protocols)+1)
			var zero *C.char
			out[len(protocols)] = zero
			for i := range protocols {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(protocols[i])))
			}
		}
	}
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg6 = C.gpointer(gbox.AssignOnce(callback))

	C.soup_session_websocket_connect_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// WebsocketConnectFinish gets the WebsocketConnection response to a
// soup_session_websocket_connect_async() call and (if successful), returns a
// WebsocketConnection that can be used to communicate with the server.
func (session *Session) WebsocketConnectFinish(result gio.AsyncResulter) (*WebsocketConnection, error) {
	var _arg0 *C.SoupSession             // out
	var _arg1 *C.GAsyncResult            // out
	var _cret *C.SoupWebsocketConnection // in
	var _cerr *C.GError                  // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((result).(gextras.Nativer).Native()))

	_cret = C.soup_session_websocket_connect_finish(_arg0, _arg1, &_cerr)

	var _websocketConnection *WebsocketConnection // out
	var _goerr error                              // out

	_websocketConnection = wrapWebsocketConnection(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _websocketConnection, _goerr
}

// WouldRedirect checks if msg contains a response that would cause session to
// redirect it to a new URL (ignoring msg's SOUP_MESSAGE_NO_REDIRECT flag, and
// the number of times it has already been redirected).
func (session *Session) WouldRedirect(msg *Message) bool {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out
	var _cret C.gboolean     // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(session.Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(msg.Native()))

	_cret = C.soup_session_would_redirect(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
