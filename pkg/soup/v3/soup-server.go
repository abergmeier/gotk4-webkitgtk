// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <libsoup/soup.h>
// extern void callbackDelete(gpointer);
// extern void _gotk4_soup3_Server_ConnectRequestStarted(gpointer, SoupServerMessage*, guintptr);
// extern void _gotk4_soup3_Server_ConnectRequestRead(gpointer, SoupServerMessage*, guintptr);
// extern void _gotk4_soup3_Server_ConnectRequestFinished(gpointer, SoupServerMessage*, guintptr);
// extern void _gotk4_soup3_Server_ConnectRequestAborted(gpointer, SoupServerMessage*, guintptr);
// extern void _gotk4_soup3_ServerWebsocketCallback(SoupServer*, SoupServerMessage*, char*, SoupWebsocketConnection*, gpointer);
// extern void _gotk4_soup3_ServerClass_request_started(SoupServer*, SoupServerMessage*);
// extern void _gotk4_soup3_ServerClass_request_read(SoupServer*, SoupServerMessage*);
// extern void _gotk4_soup3_ServerClass_request_finished(SoupServer*, SoupServerMessage*);
// extern void _gotk4_soup3_ServerClass_request_aborted(SoupServer*, SoupServerMessage*);
// extern void _gotk4_soup3_ServerCallback(SoupServer*, SoupServerMessage*, char*, GHashTable*, gpointer);
// void _gotk4_soup3_Server_virtual_request_aborted(void* fnptr, SoupServer* arg0, SoupServerMessage* arg1) {
//   ((void (*)(SoupServer*, SoupServerMessage*))(fnptr))(arg0, arg1);
// };
// void _gotk4_soup3_Server_virtual_request_finished(void* fnptr, SoupServer* arg0, SoupServerMessage* arg1) {
//   ((void (*)(SoupServer*, SoupServerMessage*))(fnptr))(arg0, arg1);
// };
// void _gotk4_soup3_Server_virtual_request_read(void* fnptr, SoupServer* arg0, SoupServerMessage* arg1) {
//   ((void (*)(SoupServer*, SoupServerMessage*))(fnptr))(arg0, arg1);
// };
// void _gotk4_soup3_Server_virtual_request_started(void* fnptr, SoupServer* arg0, SoupServerMessage* arg1) {
//   ((void (*)(SoupServer*, SoupServerMessage*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeServerListenOptions = coreglib.Type(C.soup_server_listen_options_get_type())
	GTypeServer              = coreglib.Type(C.soup_server_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeServerListenOptions, F: marshalServerListenOptions},
		coreglib.TypeMarshaler{T: GTypeServer, F: marshalServer},
	})
}

// ServerListenOptions options to pass to soup_server_listen(), etc.
//
// SOUP_SERVER_LISTEN_IPV4_ONLY and SOUP_SERVER_LISTEN_IPV6_ONLY only make
// sense with soup_server_listen_all() and soup_server_listen_local(), not plain
// soup_server_listen() (which simply listens on whatever kind of socket you
// give it). And you cannot specify both of them in a single call.
type ServerListenOptions C.guint

const (
	// ServerListenHTTPS: listen for https connections rather than plain http.
	ServerListenHTTPS ServerListenOptions = 0b1
	// ServerListenIPv4Only: only listen on IPv4 interfaces.
	ServerListenIPv4Only ServerListenOptions = 0b10
	// ServerListenIPv6Only: only listen on IPv6 interfaces.
	ServerListenIPv6Only ServerListenOptions = 0b100
)

func marshalServerListenOptions(p uintptr) (interface{}, error) {
	return ServerListenOptions(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ServerListenOptions.
func (s ServerListenOptions) String() string {
	if s == 0 {
		return "ServerListenOptions(0)"
	}

	var builder strings.Builder
	builder.Grow(59)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case ServerListenHTTPS:
			builder.WriteString("HTTPS|")
		case ServerListenIPv4Only:
			builder.WriteString("IPv4Only|")
		case ServerListenIPv6Only:
			builder.WriteString("IPv6Only|")
		default:
			builder.WriteString(fmt.Sprintf("ServerListenOptions(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s ServerListenOptions) Has(other ServerListenOptions) bool {
	return (s & other) == other
}

// ServerCallback: callback used to handle requests to a Server.
//
// path and query contain the likewise-named components of the Request-URI,
// subject to certain assumptions. By default, Server decodes all
// percent-encoding in the URI path, such that "/foo%<!-- -->2Fbar" is
// treated the same as "/foo/bar". If your server is serving resources in some
// non-POSIX-filesystem namespace, you may want to distinguish those as two
// distinct paths. In that case, you can set the SoupServer:raw-paths property
// when creating the Server, and it will leave those characters undecoded.
//
// query contains the query component of the Request-URI parsed according to the
// rules for HTML form handling. Although this is the only commonly-used query
// string format in HTTP, there is nothing that actually requires that HTTP URIs
// use that format; if your server needs to use some other format, you can just
// ignore query, and call soup_message_get_uri() and parse the URI's query field
// yourself.
//
// See soup_server_add_handler() and soup_server_add_early_handler() for details
// of what handlers can/should do.
type ServerCallback func(server *Server, msg *ServerMessage, path string, query map[string]string)

// ServerWebsocketCallback: callback used to handle WebSocket requests to a
// Server. The callback will be invoked after sending the handshake response
// back to the client (and is only invoked if the handshake was successful).
//
// path contains the path of the Request-URI, subject to the same rules as
// ServerCallback (qv).
type ServerWebsocketCallback func(server *Server, msg *ServerMessage, path string, connection *WebsocketConnection)

// ServerOverrides contains methods that are overridable.
type ServerOverrides struct {
	// The function takes the following parameters:
	//
	RequestAborted func(msg *ServerMessage)
	// The function takes the following parameters:
	//
	RequestFinished func(msg *ServerMessage)
	// The function takes the following parameters:
	//
	RequestRead func(msg *ServerMessage)
	// The function takes the following parameters:
	//
	RequestStarted func(msg *ServerMessage)
}

func defaultServerOverrides(v *Server) ServerOverrides {
	return ServerOverrides{
		RequestAborted:  v.requestAborted,
		RequestFinished: v.requestFinished,
		RequestRead:     v.requestRead,
		RequestStarted:  v.requestStarted,
	}
}

// Server class implementing an HTTP server.
type Server struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Server)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Server, *ServerClass, ServerOverrides](
		GTypeServer,
		initServerClass,
		wrapServer,
		defaultServerOverrides,
	)
}

func initServerClass(gclass unsafe.Pointer, overrides ServerOverrides, classInitFunc func(*ServerClass)) {
	pclass := (*C.SoupServerClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeServer))))

	if overrides.RequestAborted != nil {
		pclass.request_aborted = (*[0]byte)(C._gotk4_soup3_ServerClass_request_aborted)
	}

	if overrides.RequestFinished != nil {
		pclass.request_finished = (*[0]byte)(C._gotk4_soup3_ServerClass_request_finished)
	}

	if overrides.RequestRead != nil {
		pclass.request_read = (*[0]byte)(C._gotk4_soup3_ServerClass_request_read)
	}

	if overrides.RequestStarted != nil {
		pclass.request_started = (*[0]byte)(C._gotk4_soup3_ServerClass_request_started)
	}

	if classInitFunc != nil {
		class := (*ServerClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapServer(obj *coreglib.Object) *Server {
	return &Server{
		Object: obj,
	}
}

func marshalServer(p uintptr) (interface{}, error) {
	return wrapServer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectRequestAborted is emitted when processing has failed for a message;
// this could mean either that it could not be read (if Server::request_read has
// not been emitted for it yet), or that the response could not be written back
// (if Server::request_read has been emitted but Server::request_finished has
// not been).
//
// message is in an undefined state when this signal is emitted; the signal
// exists primarily to allow the server to free any state that it may have
// allocated in Server::request_started.
func (server *Server) ConnectRequestAborted(f func(message *ServerMessage)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(server, "request-aborted", false, unsafe.Pointer(C._gotk4_soup3_Server_ConnectRequestAborted), f)
}

// ConnectRequestFinished is emitted when the server has finished writing a
// response to a request.
func (server *Server) ConnectRequestFinished(f func(message *ServerMessage)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(server, "request-finished", false, unsafe.Pointer(C._gotk4_soup3_Server_ConnectRequestFinished), f)
}

// ConnectRequestRead is emitted when the server has successfully read a
// request. message will have all of its request-side information filled in,
// and if the message was authenticated, client will have information about
// that. This signal is emitted before any (non-early) handlers are called for
// the message, and if it sets the message's #status_code, then normal handler
// processing will be skipped.
func (server *Server) ConnectRequestRead(f func(message *ServerMessage)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(server, "request-read", false, unsafe.Pointer(C._gotk4_soup3_Server_ConnectRequestRead), f)
}

// ConnectRequestStarted is emitted when the server has started reading a new
// request. message will be completely blank; not even the Request-Line will
// have been read yet. About the only thing you can usefully do with it is
// connect to its signals.
//
// If the request is read successfully, this will eventually be followed by
// a Server::request_read signal. If a response is then sent, the request
// processing will end with a Server::request_finished signal. If a network
// error occurs, the processing will instead end with Server::request_aborted.
func (server *Server) ConnectRequestStarted(f func(message *ServerMessage)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(server, "request-started", false, unsafe.Pointer(C._gotk4_soup3_Server_ConnectRequestStarted), f)
}

// AcceptIostream: add a new client stream to the server.
//
// The function takes the following parameters:
//
//   - stream: OStream.
//   - localAddr (optional): local Address associated with the stream.
//   - remoteAddr (optional): remote Address associated with the stream.
//
func (server *Server) AcceptIostream(stream gio.IOStreamer, localAddr, remoteAddr gio.SocketAddresser) error {
	var _arg0 *C.SoupServer     // out
	var _arg1 *C.GIOStream      // out
	var _arg2 *C.GSocketAddress // out
	var _arg3 *C.GSocketAddress // out
	var _cerr *C.GError         // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.GIOStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	if localAddr != nil {
		_arg2 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.InternObject(localAddr).Native()))
	}
	if remoteAddr != nil {
		_arg3 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.InternObject(remoteAddr).Native()))
	}

	C.soup_server_accept_iostream(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(server)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(localAddr)
	runtime.KeepAlive(remoteAddr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// AddAuthDomain adds an authentication domain to server. Each auth domain will
// have the chance to require authentication for each request that comes in;
// normally auth domains will require authentication for requests on
// certain paths that they have been set up to watch, or that meet other
// criteria set by the caller. If an auth domain determines that a request
// requires authentication (and the request doesn't contain authentication),
// server will automatically reject the request with an appropriate status (401
// Unauthorized or 407 Proxy Authentication Required). If the request used the
// SoupServer:100-continue Expectation, server will reject it before the request
// body is sent.
//
// The function takes the following parameters:
//
//   - authDomain: AuthDomain.
//
func (server *Server) AddAuthDomain(authDomain AuthDomainer) {
	var _arg0 *C.SoupServer     // out
	var _arg1 *C.SoupAuthDomain // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.SoupAuthDomain)(unsafe.Pointer(coreglib.InternObject(authDomain).Native()))

	C.soup_server_add_auth_domain(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(authDomain)
}

// AddEarlyHandler adds an "early" handler to server for requests prefixed by
// path. Note that "normal" and "early" handlers are matched up together, so
// if you add a normal handler for "/foo" and an early handler for "/foo/bar",
// then a request to "/foo/bar" (or any path below it) will run only the early
// handler. (But if you add both handlers at the same path, then both will get
// run.)
//
// For requests under path (that have not already been assigned a status code by
// a AuthDomain or a signal handler), callback will be invoked after receiving
// the request headers, but before receiving the request body; the message's
// method and request-headers properties will be set.
//
// Early handlers are generally used for processing requests with request bodies
// in a streaming fashion. If you determine that the request will contain a
// message body, normally you would call soup_message_body_set_accumulate() on
// the message's request-body to turn off request-body accumulation, and connect
// to the message's ServerMessage::got-chunk signal to process each chunk as it
// comes in.
//
// To complete the message processing after the full message body has been read,
// you can either also connect to ServerMessage::got-body, or else you can
// register a non-early handler for path as well. As long as you have not set
// the status-code by the time ServerMessage::got-body is emitted, the non-early
// handler will be run as well.
//
// The function takes the following parameters:
//
//   - path (optional): toplevel path for the handler.
//   - callback to invoke for requests under path.
//
func (server *Server) AddEarlyHandler(path string, callback ServerCallback) {
	var _arg0 *C.SoupServer        // out
	var _arg1 *C.char              // out
	var _arg2 C.SoupServerCallback // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	if path != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*[0]byte)(C._gotk4_soup3_ServerCallback)
	_arg3 = C.gpointer(gbox.Assign(callback))
	_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.soup_server_add_early_handler(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(server)
	runtime.KeepAlive(path)
	runtime.KeepAlive(callback)
}

// AddHandler adds a handler to server for requests prefixed by path. If path
// is NULL or "/", then this will be the default handler for all requests that
// don't have a more specific handler. (Note though that if you want to handle
// requests to the special "*" URI, you must explicitly register a handler for
// "*"; the default handler will not be used for that case.)
//
// For requests under path (that have not already been assigned a status code by
// a AuthDomain, an early server handler, or a signal handler), callback will be
// invoked after receiving the request body; the ServerMessage<!-- -->'s method,
// request-headers, and request-body properties will be set.
//
// After determining what to do with the request, the callback must at a minimum
// call soup_server_message_set_status() on the message to set the response
// status code. Additionally, it may set response headers and/or fill in the
// response body.
//
// If the callback cannot fully fill in the response before returning (eg,
// if it needs to wait for information from a database, or another network
// server), it should call soup_server_pause_message() to tell server
// to not send the response right away. When the response is ready, call
// soup_server_unpause_message() to cause it to be sent.
//
// To send the response body a bit at a time using "chunked" encoding,
// first call soup_message_headers_set_encoding() to set SOUP_ENCODING_CHUNKED
// on the response-headers. Then call soup_message_body_append() (or
// soup_message_body_append_bytes)) to append each chunk as it becomes ready,
// and soup_server_unpause_message() to make sure it's running. (The server will
// automatically pause the message if it is using chunked encoding but no more
// chunks are available.) When you are done, call soup_message_body_complete()
// to indicate that no more chunks are coming.
//
// The function takes the following parameters:
//
//   - path (optional): toplevel path for the handler.
//   - callback to invoke for requests under path.
//
func (server *Server) AddHandler(path string, callback ServerCallback) {
	var _arg0 *C.SoupServer        // out
	var _arg1 *C.char              // out
	var _arg2 C.SoupServerCallback // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	if path != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*[0]byte)(C._gotk4_soup3_ServerCallback)
	_arg3 = C.gpointer(gbox.Assign(callback))
	_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.soup_server_add_handler(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(server)
	runtime.KeepAlive(path)
	runtime.KeepAlive(callback)
}

// AddWebsocketExtension: add support for a WebSocket extension of the
// given extension_type. When a WebSocket client requests an extension of
// extension_type, a new WebsocketExtension of type extension_type will be
// created to handle the request.
//
// Note that WebsocketExtensionDeflate is supported by default, use
// soup_server_remove_websocket_extension() if you want to disable it.
//
// The function takes the following parameters:
//
//   - extensionType: #GType.
//
func (server *Server) AddWebsocketExtension(extensionType coreglib.Type) {
	var _arg0 *C.SoupServer // out
	var _arg1 C.GType       // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = C.GType(extensionType)

	C.soup_server_add_websocket_extension(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(extensionType)
}

// AddWebsocketHandler adds a WebSocket handler to server for requests prefixed
// by path. (If path is NULL or "/", then this will be the default handler for
// all requests that don't have a more specific handler.)
//
// When a path has a WebSocket handler registered, server will check incoming
// requests for WebSocket handshakes after all other handlers have run (unless
// some earlier handler has already set a status code on the message), and
// update the request's status, response headers, and response body accordingly.
//
// If origin is non-NULL, then only requests containing a matching "Origin"
// header will be accepted. If protocols is non-NULL, then only requests
// containing a compatible "Sec-WebSocket-Protocols" header will be accepted.
// More complicated requirements can be handled by adding a normal handler to
// path, and having it perform whatever checks are needed and setting a failure
// status code if the handshake should be rejected.
//
// The function takes the following parameters:
//
//   - path (optional): toplevel path for the handler.
//   - origin (optional) of the connection.
//   - protocols (optional): protocols supported by this handler.
//   - callback to invoke for successful WebSocket requests under path.
//
func (server *Server) AddWebsocketHandler(path, origin string, protocols []string, callback ServerWebsocketCallback) {
	var _arg0 *C.SoupServer                 // out
	var _arg1 *C.char                       // out
	var _arg2 *C.char                       // out
	var _arg3 **C.char                      // out
	var _arg4 C.SoupServerWebsocketCallback // out
	var _arg5 C.gpointer
	var _arg6 C.GDestroyNotify

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	if path != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if origin != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(origin)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	{
		_arg3 = (**C.char)(C.calloc(C.size_t((len(protocols) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg3))
		{
			out := unsafe.Slice(_arg3, len(protocols)+1)
			var zero *C.char
			out[len(protocols)] = zero
			for i := range protocols {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(protocols[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	_arg4 = (*[0]byte)(C._gotk4_soup3_ServerWebsocketCallback)
	_arg5 = C.gpointer(gbox.Assign(callback))
	_arg6 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.soup_server_add_websocket_handler(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(server)
	runtime.KeepAlive(path)
	runtime.KeepAlive(origin)
	runtime.KeepAlive(protocols)
	runtime.KeepAlive(callback)
}

// Disconnect closes and frees server's listening sockets.
//
// Note that if there are currently requests in progress on server, that they
// will continue to be processed if server's Context is still running.
//
// You can call soup_server_listen(), etc, after calling this function if you
// want to start listening again.
func (server *Server) Disconnect() {
	var _arg0 *C.SoupServer // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	C.soup_server_disconnect(_arg0)
	runtime.KeepAlive(server)
}

// Listeners gets server's list of listening sockets.
//
// You should treat these sockets as read-only; writing to or modifiying any of
// these sockets may cause server to malfunction.
//
// The function returns the following values:
//
//   - sList: a list of listening sockets.
//
func (server *Server) Listeners() []*gio.Socket {
	var _arg0 *C.SoupServer // out
	var _cret *C.GSList     // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	_cret = C.soup_server_get_listeners(_arg0)
	runtime.KeepAlive(server)

	var _sList []*gio.Socket // out

	_sList = make([]*gio.Socket, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GSocket)(v)
		var dst *gio.Socket // out
		{
			obj := coreglib.Take(unsafe.Pointer(src))
			dst = &gio.Socket{
				Object: obj,
				DatagramBased: gio.DatagramBased{
					Object: obj,
				},
				Initable: gio.Initable{
					Object: obj,
				},
			}
		}
		_sList = append(_sList, dst)
	})

	return _sList
}

// TLSAuthMode gets the server SSL/TLS client authentication mode.
//
// The function returns the following values:
//
//   - tlsAuthenticationMode: AuthenticationMode.
//
func (server *Server) TLSAuthMode() gio.TLSAuthenticationMode {
	var _arg0 *C.SoupServer            // out
	var _cret C.GTlsAuthenticationMode // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	_cret = C.soup_server_get_tls_auth_mode(_arg0)
	runtime.KeepAlive(server)

	var _tlsAuthenticationMode gio.TLSAuthenticationMode // out

	_tlsAuthenticationMode = gio.TLSAuthenticationMode(_cret)

	return _tlsAuthenticationMode
}

// TLSCertificate gets the server SSL/TLS certificate.
//
// The function returns the following values:
//
//   - tlsCertificate (optional) or NULL.
//
func (server *Server) TLSCertificate() gio.TLSCertificater {
	var _arg0 *C.SoupServer      // out
	var _cret *C.GTlsCertificate // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	_cret = C.soup_server_get_tls_certificate(_arg0)
	runtime.KeepAlive(server)

	var _tlsCertificate gio.TLSCertificater // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.TLSCertificater)
				return ok
			})
			rv, ok := casted.(gio.TLSCertificater)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSCertificater")
			}
			_tlsCertificate = rv
		}
	}

	return _tlsCertificate
}

// TLSDatabase gets the server SSL/TLS database.
//
// The function returns the following values:
//
//   - tlsDatabase (optional) or NULL.
//
func (server *Server) TLSDatabase() gio.TLSDatabaser {
	var _arg0 *C.SoupServer   // out
	var _cret *C.GTlsDatabase // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	_cret = C.soup_server_get_tls_database(_arg0)
	runtime.KeepAlive(server)

	var _tlsDatabase gio.TLSDatabaser // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.TLSDatabaser)
				return ok
			})
			rv, ok := casted.(gio.TLSDatabaser)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSDatabaser")
			}
			_tlsDatabase = rv
		}
	}

	return _tlsDatabase
}

// URIs gets a list of URIs corresponding to the interfaces server is listening
// on. These will contain IP addresses, not hostnames, and will also indicate
// whether the given listener is http or https.
//
// Note that if you used soup_server_listen_all(), the returned URIs will use
// the addresses <literal>0.0.0.0</literal> and <literal>::</literal>, rather
// than actually returning separate URIs for each interface on the system.
//
// The function returns the following values:
//
//   - sList: list of #GUris, which you must free when you are done with it.
//
func (server *Server) URIs() []*glib.URI {
	var _arg0 *C.SoupServer // out
	var _cret *C.GSList     // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	_cret = C.soup_server_get_uris(_arg0)
	runtime.KeepAlive(server)

	var _sList []*glib.URI // out

	_sList = make([]*glib.URI, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GUri)(v)
		var dst *glib.URI // out
		dst = (*glib.URI)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
		_sList = append(_sList, dst)
	})

	return _sList
}

// IsHTTPS checks whether server is capable of https.
//
// In order for a server to run https, you must call
// soup_server_set_ssl_cert_file(), or set the Server:tls-certificate property,
// to provide it with a certificate to use.
//
// If you are using the deprecated single-listener APIs, then a return value
// of TRUE indicates that the Server serves https exclusively. If you are using
// soup_server_listen(), etc, then a TRUE return value merely indicates that
// the server is <emphasis>able</emphasis> to do https, regardless of whether
// it actually currently is or not. Use soup_server_get_uris() to see if it
// currently has any https listeners.
//
// The function returns the following values:
//
//   - ok: TRUE if server is configured to serve https.
//
func (server *Server) IsHTTPS() bool {
	var _arg0 *C.SoupServer // out
	var _cret C.gboolean    // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))

	_cret = C.soup_server_is_https(_arg0)
	runtime.KeepAlive(server)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Listen: this attempts to set up server to listen for connections on address.
//
// If options includes SOUP_SERVER_LISTEN_HTTPS, and server has been configured
// for TLS, then server will listen for https connections on this port.
// Otherwise it will listen for plain http.
//
// You may call this method (along with the other "listen" methods) any number
// of times on a server, if you want to listen on multiple ports, or set up both
// http and https service.
//
// After calling this method, server will begin accepting and processing
// connections as soon as the appropriate Context is run.
//
// Note that Server never makes use of dual IPv4/IPv6 sockets; if address is an
// IPv6 address, it will only accept IPv6 connections. You must configure IPv4
// listening separately.
//
// The function takes the following parameters:
//
//   - address of the interface to listen on.
//   - options: listening options for this server.
//
func (server *Server) Listen(address gio.SocketAddresser, options ServerListenOptions) error {
	var _arg0 *C.SoupServer             // out
	var _arg1 *C.GSocketAddress         // out
	var _arg2 C.SoupServerListenOptions // out
	var _cerr *C.GError                 // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))
	_arg2 = C.SoupServerListenOptions(options)

	C.soup_server_listen(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(server)
	runtime.KeepAlive(address)
	runtime.KeepAlive(options)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ListenAll: this attempts to set up server to listen for connections
// on all interfaces on the system. (That is, it listens on the addresses
// <literal>0.0.0.0</literal> and/or <literal>::</literal>, depending on whether
// options includes SOUP_SERVER_LISTEN_IPV4_ONLY, SOUP_SERVER_LISTEN_IPV6_ONLY,
// or neither.) If port is specified, server will listen on that port. If it is
// 0, server will find an unused port to listen on. (In that case, you can use
// soup_server_get_uris() to find out what port it ended up choosing.)
//
// See soup_server_listen() for more details.
//
// The function takes the following parameters:
//
//   - port to listen on, or 0.
//   - options: listening options for this server.
//
func (server *Server) ListenAll(port uint, options ServerListenOptions) error {
	var _arg0 *C.SoupServer             // out
	var _arg1 C.guint                   // out
	var _arg2 C.SoupServerListenOptions // out
	var _cerr *C.GError                 // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = C.guint(port)
	_arg2 = C.SoupServerListenOptions(options)

	C.soup_server_listen_all(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(server)
	runtime.KeepAlive(port)
	runtime.KeepAlive(options)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ListenLocal: this attempts to set up server to listen for connections
// on "localhost" (that is, <literal>127.0.0.1</literal> and/or
// <literal>::1</literal>, depending on whether options includes
// SOUP_SERVER_LISTEN_IPV4_ONLY, SOUP_SERVER_LISTEN_IPV6_ONLY, or neither).
// If port is specified, server will listen on that port. If it is 0,
// server will find an unused port to listen on. (In that case, you can use
// soup_server_get_uris() to find out what port it ended up choosing.)
//
// See soup_server_listen() for more details.
//
// The function takes the following parameters:
//
//   - port to listen on, or 0.
//   - options: listening options for this server.
//
func (server *Server) ListenLocal(port uint, options ServerListenOptions) error {
	var _arg0 *C.SoupServer             // out
	var _arg1 C.guint                   // out
	var _arg2 C.SoupServerListenOptions // out
	var _cerr *C.GError                 // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = C.guint(port)
	_arg2 = C.SoupServerListenOptions(options)

	C.soup_server_listen_local(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(server)
	runtime.KeepAlive(port)
	runtime.KeepAlive(options)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ListenSocket: this attempts to set up server to listen for connections on
// socket.
//
// See soup_server_listen() for more details.
//
// The function takes the following parameters:
//
//   - socket: listening #GSocket.
//   - options: listening options for this server.
//
func (server *Server) ListenSocket(socket *gio.Socket, options ServerListenOptions) error {
	var _arg0 *C.SoupServer             // out
	var _arg1 *C.GSocket                // out
	var _arg2 C.SoupServerListenOptions // out
	var _cerr *C.GError                 // in

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	_arg2 = C.SoupServerListenOptions(options)

	C.soup_server_listen_socket(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(server)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(options)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// PauseMessage pauses I/O on msg. This can be used when you need to return
// from the server handler without having the full response ready yet. Use
// soup_server_unpause_message() to resume I/O.
//
// This must only be called on a ServerMessage which was created by the Server
// and are currently doing I/O, such as those passed into a ServerCallback or
// emitted in a Server::request-read signal.
//
// The function takes the following parameters:
//
//   - msg associated with server.
//
func (server *Server) PauseMessage(msg *ServerMessage) {
	var _arg0 *C.SoupServer        // out
	var _arg1 *C.SoupServerMessage // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_server_pause_message(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(msg)
}

// RemoveAuthDomain removes auth_domain from server.
//
// The function takes the following parameters:
//
//   - authDomain: AuthDomain.
//
func (server *Server) RemoveAuthDomain(authDomain AuthDomainer) {
	var _arg0 *C.SoupServer     // out
	var _arg1 *C.SoupAuthDomain // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.SoupAuthDomain)(unsafe.Pointer(coreglib.InternObject(authDomain).Native()))

	C.soup_server_remove_auth_domain(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(authDomain)
}

// RemoveHandler removes all handlers (early and normal) registered at path.
//
// The function takes the following parameters:
//
//   - path: toplevel path for the handler.
//
func (server *Server) RemoveHandler(path string) {
	var _arg0 *C.SoupServer // out
	var _arg1 *C.char       // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	C.soup_server_remove_handler(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(path)
}

// RemoveWebsocketExtension removes support for WebSocket extension of type
// extension_type (or any subclass of extension_type) from server.
//
// The function takes the following parameters:
//
//   - extensionType: #GType.
//
func (server *Server) RemoveWebsocketExtension(extensionType coreglib.Type) {
	var _arg0 *C.SoupServer // out
	var _arg1 C.GType       // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = C.GType(extensionType)

	C.soup_server_remove_websocket_extension(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(extensionType)
}

// SetTLSAuthMode sets server's AuthenticationMode to use for SSL/TLS client
// authentication.
//
// The function takes the following parameters:
//
//   - mode: AuthenticationMode.
//
func (server *Server) SetTLSAuthMode(mode gio.TLSAuthenticationMode) {
	var _arg0 *C.SoupServer            // out
	var _arg1 C.GTlsAuthenticationMode // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = C.GTlsAuthenticationMode(mode)

	C.soup_server_set_tls_auth_mode(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(mode)
}

// SetTLSCertificate sets server up to do https, using the given SSL/TLS
// certificate.
//
// The function takes the following parameters:
//
//   - certificate: Certificate.
//
func (server *Server) SetTLSCertificate(certificate gio.TLSCertificater) {
	var _arg0 *C.SoupServer      // out
	var _arg1 *C.GTlsCertificate // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(coreglib.InternObject(certificate).Native()))

	C.soup_server_set_tls_certificate(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(certificate)
}

// SetTLSDatabase sets server's Database to use for validating SSL/TLS client
// certificates.
//
// The function takes the following parameters:
//
//   - tlsDatabase: Database.
//
func (server *Server) SetTLSDatabase(tlsDatabase gio.TLSDatabaser) {
	var _arg0 *C.SoupServer   // out
	var _arg1 *C.GTlsDatabase // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(tlsDatabase).Native()))

	C.soup_server_set_tls_database(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(tlsDatabase)
}

// UnpauseMessage resumes I/O on msg. Use this to resume after calling
// soup_server_pause_message(), or after adding a new chunk to a chunked
// response.
//
// I/O won't actually resume until you return to the main loop.
//
// This must only be called on a ServerMessage which was created by the Server
// and are currently doing I/O, such as those passed into a ServerCallback or
// emitted in a Server::request-read signal.
//
// The function takes the following parameters:
//
//   - msg associated with server.
//
func (server *Server) UnpauseMessage(msg *ServerMessage) {
	var _arg0 *C.SoupServer        // out
	var _arg1 *C.SoupServerMessage // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C.soup_server_unpause_message(_arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(msg)
}

// The function takes the following parameters:
//
func (server *Server) requestAborted(msg *ServerMessage) {
	gclass := (*C.SoupServerClass)(coreglib.PeekParentClass(server))
	fnarg := gclass.request_aborted

	var _arg0 *C.SoupServer        // out
	var _arg1 *C.SoupServerMessage // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C._gotk4_soup3_Server_virtual_request_aborted(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(msg)
}

// The function takes the following parameters:
//
func (server *Server) requestFinished(msg *ServerMessage) {
	gclass := (*C.SoupServerClass)(coreglib.PeekParentClass(server))
	fnarg := gclass.request_finished

	var _arg0 *C.SoupServer        // out
	var _arg1 *C.SoupServerMessage // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C._gotk4_soup3_Server_virtual_request_finished(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(msg)
}

// The function takes the following parameters:
//
func (server *Server) requestRead(msg *ServerMessage) {
	gclass := (*C.SoupServerClass)(coreglib.PeekParentClass(server))
	fnarg := gclass.request_read

	var _arg0 *C.SoupServer        // out
	var _arg1 *C.SoupServerMessage // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C._gotk4_soup3_Server_virtual_request_read(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(msg)
}

// The function takes the following parameters:
//
func (server *Server) requestStarted(msg *ServerMessage) {
	gclass := (*C.SoupServerClass)(coreglib.PeekParentClass(server))
	fnarg := gclass.request_started

	var _arg0 *C.SoupServer        // out
	var _arg1 *C.SoupServerMessage // out

	_arg0 = (*C.SoupServer)(unsafe.Pointer(coreglib.InternObject(server).Native()))
	_arg1 = (*C.SoupServerMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C._gotk4_soup3_Server_virtual_request_started(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(server)
	runtime.KeepAlive(msg)
}

// ServerClass: instance of this type is always passed by reference.
type ServerClass struct {
	*serverClass
}

// serverClass is the struct that's finalized.
type serverClass struct {
	native *C.SoupServerClass
}

func (s *ServerClass) Padding() [6]unsafe.Pointer {
	valptr := &s.native.padding
	var _v [6]unsafe.Pointer // out
	{
		src := &*valptr
		for i := 0; i < 6; i++ {
			_v[i] = (unsafe.Pointer)(unsafe.Pointer(src[i]))
		}
	}
	return _v
}
