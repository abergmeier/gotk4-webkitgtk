// Code generated by girgen. DO NOT EDIT.

package soup

import (
	"context"
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <libsoup/soup.h>
// extern void _gotk4_soup3_Session_ConnectRequestUnqueued(gpointer, SoupMessage*, guintptr);
// extern void _gotk4_soup3_Session_ConnectRequestQueued(gpointer, SoupMessage*, guintptr);
// extern void _gotk4_soup3_SessionClass_request_unqueued(SoupSession*, SoupMessage*);
// extern void _gotk4_soup3_SessionClass_request_queued(SoupSession*, SoupMessage*);
// extern void _gotk4_soup3_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
// extern void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
// void _gotk4_soup3_Session_virtual_request_queued(void* fnptr, SoupSession* arg0, SoupMessage* arg1) {
//   ((void (*)(SoupSession*, SoupMessage*))(fnptr))(arg0, arg1);
// };
// void _gotk4_soup3_Session_virtual_request_unqueued(void* fnptr, SoupSession* arg0, SoupMessage* arg1) {
//   ((void (*)(SoupSession*, SoupMessage*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeSessionError = coreglib.Type(C.soup_session_error_get_type())
	GTypeSession      = coreglib.Type(C.soup_session_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeSessionError, F: marshalSessionError},
		coreglib.TypeMarshaler{T: GTypeSession, F: marshalSession},
	})
}

// SessionError: Session error.
type SessionError C.gint

const (
	// SessionErrorParsing server's response could not be parsed.
	SessionErrorParsing SessionError = iota
	// SessionErrorEncoding server's response was in an unsupported format.
	SessionErrorEncoding
	// SessionErrorTooManyRedirects: message has been redirected too many times.
	SessionErrorTooManyRedirects
	// SessionErrorTooManyRestarts: message has been restarted too many times.
	SessionErrorTooManyRestarts
	// SessionErrorRedirectNoLocation: failed to redirect message because
	// Location header was missing or empty in response.
	SessionErrorRedirectNoLocation
	// SessionErrorRedirectBadURI: failed to redirect message because Location
	// header contains an invalid URI.
	SessionErrorRedirectBadURI
	// SessionErrorMessageAlreadyInQueue: message is already in the session
	// queue. Messages can only be reused after unqueued.
	SessionErrorMessageAlreadyInQueue
)

func marshalSessionError(p uintptr) (interface{}, error) {
	return SessionError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SessionError.
func (s SessionError) String() string {
	switch s {
	case SessionErrorParsing:
		return "Parsing"
	case SessionErrorEncoding:
		return "Encoding"
	case SessionErrorTooManyRedirects:
		return "TooManyRedirects"
	case SessionErrorTooManyRestarts:
		return "TooManyRestarts"
	case SessionErrorRedirectNoLocation:
		return "RedirectNoLocation"
	case SessionErrorRedirectBadURI:
		return "RedirectBadURI"
	case SessionErrorMessageAlreadyInQueue:
		return "MessageAlreadyInQueue"
	default:
		return fmt.Sprintf("SessionError(%d)", s)
	}
}

// SessionOverrides contains methods that are overridable.
type SessionOverrides struct {
	// The function takes the following parameters:
	//
	RequestQueued func(msg *Message)
	// The function takes the following parameters:
	//
	RequestUnqueued func(msg *Message)
}

func defaultSessionOverrides(v *Session) SessionOverrides {
	return SessionOverrides{
		RequestQueued:   v.requestQueued,
		RequestUnqueued: v.requestUnqueued,
	}
}

// Session class managing options and state for Message<!-- -->s.
type Session struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Session)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Session, *SessionClass, SessionOverrides](
		GTypeSession,
		initSessionClass,
		wrapSession,
		defaultSessionOverrides,
	)
}

func initSessionClass(gclass unsafe.Pointer, overrides SessionOverrides, classInitFunc func(*SessionClass)) {
	pclass := (*C.SoupSessionClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeSession))))

	if overrides.RequestQueued != nil {
		pclass.request_queued = (*[0]byte)(C._gotk4_soup3_SessionClass_request_queued)
	}

	if overrides.RequestUnqueued != nil {
		pclass.request_unqueued = (*[0]byte)(C._gotk4_soup3_SessionClass_request_unqueued)
	}

	if classInitFunc != nil {
		class := (*SessionClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSession(obj *coreglib.Object) *Session {
	return &Session{
		Object: obj,
	}
}

func marshalSession(p uintptr) (interface{}, error) {
	return wrapSession(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectRequestQueued is emitted when a request is queued on session.
//
// When sending a request, first Session::request_queued is emitted, indicating
// that the session has become aware of the request.
//
// After a connection is available to send the request various Message signals
// are emitted as the message is processed. If the message is requeued, it will
// emit Message::restarted, which will then be followed by other Message signals
// when the message is re-sent.
//
// Eventually, the message will emit Message::finished. Normally, this signals
// the completion of message processing. However, it is possible that the
// application will requeue the message from the "finished" handler. In that
// case the process will loop back.
//
// Eventually, a message will reach "finished" and not be requeued. At that
// point, the session will emit Session::request_unqueued to indicate that it is
// done with the message.
//
// To sum up: Session::request_queued and Session::request_unqueued are
// guaranteed to be emitted exactly once, but Message::finished (and all of the
// other Message signals) may be invoked multiple times for a given message.
func (session *Session) ConnectRequestQueued(f func(msg *Message)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(session, "request-queued", false, unsafe.Pointer(C._gotk4_soup3_Session_ConnectRequestQueued), f)
}

// ConnectRequestUnqueued is emitted when a request is removed from session's
// queue, indicating that session is done with it. See Session::request_queued
// for a detailed description of the message lifecycle within a session.
func (session *Session) ConnectRequestUnqueued(f func(msg *Message)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(session, "request-unqueued", false, unsafe.Pointer(C._gotk4_soup3_Session_ConnectRequestUnqueued), f)
}

// NewSession creates a Session with the default options.
//
// The function returns the following values:
//
//   - session: new session.
//
func NewSession() *Session {
	var _cret *C.SoupSession // in

	_cret = C.soup_session_new()

	var _session *Session // out

	_session = wrapSession(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _session
}

// Abort cancels all pending requests in session and closes all idle persistent
// connections.
func (session *Session) Abort() {
	var _arg0 *C.SoupSession // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	C.soup_session_abort(_arg0)
	runtime.KeepAlive(session)
}

// AddFeature adds feature's functionality to session. You cannot add multiple
// features of the same #GType to a session.
//
// See the main Session documentation for information on what features are
// present in sessions by default.
//
// The function takes the following parameters:
//
//   - feature: object that implements SessionFeature.
//
func (session *Session) AddFeature(feature SessionFeaturer) {
	var _arg0 *C.SoupSession        // out
	var _arg1 *C.SoupSessionFeature // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupSessionFeature)(unsafe.Pointer(coreglib.InternObject(feature).Native()))

	C.soup_session_add_feature(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(feature)
}

// AddFeatureByType: if feature_type is the type of a class that implements
// SessionFeature, this creates a new feature of that type and adds it to
// session as with soup_session_add_feature(). You can use this when you don't
// need to customize the new feature in any way. Adding multiple features of the
// same feature_type is not allowed.
//
// If feature_type is not a SessionFeature type, this gives each existing
// feature on session the chance to accept feature_type as a "subfeature".
// This can be used to add new Auth types, for instance.
//
// See the main Session documentation for information on what features are
// present in sessions by default.
//
// The function takes the following parameters:
//
//   - featureType: #GType.
//
func (session *Session) AddFeatureByType(featureType coreglib.Type) {
	var _arg0 *C.SoupSession // out
	var _arg1 C.GType        // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = C.GType(featureType)

	C.soup_session_add_feature_by_type(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(featureType)
}

// AcceptLanguage: get the value used by session for the "Accept-Language"
// header on new requests.
//
// The function returns the following values:
//
//   - utf8 (optional): accept language string or NULL.
//
func (session *Session) AcceptLanguage() string {
	var _arg0 *C.SoupSession // out
	var _cret *C.char        // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_accept_language(_arg0)
	runtime.KeepAlive(session)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// AcceptLanguageAuto: get whether session automatically sets the
// "Accept-Language" header on new requests.
//
// The function returns the following values:
//
//   - ok: TRUE if session sets "Accept-Language" header automatically, or FALSE
//     otherwise.
//
func (session *Session) AcceptLanguageAuto() bool {
	var _arg0 *C.SoupSession // out
	var _cret C.gboolean     // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_accept_language_auto(_arg0)
	runtime.KeepAlive(session)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AsyncResultMessage gets the Message of the result asynchronous operation This
// is useful to get the Message of an asynchronous operation started by session
// from its ReadyCallback.
//
// The function takes the following parameters:
//
//   - result passed to your callback.
//
// The function returns the following values:
//
//   - message (optional) or NULL if result is not a valid session async
//     operation result.
//
func (session *Session) AsyncResultMessage(result gio.AsyncResulter) *Message {
	var _arg0 *C.SoupSession  // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.SoupMessage  // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.soup_session_get_async_result_message(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(result)

	var _message *Message // out

	if _cret != nil {
		_message = wrapMessage(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _message
}

// Feature gets the feature in session of type feature_type.
//
// The function takes the following parameters:
//
//   - featureType of the feature to get.
//
// The function returns the following values:
//
//   - sessionFeature (optional) or NULL. The feature is owned by session.
//
func (session *Session) Feature(featureType coreglib.Type) *SessionFeature {
	var _arg0 *C.SoupSession        // out
	var _arg1 C.GType               // out
	var _cret *C.SoupSessionFeature // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = C.GType(featureType)

	_cret = C.soup_session_get_feature(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(featureType)

	var _sessionFeature *SessionFeature // out

	if _cret != nil {
		_sessionFeature = wrapSessionFeature(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _sessionFeature
}

// FeatureForMessage gets the feature in session of type feature_type, provided
// that it is not disabled for msg.
//
// The function takes the following parameters:
//
//   - featureType of the feature to get.
//   - msg: Message.
//
// The function returns the following values:
//
//   - sessionFeature (optional) or NULL. The feature is owned by session.
//
func (session *Session) FeatureForMessage(featureType coreglib.Type, msg *Message) *SessionFeature {
	var _arg0 *C.SoupSession        // out
	var _arg1 C.GType               // out
	var _arg2 *C.SoupMessage        // out
	var _cret *C.SoupSessionFeature // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = C.GType(featureType)
	_arg2 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_session_get_feature_for_message(_arg0, _arg1, _arg2)
	runtime.KeepAlive(session)
	runtime.KeepAlive(featureType)
	runtime.KeepAlive(msg)

	var _sessionFeature *SessionFeature // out

	if _cret != nil {
		_sessionFeature = wrapSessionFeature(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _sessionFeature
}

// IdleTimeout: get the timeout in seconds for idle connection lifetime
// currently used by session.
//
// The function returns the following values:
//
//   - guint: timeout in seconds.
//
func (session *Session) IdleTimeout() uint {
	var _arg0 *C.SoupSession // out
	var _cret C.guint        // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_idle_timeout(_arg0)
	runtime.KeepAlive(session)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// LocalAddress: get the SocketAddress to use for the client side of connections
// in session.
//
// The function returns the following values:
//
//   - inetSocketAddress (optional) or NULL.
//
func (session *Session) LocalAddress() *gio.InetSocketAddress {
	var _arg0 *C.SoupSession        // out
	var _cret *C.GInetSocketAddress // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_local_address(_arg0)
	runtime.KeepAlive(session)

	var _inetSocketAddress *gio.InetSocketAddress // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_inetSocketAddress = &gio.InetSocketAddress{
				SocketAddress: gio.SocketAddress{
					Object: obj,
					SocketConnectable: gio.SocketConnectable{
						Object: obj,
					},
				},
			}
		}
	}

	return _inetSocketAddress
}

// MaxConns: get the maximum number of connections that session can open at
// once.
//
// The function returns the following values:
//
//   - guint: maximum number of connections.
//
func (session *Session) MaxConns() uint {
	var _arg0 *C.SoupSession // out
	var _cret C.guint        // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_max_conns(_arg0)
	runtime.KeepAlive(session)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// MaxConnsPerHost: get the maximum number of connections that session can open
// at once to a given host.
//
// The function returns the following values:
//
//   - guint: maximum number of connections per host.
//
func (session *Session) MaxConnsPerHost() uint {
	var _arg0 *C.SoupSession // out
	var _cret C.guint        // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_max_conns_per_host(_arg0)
	runtime.KeepAlive(session)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ProxyResolver: get the Resolver currently used by session.
//
// The function returns the following values:
//
//   - proxyResolver (optional) or NULL if proxies are disabled in session.
//
func (session *Session) ProxyResolver() *gio.ProxyResolver {
	var _arg0 *C.SoupSession    // out
	var _cret *C.GProxyResolver // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_proxy_resolver(_arg0)
	runtime.KeepAlive(session)

	var _proxyResolver *gio.ProxyResolver // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_proxyResolver = &gio.ProxyResolver{
				Object: obj,
			}
		}
	}

	return _proxyResolver
}

// RemoteConnectable: get the remote connectable if one set.
//
// The function returns the following values:
//
//   - socketConnectable (optional) or NULL.
//
func (session *Session) RemoteConnectable() *gio.SocketConnectable {
	var _arg0 *C.SoupSession        // out
	var _cret *C.GSocketConnectable // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_remote_connectable(_arg0)
	runtime.KeepAlive(session)

	var _socketConnectable *gio.SocketConnectable // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_socketConnectable = &gio.SocketConnectable{
				Object: obj,
			}
		}
	}

	return _socketConnectable
}

// Timeout: get the timeout in seconds for socket I/O operations currently used
// by session.
//
// The function returns the following values:
//
//   - guint: timeout in seconds.
//
func (session *Session) Timeout() uint {
	var _arg0 *C.SoupSession // out
	var _cret C.guint        // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_timeout(_arg0)
	runtime.KeepAlive(session)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// TLSDatabase: get the Database currently used by session.
//
// The function returns the following values:
//
//   - tlsDatabase (optional) or NULL.
//
func (session *Session) TLSDatabase() gio.TLSDatabaser {
	var _arg0 *C.SoupSession  // out
	var _cret *C.GTlsDatabase // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_tls_database(_arg0)
	runtime.KeepAlive(session)

	var _tlsDatabase gio.TLSDatabaser // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.TLSDatabaser)
				return ok
			})
			rv, ok := casted.(gio.TLSDatabaser)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSDatabaser")
			}
			_tlsDatabase = rv
		}
	}

	return _tlsDatabase
}

// TLSInteraction: get the Interaction currently used by session.
//
// The function returns the following values:
//
//   - tlsInteraction (optional) or NULL.
//
func (session *Session) TLSInteraction() *gio.TLSInteraction {
	var _arg0 *C.SoupSession     // out
	var _cret *C.GTlsInteraction // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_tls_interaction(_arg0)
	runtime.KeepAlive(session)

	var _tlsInteraction *gio.TLSInteraction // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_tlsInteraction = &gio.TLSInteraction{
				Object: obj,
			}
		}
	}

	return _tlsInteraction
}

// UserAgent: get the value used by session for the "User-Agent" header on new
// requests.
//
// The function returns the following values:
//
//   - utf8 (optional): user agent string or NULL.
//
func (session *Session) UserAgent() string {
	var _arg0 *C.SoupSession // out
	var _cret *C.char        // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))

	_cret = C.soup_session_get_user_agent(_arg0)
	runtime.KeepAlive(session)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// HasFeature tests if session has at a feature of type feature_type (which
// can be the type of either a SessionFeature, or else a subtype of some class
// managed by another feature, such as Auth).
//
// The function takes the following parameters:
//
//   - featureType of the class of features to check for.
//
// The function returns the following values:
//
//   - ok: TRUE or FALSE.
//
func (session *Session) HasFeature(featureType coreglib.Type) bool {
	var _arg0 *C.SoupSession // out
	var _arg1 C.GType        // out
	var _cret C.gboolean     // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = C.GType(featureType)

	_cret = C.soup_session_has_feature(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(featureType)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PreconnectAsync: start a preconnection to msg. Once the connection is done,
// it will remain in idle state so that it can be reused by future requests.
// If there's already an idle connection for the given msg host, the operation
// finishes successfully without creating a new connection. If a new request for
// the given msg host is made while the preconnect is still ongoing, the request
// will take the ownership of the connection and the preconnect operation will
// finish successfully (if there's a connection error it will be handled by the
// request).
//
// The operation finishes when the connection is done or an error occurred.
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//   - msg: Message.
//   - ioPriority: i/O priority of the request.
//   - callback (optional) to invoke when the operation finishes.
//
func (session *Session) PreconnectAsync(ctx context.Context, msg *Message, ioPriority int, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SoupSession        // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.SoupMessage        // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.soup_session_preconnect_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(session)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// PreconnectFinish: complete a preconnect async operation started with
// soup_session_preconnect_async().
//
// The function takes the following parameters:
//
//   - result passed to your callback.
//
func (session *Session) PreconnectFinish(result gio.AsyncResulter) error {
	var _arg0 *C.SoupSession  // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.soup_session_preconnect_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(session)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// RemoveFeature removes feature's functionality from session.
//
// The function takes the following parameters:
//
//   - feature that has previously been added to session.
//
func (session *Session) RemoveFeature(feature SessionFeaturer) {
	var _arg0 *C.SoupSession        // out
	var _arg1 *C.SoupSessionFeature // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupSessionFeature)(unsafe.Pointer(coreglib.InternObject(feature).Native()))

	C.soup_session_remove_feature(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(feature)
}

// RemoveFeatureByType removes all features of type feature_type (or
// any subclass of feature_type) from session. You can also remove
// standard features from the session at construct time by using the
// SoupSession:remove-feature-by-type property.
//
// The function takes the following parameters:
//
//   - featureType: #GType.
//
func (session *Session) RemoveFeatureByType(featureType coreglib.Type) {
	var _arg0 *C.SoupSession // out
	var _arg1 C.GType        // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = C.GType(featureType)

	C.soup_session_remove_feature_by_type(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(featureType)
}

// Send: synchronously sends msg and waits for the beginning of a response.
// On success, a Stream will be returned which you can use to read the response
// body. ("Success" here means only that an HTTP response was received and
// understood; it does not necessarily mean that a 2xx class status code was
// received.)
//
// If non-NULL, cancellable can be used to cancel the request;
// soup_session_send() will return a G_IO_ERROR_CANCELLED error. Note that
// with requests that have side effects (eg, <literal>POST</literal>,
// <literal>PUT</literal>, <literal>DELETE</literal>) it is possible that you
// might cancel the request after the server acts on it, but before it returns a
// response, leaving the remote resource in an unknown state.
//
// If msg is requeued due to a redirect or authentication, the initial
// (3xx/401/407) response body will be suppressed, and soup_session_send() will
// only return once a final response has been received.
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//   - msg: Message.
//
// The function returns the following values:
//
//   - inputStream for reading the response body, or NULL on error.
//
func (session *Session) Send(ctx context.Context, msg *Message) (gio.InputStreamer, error) {
	var _arg0 *C.SoupSession  // out
	var _arg2 *C.GCancellable // out
	var _arg1 *C.SoupMessage  // out
	var _cret *C.GInputStream // in
	var _cerr *C.GError       // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_session_send(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(session)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(msg)

	var _inputStream gio.InputStreamer // out
	var _goerr error                   // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.InputStreamer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.InputStreamer)
			return ok
		})
		rv, ok := casted.(gio.InputStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.InputStreamer")
		}
		_inputStream = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _inputStream, _goerr
}

// SendAndRead: synchronously sends msg and reads the response body. On success,
// a #GBytes will be returned with the response body. This function should only
// be used when the resource to be retrieved is not too long and can be stored
// in memory.
//
// See soup_session_send() for more details on the general semantics.
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//   - msg: Message.
//
// The function returns the following values:
//
//   - bytes or NULL on error.
//
func (session *Session) SendAndRead(ctx context.Context, msg *Message) (*glib.Bytes, error) {
	var _arg0 *C.SoupSession  // out
	var _arg2 *C.GCancellable // out
	var _arg1 *C.SoupMessage  // out
	var _cret *C.GBytes       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	_cret = C.soup_session_send_and_read(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(session)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(msg)

	var _bytes *glib.Bytes // out
	var _goerr error       // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytes, _goerr
}

// SendAndReadAsync: asynchronously sends msg and reads the response body.
// When callback is called, then either msg has been sent, and its response body
// read, or else an error has occurred. This function should only be used when
// the resource to be retrieved is not too long and can be stored in memory.
// Call soup_session_send_and_read_finish() to get a #GBytes with the response
// body.
//
// See soup_session_send() for more details on the general semantics.
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//   - msg: Message.
//   - ioPriority: i/O priority of the request.
//   - callback (optional) to invoke.
//
func (session *Session) SendAndReadAsync(ctx context.Context, msg *Message, ioPriority int, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SoupSession        // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.SoupMessage        // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.soup_session_send_and_read_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(session)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// SendAndReadFinish gets the response to a soup_session_send_and_read_async()
// call and (if successful), returns a #GBytes with the response body.
//
// The function takes the following parameters:
//
//   - result passed to your callback.
//
// The function returns the following values:
//
//   - bytes or NULL on error.
//
func (session *Session) SendAndReadFinish(result gio.AsyncResulter) (*glib.Bytes, error) {
	var _arg0 *C.SoupSession  // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GBytes       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.soup_session_send_and_read_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(session)
	runtime.KeepAlive(result)

	var _bytes *glib.Bytes // out
	var _goerr error       // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytes, _goerr
}

// SendAsync: asynchronously sends msg and waits for the beginning of
// a response. When callback is called, then either msg has been sent,
// and its response headers received, or else an error has occurred. Call
// soup_session_send_finish() to get a Stream for reading the response body.
//
// See soup_session_send() for more details on the general semantics.
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//   - msg: Message.
//   - ioPriority: i/O priority of the request.
//   - callback (optional) to invoke.
//
func (session *Session) SendAsync(ctx context.Context, msg *Message, ioPriority int, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SoupSession        // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.SoupMessage        // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.soup_session_send_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(session)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// SendFinish gets the response to a soup_session_send_async() call and (if
// successful), returns a Stream that can be used to read the response body.
//
// The function takes the following parameters:
//
//   - result passed to your callback.
//
// The function returns the following values:
//
//   - inputStream for reading the response body, or NULL on error.
//
func (session *Session) SendFinish(result gio.AsyncResulter) (gio.InputStreamer, error) {
	var _arg0 *C.SoupSession  // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GInputStream // in
	var _cerr *C.GError       // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.soup_session_send_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(session)
	runtime.KeepAlive(result)

	var _inputStream gio.InputStreamer // out
	var _goerr error                   // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.InputStreamer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.InputStreamer)
			return ok
		})
		rv, ok := casted.(gio.InputStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.InputStreamer")
		}
		_inputStream = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _inputStream, _goerr
}

// SetAcceptLanguage: set the value to use for the "Accept-Language" header
// on Message<!-- -->s sent from session. If accept_language is NULL then no
// "Accept-Language" will be included in requests. See Session:accept-language
// for more information.
//
// The function takes the following parameters:
//
//   - acceptLanguage languages string.
//
func (session *Session) SetAcceptLanguage(acceptLanguage string) {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.char        // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(acceptLanguage)))
	defer C.free(unsafe.Pointer(_arg1))

	C.soup_session_set_accept_language(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(acceptLanguage)
}

// SetAcceptLanguageAuto: set whether session will automatically set the
// "Accept-Language" header on requests using a value generated from system
// languages based on g_get_language_names(). See Session:accept-language-auto
// for more information.
//
// The function takes the following parameters:
//
//   - acceptLanguageAuto: value to set.
//
func (session *Session) SetAcceptLanguageAuto(acceptLanguageAuto bool) {
	var _arg0 *C.SoupSession // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	if acceptLanguageAuto {
		_arg1 = C.TRUE
	}

	C.soup_session_set_accept_language_auto(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(acceptLanguageAuto)
}

// SetIdleTimeout: set a timeout in seconds for idle connection lifetime to
// be used by session on new connections. See Session:idle-timeout for more
// information.
//
// The function takes the following parameters:
//
//   - timeout in seconds.
//
func (session *Session) SetIdleTimeout(timeout uint) {
	var _arg0 *C.SoupSession // out
	var _arg1 C.guint        // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = C.guint(timeout)

	C.soup_session_set_idle_timeout(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(timeout)
}

// SetProxyResolver: set a Resolver to be used by session on new connections.
// If proxy_resolver is NULL then no proxies will be used. See
// Session:proxy-resolver for more information.
//
// The function takes the following parameters:
//
//   - proxyResolver (optional) or NULL.
//
func (session *Session) SetProxyResolver(proxyResolver gio.ProxyResolverer) {
	var _arg0 *C.SoupSession    // out
	var _arg1 *C.GProxyResolver // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	if proxyResolver != nil {
		_arg1 = (*C.GProxyResolver)(unsafe.Pointer(coreglib.InternObject(proxyResolver).Native()))
	}

	C.soup_session_set_proxy_resolver(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(proxyResolver)
}

// SetTimeout: set a timeout in seconds for socket I/O operations to be used by
// session on new connections. See Session:timeout for more information.
//
// The function takes the following parameters:
//
//   - timeout in seconds.
//
func (session *Session) SetTimeout(timeout uint) {
	var _arg0 *C.SoupSession // out
	var _arg1 C.guint        // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = C.guint(timeout)

	C.soup_session_set_timeout(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(timeout)
}

// SetTLSDatabase: set a Database to be used by session on new connections.
// If tls_database is NULL then certificate validation will always fail.
// See Session:tls-database for more information.
//
// The function takes the following parameters:
//
//   - tlsDatabase (optional) or NULL.
//
func (session *Session) SetTLSDatabase(tlsDatabase gio.TLSDatabaser) {
	var _arg0 *C.SoupSession  // out
	var _arg1 *C.GTlsDatabase // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	if tlsDatabase != nil {
		_arg1 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(tlsDatabase).Native()))
	}

	C.soup_session_set_tls_database(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(tlsDatabase)
}

// SetTLSInteraction: set a Interaction to be used by session on new
// connections. If tls_interaction is NULL then client certificate validation
// will always fail. See Session:tls-interaction for more information.
//
// The function takes the following parameters:
//
//   - tlsInteraction (optional) or NULL.
//
func (session *Session) SetTLSInteraction(tlsInteraction *gio.TLSInteraction) {
	var _arg0 *C.SoupSession     // out
	var _arg1 *C.GTlsInteraction // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	if tlsInteraction != nil {
		_arg1 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(tlsInteraction).Native()))
	}

	C.soup_session_set_tls_interaction(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(tlsInteraction)
}

// SetUserAgent: set the value to use for the "User-Agent" header on Message<!--
// -->s sent from session. If user_agent has trailing whitespace, session will
// append its own product token (eg, "<literal>libsoup/3.0.0</literal>") to the
// end of the header for you. If user_agent is NULL then no "User-Agent" will be
// included in requests. See Session:user-agent for more information.
//
// The function takes the following parameters:
//
//   - userAgent: user agent string.
//
func (session *Session) SetUserAgent(userAgent string) {
	var _arg0 *C.SoupSession // out
	var _arg1 *C.char        // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(userAgent)))
	defer C.free(unsafe.Pointer(_arg1))

	C.soup_session_set_user_agent(_arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(userAgent)
}

// WebsocketConnectAsync: asynchronously creates a WebsocketConnection to
// communicate with a remote server.
//
// All necessary WebSocket-related headers will be added to msg, and it will
// then be sent and asynchronously processed normally (including handling of
// redirection and HTTP authentication).
//
// If the server returns "101 Switching Protocols", then msg's status code and
// response headers will be updated, and then the WebSocket handshake will be
// completed. On success, soup_session_websocket_connect_finish() will return a
// new WebsocketConnection. On failure it will return a #GError.
//
// If the server returns a status other than "101 Switching Protocols",
// then msg will contain the complete response headers and body from the
// server's response, and soup_session_websocket_connect_finish() will return
// SOUP_WEBSOCKET_ERROR_NOT_WEBSOCKET.
//
// The function takes the following parameters:
//
//   - ctx (optional): #GCancellable.
//   - msg indicating the WebSocket server to connect to.
//   - origin (optional) of the connection.
//   - protocols (optional): a NULL-terminated array of protocols supported.
//   - ioPriority: i/O priority of the request.
//   - callback (optional) to invoke.
//
func (session *Session) WebsocketConnectAsync(ctx context.Context, msg *Message, origin string, protocols []string, ioPriority int, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SoupSession        // out
	var _arg5 *C.GCancellable       // out
	var _arg1 *C.SoupMessage        // out
	var _arg2 *C.char               // out
	var _arg3 **C.char              // out
	var _arg4 C.int                 // out
	var _arg6 C.GAsyncReadyCallback // out
	var _arg7 C.gpointer

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))
	if origin != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(origin)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	{
		_arg3 = (**C.char)(C.calloc(C.size_t((len(protocols) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg3))
		{
			out := unsafe.Slice(_arg3, len(protocols)+1)
			var zero *C.char
			out[len(protocols)] = zero
			for i := range protocols {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(protocols[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	_arg4 = C.int(ioPriority)
	if callback != nil {
		_arg6 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg7 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.soup_session_websocket_connect_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(session)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(origin)
	runtime.KeepAlive(protocols)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// WebsocketConnectFinish gets the WebsocketConnection response to a
// soup_session_websocket_connect_async() call and (if successful), returns a
// WebsocketConnection that can be used to communicate with the server.
//
// The function takes the following parameters:
//
//   - result passed to your callback.
//
// The function returns the following values:
//
//   - websocketConnection: new WebsocketConnection, or NULL on error.
//
func (session *Session) WebsocketConnectFinish(result gio.AsyncResulter) (*WebsocketConnection, error) {
	var _arg0 *C.SoupSession             // out
	var _arg1 *C.GAsyncResult            // out
	var _cret *C.SoupWebsocketConnection // in
	var _cerr *C.GError                  // in

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.soup_session_websocket_connect_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(session)
	runtime.KeepAlive(result)

	var _websocketConnection *WebsocketConnection // out
	var _goerr error                              // out

	_websocketConnection = wrapWebsocketConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _websocketConnection, _goerr
}

// The function takes the following parameters:
//
func (session *Session) requestQueued(msg *Message) {
	gclass := (*C.SoupSessionClass)(coreglib.PeekParentClass(session))
	fnarg := gclass.request_queued

	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C._gotk4_soup3_Session_virtual_request_queued(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(msg)
}

// The function takes the following parameters:
//
func (session *Session) requestUnqueued(msg *Message) {
	gclass := (*C.SoupSessionClass)(coreglib.PeekParentClass(session))
	fnarg := gclass.request_unqueued

	var _arg0 *C.SoupSession // out
	var _arg1 *C.SoupMessage // out

	_arg0 = (*C.SoupSession)(unsafe.Pointer(coreglib.InternObject(session).Native()))
	_arg1 = (*C.SoupMessage)(unsafe.Pointer(coreglib.InternObject(msg).Native()))

	C._gotk4_soup3_Session_virtual_request_unqueued(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(session)
	runtime.KeepAlive(msg)
}

// SessionClass: instance of this type is always passed by reference.
type SessionClass struct {
	*sessionClass
}

// sessionClass is the struct that's finalized.
type sessionClass struct {
	native *C.SoupSessionClass
}
