// Code generated by girgen. DO NOT EDIT.

package webkit2

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/gtk/v3"
)

// #cgo pkg-config: webkit2gtk-4.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <webkit2/webkit2.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.webkit_context_menu_item_get_type()), F: marshalContextMenuItemmer},
	})
}

type ContextMenuItem struct {
	externglib.InitiallyUnowned
}

func wrapContextMenuItem(obj *externglib.Object) *ContextMenuItem {
	return &ContextMenuItem{
		InitiallyUnowned: externglib.InitiallyUnowned{
			Object: obj,
		},
	}
}

func marshalContextMenuItemmer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapContextMenuItem(obj), nil
}

// NewContextMenuItem creates a new KitContextMenuItem for the given action.
//
// Deprecated: Use webkit_context_menu_item_new_from_gaction() instead.
func NewContextMenuItem(action *gtk.Action) *ContextMenuItem {
	var _arg1 *C.GtkAction             // out
	var _cret *C.WebKitContextMenuItem // in

	_arg1 = (*C.GtkAction)(unsafe.Pointer(action.Native()))

	_cret = C.webkit_context_menu_item_new(_arg1)
	runtime.KeepAlive(action)

	var _contextMenuItem *ContextMenuItem // out

	_contextMenuItem = wrapContextMenuItem(externglib.Take(unsafe.Pointer(_cret)))

	return _contextMenuItem
}

// NewContextMenuItemFromGaction creates a new KitContextMenuItem for the given
// action and label. On activation target will be passed as parameter to the
// callback.
func NewContextMenuItemFromGaction(action gio.Actioner, label string, target *glib.Variant) *ContextMenuItem {
	var _arg1 *C.GAction               // out
	var _arg2 *C.gchar                 // out
	var _arg3 *C.GVariant              // out
	var _cret *C.WebKitContextMenuItem // in

	_arg1 = (*C.GAction)(unsafe.Pointer(action.Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg2))
	if target != nil {
		_arg3 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(target)))
	}

	_cret = C.webkit_context_menu_item_new_from_gaction(_arg1, _arg2, _arg3)
	runtime.KeepAlive(action)
	runtime.KeepAlive(label)
	runtime.KeepAlive(target)

	var _contextMenuItem *ContextMenuItem // out

	_contextMenuItem = wrapContextMenuItem(externglib.Take(unsafe.Pointer(_cret)))

	return _contextMenuItem
}

// NewContextMenuItemFromStockAction creates a new KitContextMenuItem for the
// given stock action. Stock actions are handled automatically by WebKit so
// that, for example, when a menu item created with a
// WEBKIT_CONTEXT_MENU_ACTION_STOP is activated the action associated will be
// handled by WebKit and the current load operation will be stopped. You can get
// the #GAction of a KitContextMenuItem created with a KitContextMenuAction with
// webkit_context_menu_item_get_gaction() and connect to the Action::activate
// signal to be notified when the item is activated, but you can't prevent the
// associated action from being performed.
func NewContextMenuItemFromStockAction(action ContextMenuAction) *ContextMenuItem {
	var _arg1 C.WebKitContextMenuAction // out
	var _cret *C.WebKitContextMenuItem  // in

	_arg1 = C.WebKitContextMenuAction(action)

	_cret = C.webkit_context_menu_item_new_from_stock_action(_arg1)
	runtime.KeepAlive(action)

	var _contextMenuItem *ContextMenuItem // out

	_contextMenuItem = wrapContextMenuItem(externglib.Take(unsafe.Pointer(_cret)))

	return _contextMenuItem
}

// NewContextMenuItemFromStockActionWithLabel creates a new KitContextMenuItem
// for the given stock action using the given label. Stock actions have a
// predefined label, this method can be used to create a KitContextMenuItem for
// a KitContextMenuAction but using a custom label.
func NewContextMenuItemFromStockActionWithLabel(action ContextMenuAction, label string) *ContextMenuItem {
	var _arg1 C.WebKitContextMenuAction // out
	var _arg2 *C.gchar                  // out
	var _cret *C.WebKitContextMenuItem  // in

	_arg1 = C.WebKitContextMenuAction(action)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.webkit_context_menu_item_new_from_stock_action_with_label(_arg1, _arg2)
	runtime.KeepAlive(action)
	runtime.KeepAlive(label)

	var _contextMenuItem *ContextMenuItem // out

	_contextMenuItem = wrapContextMenuItem(externglib.Take(unsafe.Pointer(_cret)))

	return _contextMenuItem
}

// NewContextMenuItemSeparator creates a new KitContextMenuItem representing a
// separator.
func NewContextMenuItemSeparator() *ContextMenuItem {
	var _cret *C.WebKitContextMenuItem // in

	_cret = C.webkit_context_menu_item_new_separator()

	var _contextMenuItem *ContextMenuItem // out

	_contextMenuItem = wrapContextMenuItem(externglib.Take(unsafe.Pointer(_cret)))

	return _contextMenuItem
}

// NewContextMenuItemWithSubmenu creates a new KitContextMenuItem using the
// given label with a submenu.
func NewContextMenuItemWithSubmenu(label string, submenu *ContextMenu) *ContextMenuItem {
	var _arg1 *C.gchar                 // out
	var _arg2 *C.WebKitContextMenu     // out
	var _cret *C.WebKitContextMenuItem // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.WebKitContextMenu)(unsafe.Pointer(submenu.Native()))

	_cret = C.webkit_context_menu_item_new_with_submenu(_arg1, _arg2)
	runtime.KeepAlive(label)
	runtime.KeepAlive(submenu)

	var _contextMenuItem *ContextMenuItem // out

	_contextMenuItem = wrapContextMenuItem(externglib.Take(unsafe.Pointer(_cret)))

	return _contextMenuItem
}

// Action gets the action associated to item as a Action.
//
// Deprecated: Use webkit_context_menu_item_get_gaction() instead.
func (item *ContextMenuItem) Action() *gtk.Action {
	var _arg0 *C.WebKitContextMenuItem // out
	var _cret *C.GtkAction             // in

	_arg0 = (*C.WebKitContextMenuItem)(unsafe.Pointer(item.Native()))

	_cret = C.webkit_context_menu_item_get_action(_arg0)
	runtime.KeepAlive(item)

	var _action *gtk.Action // out

	{
		obj := externglib.Take(unsafe.Pointer(_cret))
		_action = &gtk.Action{
			Object: obj,
			Buildable: gtk.Buildable{
				Object: obj,
			},
		}
	}

	return _action
}

// Gaction gets the action associated to item as a #GAction.
func (item *ContextMenuItem) Gaction() gio.Actioner {
	var _arg0 *C.WebKitContextMenuItem // out
	var _cret *C.GAction               // in

	_arg0 = (*C.WebKitContextMenuItem)(unsafe.Pointer(item.Native()))

	_cret = C.webkit_context_menu_item_get_gaction(_arg0)
	runtime.KeepAlive(item)

	var _action gio.Actioner // out

	_action = (externglib.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(gio.Actioner)

	return _action
}

// StockAction gets the KitContextMenuAction of item. If the KitContextMenuItem
// was not created for a stock action WEBKIT_CONTEXT_MENU_ACTION_CUSTOM will be
// returned. If the KitContextMenuItem is a separator
// WEBKIT_CONTEXT_MENU_ACTION_NO_ACTION will be returned.
func (item *ContextMenuItem) StockAction() ContextMenuAction {
	var _arg0 *C.WebKitContextMenuItem  // out
	var _cret C.WebKitContextMenuAction // in

	_arg0 = (*C.WebKitContextMenuItem)(unsafe.Pointer(item.Native()))

	_cret = C.webkit_context_menu_item_get_stock_action(_arg0)
	runtime.KeepAlive(item)

	var _contextMenuAction ContextMenuAction // out

	_contextMenuAction = ContextMenuAction(_cret)

	return _contextMenuAction
}

// Submenu gets the submenu of item.
func (item *ContextMenuItem) Submenu() *ContextMenu {
	var _arg0 *C.WebKitContextMenuItem // out
	var _cret *C.WebKitContextMenu     // in

	_arg0 = (*C.WebKitContextMenuItem)(unsafe.Pointer(item.Native()))

	_cret = C.webkit_context_menu_item_get_submenu(_arg0)
	runtime.KeepAlive(item)

	var _contextMenu *ContextMenu // out

	_contextMenu = wrapContextMenu(externglib.Take(unsafe.Pointer(_cret)))

	return _contextMenu
}

// IsSeparator checks whether item is a separator.
func (item *ContextMenuItem) IsSeparator() bool {
	var _arg0 *C.WebKitContextMenuItem // out
	var _cret C.gboolean               // in

	_arg0 = (*C.WebKitContextMenuItem)(unsafe.Pointer(item.Native()))

	_cret = C.webkit_context_menu_item_is_separator(_arg0)
	runtime.KeepAlive(item)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetSubmenu sets or replaces the item submenu. If submenu is NULL the current
// submenu of item is removed.
func (item *ContextMenuItem) SetSubmenu(submenu *ContextMenu) {
	var _arg0 *C.WebKitContextMenuItem // out
	var _arg1 *C.WebKitContextMenu     // out

	_arg0 = (*C.WebKitContextMenuItem)(unsafe.Pointer(item.Native()))
	if submenu != nil {
		_arg1 = (*C.WebKitContextMenu)(unsafe.Pointer(submenu.Native()))
	}

	C.webkit_context_menu_item_set_submenu(_arg0, _arg1)
	runtime.KeepAlive(item)
	runtime.KeepAlive(submenu)
}
