// Code generated by girgen. DO NOT EDIT.

package webkit2

import (
	"runtime"
	"unsafe"

	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: webkit2gtk-4.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <webkit2/webkit2.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.webkit_download_get_type()), F: marshalDownloader},
	})
}

// DownloadOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type DownloadOverrider interface {
	DecideDestination(suggestedFilename string) bool
}

type Download struct {
	*externglib.Object
}

func wrapDownload(obj *externglib.Object) *Download {
	return &Download{
		Object: obj,
	}
}

func marshalDownloader(p uintptr) (interface{}, error) {
	return wrapDownload(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Cancel cancels the download. When the ongoing download operation is
// effectively cancelled the signal KitDownload::failed is emitted with
// WEBKIT_DOWNLOAD_ERROR_CANCELLED_BY_USER error.
func (download *Download) Cancel() {
	var _arg0 *C.WebKitDownload // out

	_arg0 = (*C.WebKitDownload)(unsafe.Pointer(download.Native()))

	C.webkit_download_cancel(_arg0)
	runtime.KeepAlive(download)
}

// AllowOverwrite returns the current value of the KitDownload:allow-overwrite
// property, which determines whether the download will overwrite an existing
// file on disk, or if it will fail if the destination already exists.
func (download *Download) AllowOverwrite() bool {
	var _arg0 *C.WebKitDownload // out
	var _cret C.gboolean        // in

	_arg0 = (*C.WebKitDownload)(unsafe.Pointer(download.Native()))

	_cret = C.webkit_download_get_allow_overwrite(_arg0)
	runtime.KeepAlive(download)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Destination obtains the URI to which the downloaded file will be written. You
// can connect to KitDownload::created-destination to make sure this method
// returns a valid destination.
func (download *Download) Destination() string {
	var _arg0 *C.WebKitDownload // out
	var _cret *C.gchar          // in

	_arg0 = (*C.WebKitDownload)(unsafe.Pointer(download.Native()))

	_cret = C.webkit_download_get_destination(_arg0)
	runtime.KeepAlive(download)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// ElapsedTime gets the elapsed time in seconds, including any fractional part.
// If the download finished, had an error or was cancelled this is the time
// between its start and the event.
func (download *Download) ElapsedTime() float64 {
	var _arg0 *C.WebKitDownload // out
	var _cret C.gdouble         // in

	_arg0 = (*C.WebKitDownload)(unsafe.Pointer(download.Native()))

	_cret = C.webkit_download_get_elapsed_time(_arg0)
	runtime.KeepAlive(download)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// EstimatedProgress gets the value of the KitDownload:estimated-progress
// property. You can monitor the estimated progress of the download operation by
// connecting to the notify::estimated-progress signal of download.
func (download *Download) EstimatedProgress() float64 {
	var _arg0 *C.WebKitDownload // out
	var _cret C.gdouble         // in

	_arg0 = (*C.WebKitDownload)(unsafe.Pointer(download.Native()))

	_cret = C.webkit_download_get_estimated_progress(_arg0)
	runtime.KeepAlive(download)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// ReceivedDataLength gets the length of the data already downloaded for
// download in bytes.
func (download *Download) ReceivedDataLength() uint64 {
	var _arg0 *C.WebKitDownload // out
	var _cret C.guint64         // in

	_arg0 = (*C.WebKitDownload)(unsafe.Pointer(download.Native()))

	_cret = C.webkit_download_get_received_data_length(_arg0)
	runtime.KeepAlive(download)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// Request retrieves the KitURIRequest object that backs the download process.
func (download *Download) Request() *URIRequest {
	var _arg0 *C.WebKitDownload   // out
	var _cret *C.WebKitURIRequest // in

	_arg0 = (*C.WebKitDownload)(unsafe.Pointer(download.Native()))

	_cret = C.webkit_download_get_request(_arg0)
	runtime.KeepAlive(download)

	var _uriRequest *URIRequest // out

	_uriRequest = wrapURIRequest(externglib.Take(unsafe.Pointer(_cret)))

	return _uriRequest
}

// Response retrieves the KitURIResponse object that backs the download process.
// This method returns NULL if called before the response is received from the
// server. You can connect to notify::response signal to be notified when the
// response is received.
func (download *Download) Response() *URIResponse {
	var _arg0 *C.WebKitDownload    // out
	var _cret *C.WebKitURIResponse // in

	_arg0 = (*C.WebKitDownload)(unsafe.Pointer(download.Native()))

	_cret = C.webkit_download_get_response(_arg0)
	runtime.KeepAlive(download)

	var _uriResponse *URIResponse // out

	_uriResponse = wrapURIResponse(externglib.Take(unsafe.Pointer(_cret)))

	return _uriResponse
}

// WebView: get the KitWebView that initiated the download.
func (download *Download) WebView() *WebView {
	var _arg0 *C.WebKitDownload // out
	var _cret *C.WebKitWebView  // in

	_arg0 = (*C.WebKitDownload)(unsafe.Pointer(download.Native()))

	_cret = C.webkit_download_get_web_view(_arg0)
	runtime.KeepAlive(download)

	var _webView *WebView // out

	_webView = wrapWebView(externglib.Take(unsafe.Pointer(_cret)))

	return _webView
}

// SetAllowOverwrite sets the KitDownload:allow-overwrite property, which
// determines whether the download may overwrite an existing file on disk, or if
// it will fail if the destination already exists.
//
// The function takes the following parameters:
//
//    - allowed: new value for the KitDownload:allow-overwrite property.
//
func (download *Download) SetAllowOverwrite(allowed bool) {
	var _arg0 *C.WebKitDownload // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.WebKitDownload)(unsafe.Pointer(download.Native()))
	if allowed {
		_arg1 = C.TRUE
	}

	C.webkit_download_set_allow_overwrite(_arg0, _arg1)
	runtime.KeepAlive(download)
	runtime.KeepAlive(allowed)
}

// SetDestination sets the URI to which the downloaded file will be written.
// This method should be called before the download transfer starts or it will
// not have any effect on the ongoing download operation. To set the destination
// using the filename suggested by the server connect to
// KitDownload::decide-destination signal and call
// webkit_download_set_destination(). If you want to set a fixed destination URI
// that doesn't depend on the suggested filename you can connect to
// notify::response signal and call webkit_download_set_destination(). If
// KitDownload::decide-destination signal is not handled and destination URI is
// not set when the download transfer starts, the file will be saved with the
// filename suggested by the server in G_USER_DIRECTORY_DOWNLOAD directory.
//
// The function takes the following parameters:
//
//    - uri: destination URI.
//
func (download *Download) SetDestination(uri string) {
	var _arg0 *C.WebKitDownload // out
	var _arg1 *C.gchar          // out

	_arg0 = (*C.WebKitDownload)(unsafe.Pointer(download.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	C.webkit_download_set_destination(_arg0, _arg1)
	runtime.KeepAlive(download)
	runtime.KeepAlive(uri)
}

// ConnectCreatedDestination: this signal is emitted after
// KitDownload::decide-destination and before KitDownload::received-data to
// notify that destination file has been created successfully at destination.
func (download *Download) ConnectCreatedDestination(f func(destination string)) externglib.SignalHandle {
	return download.Connect("created-destination", f)
}

// ConnectDecideDestination: this signal is emitted after response is received
// to decide a destination URI for the download. If this signal is not handled
// the file will be downloaded to G_USER_DIRECTORY_DOWNLOAD directory using
// suggested_filename.
func (download *Download) ConnectDecideDestination(f func(suggestedFilename string) bool) externglib.SignalHandle {
	return download.Connect("decide-destination", f)
}

// ConnectFinished: this signal is emitted when download finishes successfully
// or due to an error. In case of errors KitDownload::failed signal is emitted
// before this one.
func (download *Download) ConnectFinished(f func()) externglib.SignalHandle {
	return download.Connect("finished", f)
}

// ConnectReceivedData: this signal is emitted after response is received, every
// time new data has been written to the destination. It's useful to know the
// progress of the download operation.
func (download *Download) ConnectReceivedData(f func(dataLength uint64)) externglib.SignalHandle {
	return download.Connect("received-data", f)
}
