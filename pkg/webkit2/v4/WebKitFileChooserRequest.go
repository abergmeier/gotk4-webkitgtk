// Code generated by girgen. DO NOT EDIT.

package webkit2

import (
	"runtime"
	"unsafe"

	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gtk/v3"
)

// #cgo pkg-config: webkit2gtk-4.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <webkit2/webkit2.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.webkit_file_chooser_request_get_type()), F: marshalFileChooserRequester},
	})
}

type FileChooserRequest struct {
	*externglib.Object
}

func wrapFileChooserRequest(obj *externglib.Object) *FileChooserRequest {
	return &FileChooserRequest{
		Object: obj,
	}
}

func marshalFileChooserRequester(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapFileChooserRequest(obj), nil
}

// Cancel: ask WebKit to cancel the request. It's important to do this in case
// no selection has been made in the client, otherwise the request won't be
// properly completed and the browser will keep the request pending forever,
// which might cause the browser to hang.
func (request *FileChooserRequest) Cancel() {
	var _arg0 *C.WebKitFileChooserRequest // out

	_arg0 = (*C.WebKitFileChooserRequest)(unsafe.Pointer(request.Native()))

	C.webkit_file_chooser_request_cancel(_arg0)
	runtime.KeepAlive(request)
}

// MIMETypes: get the list of MIME types the file chooser dialog should handle,
// in the format specified in RFC 2046 for "media types". Its contents depend on
// the value of the 'accept' attribute for HTML input elements. This function
// should normally be called before presenting the file chooser dialog to the
// user, to decide whether to allow the user to select multiple files at once or
// only one.
func (request *FileChooserRequest) MIMETypes() []string {
	var _arg0 *C.WebKitFileChooserRequest // out
	var _cret **C.gchar                   // in

	_arg0 = (*C.WebKitFileChooserRequest)(unsafe.Pointer(request.Native()))

	_cret = C.webkit_file_chooser_request_get_mime_types(_arg0)
	runtime.KeepAlive(request)

	var _utf8s []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// MIMETypesFilter: get the filter currently associated with the request, ready
// to be used by FileChooser. This function should normally be called before
// presenting the file chooser dialog to the user, to decide whether to apply a
// filter so the user would not be allowed to select files with other MIME
// types.
//
// See webkit_file_chooser_request_get_mime_types() if you are interested in
// getting the list of accepted MIME types.
func (request *FileChooserRequest) MIMETypesFilter() *gtk.FileFilter {
	var _arg0 *C.WebKitFileChooserRequest // out
	var _cret *C.GtkFileFilter            // in

	_arg0 = (*C.WebKitFileChooserRequest)(unsafe.Pointer(request.Native()))

	_cret = C.webkit_file_chooser_request_get_mime_types_filter(_arg0)
	runtime.KeepAlive(request)

	var _fileFilter *gtk.FileFilter // out

	{
		obj := externglib.Take(unsafe.Pointer(_cret))
		_fileFilter = &gtk.FileFilter{
			InitiallyUnowned: externglib.InitiallyUnowned{
				Object: obj,
			},
			Buildable: gtk.Buildable{
				Object: obj,
			},
			Object: obj,
		}
	}

	return _fileFilter
}

// SelectMultiple: determine whether the file chooser associated to this
// KitFileChooserRequest should allow selecting multiple files, which depends on
// the HTML input element having a 'multiple' attribute defined.
func (request *FileChooserRequest) SelectMultiple() bool {
	var _arg0 *C.WebKitFileChooserRequest // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.WebKitFileChooserRequest)(unsafe.Pointer(request.Native()))

	_cret = C.webkit_file_chooser_request_get_select_multiple(_arg0)
	runtime.KeepAlive(request)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SelectedFiles: get the list of selected files currently associated to the
// request. Initially, the return value of this method contains any files
// selected in previous file chooser requests for this HTML input element. Once
// webkit_file_chooser_request_select_files, the value will reflect whatever
// files are given.
//
// This function should normally be called only before presenting the file
// chooser dialog to the user, to decide whether to perform some extra action,
// like pre-selecting the files from a previous request.
func (request *FileChooserRequest) SelectedFiles() []string {
	var _arg0 *C.WebKitFileChooserRequest // out
	var _cret **C.gchar                   // in

	_arg0 = (*C.WebKitFileChooserRequest)(unsafe.Pointer(request.Native()))

	_cret = C.webkit_file_chooser_request_get_selected_files(_arg0)
	runtime.KeepAlive(request)

	var _utf8s []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// SelectFiles: ask WebKit to select local files for upload and complete the
// request.
func (request *FileChooserRequest) SelectFiles(files []string) {
	var _arg0 *C.WebKitFileChooserRequest // out
	var _arg1 **C.gchar                   // out

	_arg0 = (*C.WebKitFileChooserRequest)(unsafe.Pointer(request.Native()))
	{
		_arg1 = (**C.gchar)(C.malloc(C.ulong(len(files)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(files)+1)
			var zero *C.gchar
			out[len(files)] = zero
			for i := range files {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(files[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.webkit_file_chooser_request_select_files(_arg0, _arg1)
	runtime.KeepAlive(request)
	runtime.KeepAlive(files)
}
