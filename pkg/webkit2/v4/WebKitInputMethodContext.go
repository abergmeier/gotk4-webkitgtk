// Code generated by girgen. DO NOT EDIT.

package webkit2

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
)

// #cgo pkg-config: webkit2gtk-4.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <webkit2/webkit2.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.webkit_input_purpose_get_type()), F: marshalInputPurpose},
		{T: externglib.Type(C.webkit_input_hints_get_type()), F: marshalInputHints},
		{T: externglib.Type(C.webkit_input_method_context_get_type()), F: marshalInputMethodContexter},
		{T: externglib.Type(C.webkit_input_method_underline_get_type()), F: marshalInputMethodUnderline},
	})
}

// InputPurpose: enum values used to describe the primary purpose of the active
// editable element.
type InputPurpose int

const (
	// InputPurposeFreeForm: editable element expects any characters
	InputPurposeFreeForm InputPurpose = iota
	// InputPurposeDigits: editable element expects digits
	InputPurposeDigits
	// InputPurposeNumber: editable element expects a number
	InputPurposeNumber
	// InputPurposePhone: editable element expects a telephone
	InputPurposePhone
	// InputPurposeURL: editable element expects a URL
	InputPurposeURL
	// InputPurposeEmail: editable element expects an email
	InputPurposeEmail
	// InputPurposePassword: editable element expects a password
	InputPurposePassword
)

func marshalInputPurpose(p uintptr) (interface{}, error) {
	return InputPurpose(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for InputPurpose.
func (i InputPurpose) String() string {
	switch i {
	case InputPurposeFreeForm:
		return "FreeForm"
	case InputPurposeDigits:
		return "Digits"
	case InputPurposeNumber:
		return "Number"
	case InputPurposePhone:
		return "Phone"
	case InputPurposeURL:
		return "URL"
	case InputPurposeEmail:
		return "Email"
	case InputPurposePassword:
		return "Password"
	default:
		return fmt.Sprintf("InputPurpose(%d)", i)
	}
}

// InputHints: enum values used to describe hints that might be taken into
// account by input methods.
type InputHints int

const (
	// InputHintNone: no special behavior suggested
	InputHintNone InputHints = 0b0
	// InputHintSpellcheck: suggest spell checking
	InputHintSpellcheck InputHints = 0b1
	// InputHintLowercase: suggest to not autocapitlize
	InputHintLowercase InputHints = 0b10
	// InputHintUppercaseChars: suggest to capitalize all text
	InputHintUppercaseChars InputHints = 0b100
	// InputHintUppercaseWords: suggest to capitalize the first character of
	// each word
	InputHintUppercaseWords InputHints = 0b1000
	// InputHintUppercaseSentences: suggest to capitalize the first word of each
	// sentence
	InputHintUppercaseSentences InputHints = 0b10000
	// InputHintInhibitOSK: suggest to not show an onscreen keyboard
	InputHintInhibitOSK InputHints = 0b100000
)

func marshalInputHints(p uintptr) (interface{}, error) {
	return InputHints(C.g_value_get_flags((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the names in string for InputHints.
func (i InputHints) String() string {
	if i == 0 {
		return "InputHints(0)"
	}

	var builder strings.Builder
	builder.Grow(148)

	for i != 0 {
		next := i & (i - 1)
		bit := i - next

		switch bit {
		case InputHintNone:
			builder.WriteString("None|")
		case InputHintSpellcheck:
			builder.WriteString("Spellcheck|")
		case InputHintLowercase:
			builder.WriteString("Lowercase|")
		case InputHintUppercaseChars:
			builder.WriteString("UppercaseChars|")
		case InputHintUppercaseWords:
			builder.WriteString("UppercaseWords|")
		case InputHintUppercaseSentences:
			builder.WriteString("UppercaseSentences|")
		case InputHintInhibitOSK:
			builder.WriteString("InhibitOSK|")
		default:
			builder.WriteString(fmt.Sprintf("InputHints(0b%b)|", bit))
		}

		i = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if i contains other.
func (i InputHints) Has(other InputHints) bool {
	return (i & other) == other
}

// InputMethodContextOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type InputMethodContextOverrider interface {
	Committed(text string)
	DeleteSurrounding(offset int32, nChars uint32)
	// FilterKeyEvent: allow key_event to be handled by the input method. If
	// TRUE is returned, then no further processing should be done for the key
	// event.
	FilterKeyEvent(keyEvent *gdk.EventKey) bool
	// Preedit: get the current preedit string for the context, and a list of
	// WebKitInputMethodUnderline to apply to the string. The string will be
	// displayed inserted at cursor_offset.
	Preedit() (string, []InputMethodUnderline, uint32)
	// NotifyCursorArea: notify context that cursor area changed in input
	// associated.
	NotifyCursorArea(x int32, y int32, width int32, height int32)
	// NotifyFocusIn: notify context that input associated has gained focus.
	NotifyFocusIn()
	// NotifyFocusOut: notify context that input associated has lost focus.
	NotifyFocusOut()
	// NotifySurrounding: notify context that the context surrounding the cursor
	// has changed. If there's no selection selection_index is the same as
	// cursor_index.
	NotifySurrounding(text string, length uint32, cursorIndex uint32, selectionIndex uint32)
	PreeditChanged()
	PreeditFinished()
	PreeditStarted()
	// Reset the context. This will typically cause the input to clear the
	// preedit state.
	Reset()
	// SetEnablePreedit: set whether context should enable preedit to display
	// feedback.
	SetEnablePreedit(enabled bool)
}

type InputMethodContext struct {
	*externglib.Object
}

// InputMethodContexter describes InputMethodContext's abstract methods.
type InputMethodContexter interface {
	externglib.Objector

	// FilterKeyEvent: allow key_event to be handled by the input method.
	FilterKeyEvent(keyEvent *gdk.EventKey) bool
	// InputHints: get the value of the KitInputMethodContext:input-hints
	// property.
	InputHints() InputHints
	// InputPurpose: get the value of the KitInputMethodContext:input-purpose
	// property.
	InputPurpose() InputPurpose
	// Preedit: get the current preedit string for the context, and a list of
	// WebKitInputMethodUnderline to apply to the string.
	Preedit() (string, []InputMethodUnderline, uint32)
	// NotifyCursorArea: notify context that cursor area changed in input
	// associated.
	NotifyCursorArea(x int32, y int32, width int32, height int32)
	// NotifyFocusIn: notify context that input associated has gained focus.
	NotifyFocusIn()
	// NotifyFocusOut: notify context that input associated has lost focus.
	NotifyFocusOut()
	// NotifySurrounding: notify context that the context surrounding the cursor
	// has changed.
	NotifySurrounding(text string, length int32, cursorIndex uint32, selectionIndex uint32)
	// Reset the context.
	Reset()
	// SetEnablePreedit: set whether context should enable preedit to display
	// feedback.
	SetEnablePreedit(enabled bool)
	SetInputHints(hints InputHints)
	// SetInputPurpose: set the value of the KitInputMethodContext:input-purpose
	// property.
	SetInputPurpose(purpose InputPurpose)
}

var _ InputMethodContexter = (*InputMethodContext)(nil)

func wrapInputMethodContext(obj *externglib.Object) *InputMethodContext {
	return &InputMethodContext{
		Object: obj,
	}
}

func marshalInputMethodContexter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapInputMethodContext(obj), nil
}

// FilterKeyEvent: allow key_event to be handled by the input method. If TRUE is
// returned, then no further processing should be done for the key event.
func (context *InputMethodContext) FilterKeyEvent(keyEvent *gdk.EventKey) bool {
	var _arg0 *C.WebKitInputMethodContext // out
	var _arg1 *C.GdkEventKey              // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.WebKitInputMethodContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.GdkEventKey)(gextras.StructNative(unsafe.Pointer(keyEvent)))

	_cret = C.webkit_input_method_context_filter_key_event(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(keyEvent)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InputHints: get the value of the KitInputMethodContext:input-hints property.
func (context *InputMethodContext) InputHints() InputHints {
	var _arg0 *C.WebKitInputMethodContext // out
	var _cret C.WebKitInputHints          // in

	_arg0 = (*C.WebKitInputMethodContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_input_method_context_get_input_hints(_arg0)
	runtime.KeepAlive(context)

	var _inputHints InputHints // out

	_inputHints = InputHints(_cret)

	return _inputHints
}

// InputPurpose: get the value of the KitInputMethodContext:input-purpose
// property.
func (context *InputMethodContext) InputPurpose() InputPurpose {
	var _arg0 *C.WebKitInputMethodContext // out
	var _cret C.WebKitInputPurpose        // in

	_arg0 = (*C.WebKitInputMethodContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_input_method_context_get_input_purpose(_arg0)
	runtime.KeepAlive(context)

	var _inputPurpose InputPurpose // out

	_inputPurpose = InputPurpose(_cret)

	return _inputPurpose
}

// Preedit: get the current preedit string for the context, and a list of
// WebKitInputMethodUnderline to apply to the string. The string will be
// displayed inserted at cursor_offset.
func (context *InputMethodContext) Preedit() (string, []InputMethodUnderline, uint32) {
	var _arg0 *C.WebKitInputMethodContext // out
	var _arg1 *C.char                     // in
	var _arg2 *C.GList                    // in
	var _arg3 C.guint                     // in

	_arg0 = (*C.WebKitInputMethodContext)(unsafe.Pointer(context.Native()))

	C.webkit_input_method_context_get_preedit(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(context)

	var _text string                       // out
	var _underlines []InputMethodUnderline // out
	var _cursorOffset uint32               // out

	if _arg1 != nil {
		_text = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if _arg2 != nil {
		_underlines = make([]InputMethodUnderline, 0, gextras.ListSize(unsafe.Pointer(_arg2)))
		gextras.MoveList(unsafe.Pointer(_arg2), true, func(v unsafe.Pointer) {
			src := (*C.WebKitInputMethodUnderline)(v)
			var dst InputMethodUnderline // out
			dst = *(*InputMethodUnderline)(gextras.NewStructNative(unsafe.Pointer(src)))
			_underlines = append(_underlines, dst)
		})
	}
	_cursorOffset = uint32(_arg3)

	return _text, _underlines, _cursorOffset
}

// NotifyCursorArea: notify context that cursor area changed in input
// associated.
func (context *InputMethodContext) NotifyCursorArea(x int32, y int32, width int32, height int32) {
	var _arg0 *C.WebKitInputMethodContext // out
	var _arg1 C.int                       // out
	var _arg2 C.int                       // out
	var _arg3 C.int                       // out
	var _arg4 C.int                       // out

	_arg0 = (*C.WebKitInputMethodContext)(unsafe.Pointer(context.Native()))
	_arg1 = C.int(x)
	_arg2 = C.int(y)
	_arg3 = C.int(width)
	_arg4 = C.int(height)

	C.webkit_input_method_context_notify_cursor_area(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(context)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// NotifyFocusIn: notify context that input associated has gained focus.
func (context *InputMethodContext) NotifyFocusIn() {
	var _arg0 *C.WebKitInputMethodContext // out

	_arg0 = (*C.WebKitInputMethodContext)(unsafe.Pointer(context.Native()))

	C.webkit_input_method_context_notify_focus_in(_arg0)
	runtime.KeepAlive(context)
}

// NotifyFocusOut: notify context that input associated has lost focus.
func (context *InputMethodContext) NotifyFocusOut() {
	var _arg0 *C.WebKitInputMethodContext // out

	_arg0 = (*C.WebKitInputMethodContext)(unsafe.Pointer(context.Native()))

	C.webkit_input_method_context_notify_focus_out(_arg0)
	runtime.KeepAlive(context)
}

// NotifySurrounding: notify context that the context surrounding the cursor has
// changed. If there's no selection selection_index is the same as cursor_index.
func (context *InputMethodContext) NotifySurrounding(text string, length int32, cursorIndex uint32, selectionIndex uint32) {
	var _arg0 *C.WebKitInputMethodContext // out
	var _arg1 *C.gchar                    // out
	var _arg2 C.int                       // out
	var _arg3 C.guint                     // out
	var _arg4 C.guint                     // out

	_arg0 = (*C.WebKitInputMethodContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(length)
	_arg3 = C.guint(cursorIndex)
	_arg4 = C.guint(selectionIndex)

	C.webkit_input_method_context_notify_surrounding(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(context)
	runtime.KeepAlive(text)
	runtime.KeepAlive(length)
	runtime.KeepAlive(cursorIndex)
	runtime.KeepAlive(selectionIndex)
}

// Reset the context. This will typically cause the input to clear the preedit
// state.
func (context *InputMethodContext) Reset() {
	var _arg0 *C.WebKitInputMethodContext // out

	_arg0 = (*C.WebKitInputMethodContext)(unsafe.Pointer(context.Native()))

	C.webkit_input_method_context_reset(_arg0)
	runtime.KeepAlive(context)
}

// SetEnablePreedit: set whether context should enable preedit to display
// feedback.
func (context *InputMethodContext) SetEnablePreedit(enabled bool) {
	var _arg0 *C.WebKitInputMethodContext // out
	var _arg1 C.gboolean                  // out

	_arg0 = (*C.WebKitInputMethodContext)(unsafe.Pointer(context.Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.webkit_input_method_context_set_enable_preedit(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(enabled)
}

func (context *InputMethodContext) SetInputHints(hints InputHints) {
	var _arg0 *C.WebKitInputMethodContext // out
	var _arg1 C.WebKitInputHints          // out

	_arg0 = (*C.WebKitInputMethodContext)(unsafe.Pointer(context.Native()))
	_arg1 = C.WebKitInputHints(hints)

	C.webkit_input_method_context_set_input_hints(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(hints)
}

// SetInputPurpose: set the value of the KitInputMethodContext:input-purpose
// property.
func (context *InputMethodContext) SetInputPurpose(purpose InputPurpose) {
	var _arg0 *C.WebKitInputMethodContext // out
	var _arg1 C.WebKitInputPurpose        // out

	_arg0 = (*C.WebKitInputMethodContext)(unsafe.Pointer(context.Native()))
	_arg1 = C.WebKitInputPurpose(purpose)

	C.webkit_input_method_context_set_input_purpose(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(purpose)
}

// InputMethodUnderline: instance of this type is always passed by reference.
type InputMethodUnderline struct {
	*inputMethodUnderline
}

// inputMethodUnderline is the struct that's finalized.
type inputMethodUnderline struct {
	native *C.WebKitInputMethodUnderline
}

func marshalInputMethodUnderline(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return &InputMethodUnderline{&inputMethodUnderline{(*C.WebKitInputMethodUnderline)(unsafe.Pointer(b))}}, nil
}

// NewInputMethodUnderline constructs a struct InputMethodUnderline.
func NewInputMethodUnderline(startOffset uint32, endOffset uint32) *InputMethodUnderline {
	var _arg1 C.guint                       // out
	var _arg2 C.guint                       // out
	var _cret *C.WebKitInputMethodUnderline // in

	_arg1 = C.guint(startOffset)
	_arg2 = C.guint(endOffset)

	_cret = C.webkit_input_method_underline_new(_arg1, _arg2)
	runtime.KeepAlive(startOffset)
	runtime.KeepAlive(endOffset)

	var _inputMethodUnderline *InputMethodUnderline // out

	_inputMethodUnderline = (*InputMethodUnderline)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_inputMethodUnderline)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.webkit_input_method_underline_free((*C.WebKitInputMethodUnderline)(intern.C))
		},
	)

	return _inputMethodUnderline
}

// Copy: make a copy of the KitInputMethodUnderline.
func (underline *InputMethodUnderline) Copy() *InputMethodUnderline {
	var _arg0 *C.WebKitInputMethodUnderline // out
	var _cret *C.WebKitInputMethodUnderline // in

	_arg0 = (*C.WebKitInputMethodUnderline)(gextras.StructNative(unsafe.Pointer(underline)))

	_cret = C.webkit_input_method_underline_copy(_arg0)
	runtime.KeepAlive(underline)

	var _inputMethodUnderline *InputMethodUnderline // out

	_inputMethodUnderline = (*InputMethodUnderline)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_inputMethodUnderline)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.webkit_input_method_underline_free((*C.WebKitInputMethodUnderline)(intern.C))
		},
	)

	return _inputMethodUnderline
}

// SetColor: set the color of the underline. If rgba is NULL the foreground text
// color will be used for the underline too.
func (underline *InputMethodUnderline) SetColor(rgba *gdk.RGBA) {
	var _arg0 *C.WebKitInputMethodUnderline // out
	var _arg1 *C.GdkRGBA                    // out

	_arg0 = (*C.WebKitInputMethodUnderline)(gextras.StructNative(unsafe.Pointer(underline)))
	if rgba != nil {
		_arg1 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(rgba)))
	}

	C.webkit_input_method_underline_set_color(_arg0, _arg1)
	runtime.KeepAlive(underline)
	runtime.KeepAlive(rgba)
}
