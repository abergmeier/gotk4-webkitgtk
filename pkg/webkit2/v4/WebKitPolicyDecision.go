// Code generated by girgen. DO NOT EDIT.

package webkit2

import (
	"runtime"
	"unsafe"

	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <webkit2/webkit2.h>
import "C"

// glib.Type values for WebKitPolicyDecision.go.
var GTypePolicyDecision = externglib.Type(C.webkit_policy_decision_get_type())

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: GTypePolicyDecision, F: marshalPolicyDecision},
	})
}

// PolicyDecisionOverrider contains methods that are overridable.
type PolicyDecisionOverrider interface {
}

type PolicyDecision struct {
	_ [0]func() // equal guard
	*externglib.Object
}

var (
	_ externglib.Objector = (*PolicyDecision)(nil)
)

// PolicyDecisioner describes types inherited from class PolicyDecision.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type PolicyDecisioner interface {
	externglib.Objector
	basePolicyDecision() *PolicyDecision
}

var _ PolicyDecisioner = (*PolicyDecision)(nil)

func classInitPolicyDecisioner(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

}

func wrapPolicyDecision(obj *externglib.Object) *PolicyDecision {
	return &PolicyDecision{
		Object: obj,
	}
}

func marshalPolicyDecision(p uintptr) (interface{}, error) {
	return wrapPolicyDecision(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (decision *PolicyDecision) basePolicyDecision() *PolicyDecision {
	return decision
}

// BasePolicyDecision returns the underlying base object.
func BasePolicyDecision(obj PolicyDecisioner) *PolicyDecision {
	return obj.basePolicyDecision()
}

// Download: spawn a download from this decision.
func (decision *PolicyDecision) Download() {
	var _arg0 *C.WebKitPolicyDecision // out

	_arg0 = (*C.WebKitPolicyDecision)(unsafe.Pointer(externglib.InternObject(decision).Native()))

	C.webkit_policy_decision_download(_arg0)
	runtime.KeepAlive(decision)
}

// Ignore the action which triggered this decision. For instance, for a
// KitResponsePolicyDecision, this would cancel the request.
func (decision *PolicyDecision) Ignore() {
	var _arg0 *C.WebKitPolicyDecision // out

	_arg0 = (*C.WebKitPolicyDecision)(unsafe.Pointer(externglib.InternObject(decision).Native()))

	C.webkit_policy_decision_ignore(_arg0)
	runtime.KeepAlive(decision)
}

// Use: accept the action which triggered this decision.
func (decision *PolicyDecision) Use() {
	var _arg0 *C.WebKitPolicyDecision // out

	_arg0 = (*C.WebKitPolicyDecision)(unsafe.Pointer(externglib.InternObject(decision).Native()))

	C.webkit_policy_decision_use(_arg0)
	runtime.KeepAlive(decision)
}

// UseWithPolicies: accept the navigation action which triggered this decision,
// and continue with policies affecting all subsequent loads of resources in the
// origin associated with the accepted navigation action.
//
// For example, a navigation decision to a video sharing website may be accepted
// under the priviso no movies are allowed to autoplay. The autoplay policy in
// this case would be set in the policies.
//
// The function takes the following parameters:
//
//    - policies: KitWebsitePolicies.
//
func (decision *PolicyDecision) UseWithPolicies(policies *WebsitePolicies) {
	var _arg0 *C.WebKitPolicyDecision  // out
	var _arg1 *C.WebKitWebsitePolicies // out

	_arg0 = (*C.WebKitPolicyDecision)(unsafe.Pointer(externglib.InternObject(decision).Native()))
	_arg1 = (*C.WebKitWebsitePolicies)(unsafe.Pointer(externglib.InternObject(policies).Native()))

	C.webkit_policy_decision_use_with_policies(_arg0, _arg1)
	runtime.KeepAlive(decision)
	runtime.KeepAlive(policies)
}
