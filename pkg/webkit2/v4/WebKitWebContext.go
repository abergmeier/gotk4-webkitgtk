// Code generated by girgen. DO NOT EDIT.

package webkit2

import (
	"context"
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: webkit2gtk-4.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <webkit2/webkit2.h>
// extern void callbackDelete(gpointer);
// void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
// void _gotk4_webkit24_URISchemeRequestCallback(WebKitURISchemeRequest*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.webkit_cache_model_get_type()), F: marshalCacheModel},
		{T: externglib.Type(C.webkit_process_model_get_type()), F: marshalProcessModel},
		{T: externglib.Type(C.webkit_web_context_get_type()), F: marshalWebContexter},
	})
}

// CacheModel: enum values used for determining the KitWebContext cache model.
type CacheModel C.gint

const (
	// CacheModelDocumentViewer: disable the cache completely, which
	// substantially reduces memory usage. Useful for applications that only
	// access a single local file, with no navigation to other pages. No remote
	// resources will be cached.
	CacheModelDocumentViewer CacheModel = iota
	// CacheModelWebBrowser: improve document load speed substantially by
	// caching a very large number of resources and previously viewed content.
	CacheModelWebBrowser
	// CacheModelDocumentBrowser: cache model optimized for viewing a series of
	// local files -- for example, a documentation viewer or a website designer.
	// WebKit will cache a moderate number of resources.
	CacheModelDocumentBrowser
)

func marshalCacheModel(p uintptr) (interface{}, error) {
	return CacheModel(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CacheModel.
func (c CacheModel) String() string {
	switch c {
	case CacheModelDocumentViewer:
		return "DocumentViewer"
	case CacheModelWebBrowser:
		return "WebBrowser"
	case CacheModelDocumentBrowser:
		return "DocumentBrowser"
	default:
		return fmt.Sprintf("CacheModel(%d)", c)
	}
}

// ProcessModel: enum values used for determining the KitWebContext process
// model.
type ProcessModel C.gint

const (
	// ProcessModelSharedSecondaryProcess: deprecated 2.26.
	ProcessModelSharedSecondaryProcess ProcessModel = iota
	// ProcessModelMultipleSecondaryProcesses: use one process for each
	// KitWebView, while still allowing for some of them to share a process in
	// certain situations. The main advantage of this process model is that the
	// rendering process for a web view can crash while the rest of the views
	// keep working normally. This process model is indicated for applications
	// which may use a number of web views and the content of in each must not
	// interfere with the rest â€” for example a full-fledged web browser with
	// support for multiple tabs.
	ProcessModelMultipleSecondaryProcesses
)

func marshalProcessModel(p uintptr) (interface{}, error) {
	return ProcessModel(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ProcessModel.
func (p ProcessModel) String() string {
	switch p {
	case ProcessModelSharedSecondaryProcess:
		return "SharedSecondaryProcess"
	case ProcessModelMultipleSecondaryProcesses:
		return "MultipleSecondaryProcesses"
	default:
		return fmt.Sprintf("ProcessModel(%d)", p)
	}
}

// URISchemeRequestCallback: type definition for a function that will be called
// back when an URI request is made for a user registered URI scheme.
type URISchemeRequestCallback func(request *URISchemeRequest)

//export _gotk4_webkit24_URISchemeRequestCallback
func _gotk4_webkit24_URISchemeRequestCallback(arg0 *C.WebKitURISchemeRequest, arg1 C.gpointer) {
	v := gbox.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var request *URISchemeRequest // out

	request = wrapURISchemeRequest(externglib.Take(unsafe.Pointer(arg0)))

	fn := v.(URISchemeRequestCallback)
	fn(request)
}

// WebContextOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type WebContextOverrider interface {
	AutomationStarted(session *AutomationSession)
	DownloadStarted(download *Download)
	InitializeNotificationPermissions()
	InitializeWebExtensions()
	UserMessageReceived(message *UserMessage) bool
}

type WebContext struct {
	*externglib.Object
}

var (
	_ externglib.Objector = (*WebContext)(nil)
)

func wrapWebContext(obj *externglib.Object) *WebContext {
	return &WebContext{
		Object: obj,
	}
}

func marshalWebContexter(p uintptr) (interface{}, error) {
	return wrapWebContext(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewWebContext: create a new KitWebContext.
func NewWebContext() *WebContext {
	var _cret *C.WebKitWebContext // in

	_cret = C.webkit_web_context_new()

	var _webContext *WebContext // out

	_webContext = wrapWebContext(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _webContext
}

// NewWebContextEphemeral: create a new ephemeral KitWebContext. An ephemeral
// KitWebContext is a context created with an ephemeral KitWebsiteDataManager.
// This is just a convenient method to create ephemeral contexts without having
// to create your own KitWebsiteDataManager. All KitWebView<!-- -->s associated
// with this context will also be ephemeral. Websites will not store any data in
// the client storage. This is normally used to implement private instances.
func NewWebContextEphemeral() *WebContext {
	var _cret *C.WebKitWebContext // in

	_cret = C.webkit_web_context_new_ephemeral()

	var _webContext *WebContext // out

	_webContext = wrapWebContext(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _webContext
}

// NewWebContextWithWebsiteDataManager: create a new KitWebContext with a
// KitWebsiteDataManager.
//
// The function takes the following parameters:
//
//    - manager: KitWebsiteDataManager.
//
func NewWebContextWithWebsiteDataManager(manager *WebsiteDataManager) *WebContext {
	var _arg1 *C.WebKitWebsiteDataManager // out
	var _cret *C.WebKitWebContext         // in

	_arg1 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))

	_cret = C.webkit_web_context_new_with_website_data_manager(_arg1)
	runtime.KeepAlive(manager)

	var _webContext *WebContext // out

	_webContext = wrapWebContext(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _webContext
}

// AddPathToSandbox adds a path to be mounted in the sandbox. path must exist
// before any web process has been created otherwise it will be silently
// ignored. It is a fatal error to add paths after a web process has been
// spawned.
//
// Paths in directories such as /sys, /proc, and /dev or all of / are not valid.
//
// See also webkit_web_context_set_sandbox_enabled().
//
// The function takes the following parameters:
//
//    - path: absolute path to mount in the sandbox.
//    - readOnly: if TRUE the path will be read-only.
//
func (context *WebContext) AddPathToSandbox(path string, readOnly bool) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.char             // out
	var _arg2 C.gboolean          // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))
	if readOnly {
		_arg2 = C.TRUE
	}

	C.webkit_web_context_add_path_to_sandbox(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(path)
	runtime.KeepAlive(readOnly)
}

// AllowTLSCertificateForHost: ignore further TLS errors on the host for the
// certificate present in info.
//
// The function takes the following parameters:
//
//    - certificate: Certificate.
//    - host for which a certificate is to be allowed.
//
func (context *WebContext) AllowTLSCertificateForHost(certificate gio.TLSCertificater, host string) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.GTlsCertificate  // out
	var _arg2 *C.gchar            // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(certificate.Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(host)))
	defer C.free(unsafe.Pointer(_arg2))

	C.webkit_web_context_allow_tls_certificate_for_host(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(certificate)
	runtime.KeepAlive(host)
}

// ClearCache clears all resources currently cached. See also
// webkit_web_context_set_cache_model().
func (context *WebContext) ClearCache() {
	var _arg0 *C.WebKitWebContext // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	C.webkit_web_context_clear_cache(_arg0)
	runtime.KeepAlive(context)
}

// DownloadURI requests downloading of the specified URI string. The download
// operation will not be associated to any KitWebView, if you are interested in
// starting a download from a particular KitWebView use
// webkit_web_view_download_uri() instead.
//
// The function takes the following parameters:
//
//    - uri: URI to download.
//
func (context *WebContext) DownloadURI(uri string) *Download {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.gchar            // out
	var _cret *C.WebKitDownload   // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.webkit_web_context_download_uri(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(uri)

	var _download *Download // out

	_download = wrapDownload(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _download
}

// CacheModel returns the current cache model. For more information about this
// value check the documentation of the function
// webkit_web_context_set_cache_model().
func (context *WebContext) CacheModel() CacheModel {
	var _arg0 *C.WebKitWebContext // out
	var _cret C.WebKitCacheModel  // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_cache_model(_arg0)
	runtime.KeepAlive(context)

	var _cacheModel CacheModel // out

	_cacheModel = CacheModel(_cret)

	return _cacheModel
}

// CookieManager: get the KitCookieManager of the context's
// KitWebsiteDataManager.
func (context *WebContext) CookieManager() *CookieManager {
	var _arg0 *C.WebKitWebContext    // out
	var _cret *C.WebKitCookieManager // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_cookie_manager(_arg0)
	runtime.KeepAlive(context)

	var _cookieManager *CookieManager // out

	_cookieManager = wrapCookieManager(externglib.Take(unsafe.Pointer(_cret)))

	return _cookieManager
}

// FaviconDatabase: get the KitFaviconDatabase associated with context.
//
// To initialize the database you need to call
// webkit_web_context_set_favicon_database_directory().
func (context *WebContext) FaviconDatabase() *FaviconDatabase {
	var _arg0 *C.WebKitWebContext      // out
	var _cret *C.WebKitFaviconDatabase // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_favicon_database(_arg0)
	runtime.KeepAlive(context)

	var _faviconDatabase *FaviconDatabase // out

	_faviconDatabase = wrapFaviconDatabase(externglib.Take(unsafe.Pointer(_cret)))

	return _faviconDatabase
}

// FaviconDatabaseDirectory: get the directory path being used to store the
// favicons database for context, or NULL if
// webkit_web_context_set_favicon_database_directory() hasn't been called yet.
//
// This function will always return the same path after having called
// webkit_web_context_set_favicon_database_directory() for the first time.
func (context *WebContext) FaviconDatabaseDirectory() string {
	var _arg0 *C.WebKitWebContext // out
	var _cret *C.gchar            // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_favicon_database_directory(_arg0)
	runtime.KeepAlive(context)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// GeolocationManager: get the KitGeolocationManager of context.
func (context *WebContext) GeolocationManager() *GeolocationManager {
	var _arg0 *C.WebKitWebContext         // out
	var _cret *C.WebKitGeolocationManager // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_geolocation_manager(_arg0)
	runtime.KeepAlive(context)

	var _geolocationManager *GeolocationManager // out

	_geolocationManager = wrapGeolocationManager(externglib.Take(unsafe.Pointer(_cret)))

	return _geolocationManager
}

// Plugins: asynchronously get the list of installed plugins.
//
// When the operation is finished, callback will be called. You can then call
// webkit_web_context_get_plugins_finish() to get the result of the operation.
//
// Deprecated: since version 2.32.
//
// The function takes the following parameters:
//
//    - ctx or NULL to ignore.
//    - callback to call when the request is satisfied.
//
func (context *WebContext) Plugins(ctx context.Context, callback gio.AsyncReadyCallback) {
	var _arg0 *C.WebKitWebContext   // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.webkit_web_context_get_plugins(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// PluginsFinish: finish an asynchronous operation started with
// webkit_web_context_get_plugins.
//
// Deprecated: since version 2.32.
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (context *WebContext) PluginsFinish(result gio.AsyncResulter) ([]Plugin, error) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.GAsyncResult     // out
	var _cret *C.GList            // in
	var _cerr *C.GError           // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.webkit_web_context_get_plugins_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(context)
	runtime.KeepAlive(result)

	var _list []Plugin // out
	var _goerr error   // out

	_list = make([]Plugin, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.WebKitPlugin)(v)
		var dst Plugin // out
		dst = *wrapPlugin(externglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// ProcessModel returns the current process model. For more information about
// this value see webkit_web_context_set_process_model().
func (context *WebContext) ProcessModel() ProcessModel {
	var _arg0 *C.WebKitWebContext  // out
	var _cret C.WebKitProcessModel // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_process_model(_arg0)
	runtime.KeepAlive(context)

	var _processModel ProcessModel // out

	_processModel = ProcessModel(_cret)

	return _processModel
}

// SandboxEnabled: get whether sandboxing is currently enabled.
func (context *WebContext) SandboxEnabled() bool {
	var _arg0 *C.WebKitWebContext // out
	var _cret C.gboolean          // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_sandbox_enabled(_arg0)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SecurityManager: get the KitSecurityManager of context.
func (context *WebContext) SecurityManager() *SecurityManager {
	var _arg0 *C.WebKitWebContext      // out
	var _cret *C.WebKitSecurityManager // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_security_manager(_arg0)
	runtime.KeepAlive(context)

	var _securityManager *SecurityManager // out

	_securityManager = wrapSecurityManager(externglib.Take(unsafe.Pointer(_cret)))

	return _securityManager
}

// SpellCheckingEnabled: get whether spell checking feature is currently
// enabled.
func (context *WebContext) SpellCheckingEnabled() bool {
	var _arg0 *C.WebKitWebContext // out
	var _cret C.gboolean          // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_spell_checking_enabled(_arg0)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SpellCheckingLanguages: get the the list of spell checking languages
// associated with context, or NULL if no languages have been previously set.
//
// See webkit_web_context_set_spell_checking_languages() for more details on the
// format of the languages in the list.
func (context *WebContext) SpellCheckingLanguages() []string {
	var _arg0 *C.WebKitWebContext // out
	var _cret **C.gchar           // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_spell_checking_languages(_arg0)
	runtime.KeepAlive(context)

	var _utf8s []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// TLSErrorsPolicy: get the TLS errors policy of context
//
// Deprecated: Use webkit_website_data_manager_get_tls_errors_policy() instead.
func (context *WebContext) TLSErrorsPolicy() TLSErrorsPolicy {
	var _arg0 *C.WebKitWebContext     // out
	var _cret C.WebKitTLSErrorsPolicy // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_tls_errors_policy(_arg0)
	runtime.KeepAlive(context)

	var _tlsErrorsPolicy TLSErrorsPolicy // out

	_tlsErrorsPolicy = TLSErrorsPolicy(_cret)

	return _tlsErrorsPolicy
}

// UseSystemAppearanceForScrollbars: get the
// KitWebContext:use-system-appearance-for-scrollbars property.
func (context *WebContext) UseSystemAppearanceForScrollbars() bool {
	var _arg0 *C.WebKitWebContext // out
	var _cret C.gboolean          // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_use_system_appearance_for_scrollbars(_arg0)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WebProcessCountLimit gets the maximum number of web processes that can be
// created at the same time for the context.
//
// This function is now deprecated and always returns 0 (no limit). See also
// webkit_web_context_set_web_process_count_limit().
//
// Deprecated: since version 2.26.
func (context *WebContext) WebProcessCountLimit() uint {
	var _arg0 *C.WebKitWebContext // out
	var _cret C.guint             // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_web_process_count_limit(_arg0)
	runtime.KeepAlive(context)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// WebsiteDataManager: get the KitWebsiteDataManager of context.
func (context *WebContext) WebsiteDataManager() *WebsiteDataManager {
	var _arg0 *C.WebKitWebContext         // out
	var _cret *C.WebKitWebsiteDataManager // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_website_data_manager(_arg0)
	runtime.KeepAlive(context)

	var _websiteDataManager *WebsiteDataManager // out

	_websiteDataManager = wrapWebsiteDataManager(externglib.Take(unsafe.Pointer(_cret)))

	return _websiteDataManager
}

// InitializeNotificationPermissions sets initial desktop notification
// permissions for the context. allowed_origins and disallowed_origins must each
// be #GList of KitSecurityOrigin objects representing origins that will,
// respectively, either always or never have permission to show desktop
// notifications. No KitNotificationPermissionRequest will ever be generated for
// any of the security origins represented in allowed_origins or
// disallowed_origins. This function is necessary because some webpages
// proactively check whether they have permission to display notifications
// without ever creating a permission request.
//
// This function only affects web processes that have not already been created.
// The best time to call it is when handling
// KitWebContext::initialize-notification-permissions so as to ensure that new
// web processes receive the most recent set of permissions.
//
// The function takes the following parameters:
//
//    - allowedOrigins of security origins.
//    - disallowedOrigins of security origins.
//
func (context *WebContext) InitializeNotificationPermissions(allowedOrigins, disallowedOrigins []*SecurityOrigin) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.GList            // out
	var _arg2 *C.GList            // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	for i := len(allowedOrigins) - 1; i >= 0; i-- {
		src := allowedOrigins[i]
		var dst *C.WebKitSecurityOrigin // out
		dst = (*C.WebKitSecurityOrigin)(gextras.StructNative(unsafe.Pointer(src)))
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg1)
	for i := len(disallowedOrigins) - 1; i >= 0; i-- {
		src := disallowedOrigins[i]
		var dst *C.WebKitSecurityOrigin // out
		dst = (*C.WebKitSecurityOrigin)(gextras.StructNative(unsafe.Pointer(src)))
		_arg2 = C.g_list_prepend(_arg2, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg2)

	C.webkit_web_context_initialize_notification_permissions(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(allowedOrigins)
	runtime.KeepAlive(disallowedOrigins)
}

// IsAutomationAllowed: get whether automation is allowed in context. See also
// webkit_web_context_set_automation_allowed().
func (context *WebContext) IsAutomationAllowed() bool {
	var _arg0 *C.WebKitWebContext // out
	var _cret C.gboolean          // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_is_automation_allowed(_arg0)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEphemeral: get whether a KitWebContext is ephemeral.
func (context *WebContext) IsEphemeral() bool {
	var _arg0 *C.WebKitWebContext // out
	var _cret C.gboolean          // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_is_ephemeral(_arg0)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PrefetchDns: resolve the domain name of the given hostname in advance, so
// that if a URI of hostname is requested the load will be performed more
// quickly.
//
// The function takes the following parameters:
//
//    - hostname to be resolved.
//
func (context *WebContext) PrefetchDns(hostname string) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))

	C.webkit_web_context_prefetch_dns(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(hostname)
}

// RegisterURIScheme: register scheme in context, so that when an URI request
// with scheme is made in the KitWebContext, the KitURISchemeRequestCallback
// registered will be called with a KitURISchemeRequest. It is possible to
// handle URI scheme requests asynchronously, by calling g_object_ref() on the
// KitURISchemeRequest and calling webkit_uri_scheme_request_finish() later when
// the data of the request is available or
// webkit_uri_scheme_request_finish_error() in case of error.
//
// <informalexample><programlisting> static void about_uri_scheme_request_cb
// (WebKitURISchemeRequest *request, gpointer user_data) { GInputStream *stream;
// gsize stream_length; const gchar *path;
//
//    path = webkit_uri_scheme_request_get_path (request);
//    if (!g_strcmp0 (path, "memory")) {
//        /<!-- -->* Create a GInputStream with the contents of memory about page, and set its length to stream_length *<!-- -->/
//    } else if (!g_strcmp0 (path, "applications")) {
//        /<!-- -->* Create a GInputStream with the contents of applications about page, and set its length to stream_length *<!-- -->/
//    } else if (!g_strcmp0 (path, "example")) {
//        gchar *contents;
//
//        contents = g_strdup_printf ("&lt;html&gt;&lt;body&gt;&lt;p&gt;Example about page&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;");
//        stream_length = strlen (contents);
//        stream = g_memory_input_stream_new_from_data (contents, stream_length, g_free);
//    } else {
//        GError *error;
//
//        error = g_error_new (ABOUT_HANDLER_ERROR, ABOUT_HANDLER_ERROR_INVALID, "Invalid about:s page.", path);
//        webkit_uri_scheme_request_finish_error (request, error);
//        g_error_free (error);
//        return;
//    }
//    webkit_uri_scheme_request_finish (request, stream, stream_length, "text/html");
//    g_object_unref (stream);
//
// } </programlisting></informalexample>.
//
// The function takes the following parameters:
//
//    - scheme: network scheme to register.
//    - callback: KitURISchemeRequestCallback.
//
func (context *WebContext) RegisterURIScheme(scheme string, callback URISchemeRequestCallback) {
	var _arg0 *C.WebKitWebContext              // out
	var _arg1 *C.gchar                         // out
	var _arg2 C.WebKitURISchemeRequestCallback // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*[0]byte)(C._gotk4_webkit24_URISchemeRequestCallback)
	_arg3 = C.gpointer(gbox.Assign(callback))
	_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.webkit_web_context_register_uri_scheme(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(context)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(callback)
}

// SendMessageToAllExtensions: send message to all KitWebExtension<!-- -->s
// associated to context. If message is floating, it's consumed.
//
// The function takes the following parameters:
//
//    - message: KitUserMessage.
//
func (context *WebContext) SendMessageToAllExtensions(message *UserMessage) {
	var _arg0 *C.WebKitWebContext  // out
	var _arg1 *C.WebKitUserMessage // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.WebKitUserMessage)(unsafe.Pointer(message.Native()))

	C.webkit_web_context_send_message_to_all_extensions(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(message)
}

// SetAdditionalPluginsDirectory: set an additional directory where WebKit will
// look for plugins.
//
// Deprecated: since version 2.32.
//
// The function takes the following parameters:
//
//    - directory to add.
//
func (context *WebContext) SetAdditionalPluginsDirectory(directory string) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(directory)))
	defer C.free(unsafe.Pointer(_arg1))

	C.webkit_web_context_set_additional_plugins_directory(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(directory)
}

// SetAutomationAllowed: set whether automation is allowed in context. When
// automation is enabled the browser could be controlled by another process by
// requesting an automation session. When a new automation session is requested
// the signal KitWebContext::automation-started is emitted. Automation is
// disabled by default, so you need to explicitly call this method passing TRUE
// to enable it.
//
// Note that only one KitWebContext can have automation enabled, so this will do
// nothing if there's another KitWebContext with automation already enabled.
//
// The function takes the following parameters:
//
//    - allowed: value to set.
//
func (context *WebContext) SetAutomationAllowed(allowed bool) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	if allowed {
		_arg1 = C.TRUE
	}

	C.webkit_web_context_set_automation_allowed(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(allowed)
}

// SetCacheModel specifies a usage model for WebViews, which WebKit will use to
// determine its caching behavior. All web views follow the cache model. This
// cache model determines the RAM and disk space to use for caching previously
// viewed content .
//
// Research indicates that users tend to browse within clusters of documents
// that hold resources in common, and to revisit previously visited documents.
// WebKit and the frameworks below it include built-in caches that take
// advantage of these patterns, substantially improving document load speed in
// browsing situations. The WebKit cache model controls the behaviors of all of
// these caches, including various WebCore caches.
//
// Browsers can improve document load speed substantially by specifying
// WEBKIT_CACHE_MODEL_WEB_BROWSER. Applications without a browsing interface can
// reduce memory usage substantially by specifying
// WEBKIT_CACHE_MODEL_DOCUMENT_VIEWER. The default value is
// WEBKIT_CACHE_MODEL_WEB_BROWSER.
//
// The function takes the following parameters:
//
//    - cacheModel: KitCacheModel.
//
func (context *WebContext) SetCacheModel(cacheModel CacheModel) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 C.WebKitCacheModel  // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = C.WebKitCacheModel(cacheModel)

	C.webkit_web_context_set_cache_model(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(cacheModel)
}

// SetDiskCacheDirectory: set the directory where disk cache files will be
// stored This method must be called before loading anything in this context,
// otherwise it will not have any effect.
//
// Note that this method overrides the directory set in the
// KitWebsiteDataManager, but it doesn't change the value returned by
// webkit_website_data_manager_get_disk_cache_directory() since the
// KitWebsiteDataManager is immutable.
//
// Deprecated: Use webkit_web_context_new_with_website_data_manager() instead.
//
// The function takes the following parameters:
//
//    - directory to set.
//
func (context *WebContext) SetDiskCacheDirectory(directory string) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(directory)))
	defer C.free(unsafe.Pointer(_arg1))

	C.webkit_web_context_set_disk_cache_directory(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(directory)
}

// SetFaviconDatabaseDirectory: set the directory path to be used to store the
// favicons database for context on disk. Passing NULL as path means using the
// default directory for the platform (see g_get_user_cache_dir()).
//
// Calling this method also means enabling the favicons database for its use
// from the applications, so that's why it's expected to be called only once.
// Further calls for the same instance of KitWebContext won't cause any effect.
//
// The function takes the following parameters:
//
//    - path: absolute path to the icon database directory or NULL to use the
//    defaults.
//
func (context *WebContext) SetFaviconDatabaseDirectory(path string) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	if path != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.webkit_web_context_set_favicon_database_directory(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(path)
}

// SetNetworkProxySettings: set the network proxy settings to be used by
// connections started in context. By default WEBKIT_NETWORK_PROXY_MODE_DEFAULT
// is used, which means that the system settings will be used
// (g_proxy_resolver_get_default()). If you want to override the system default
// settings, you can either use WEBKIT_NETWORK_PROXY_MODE_NO_PROXY to make sure
// no proxies are used at all, or WEBKIT_NETWORK_PROXY_MODE_CUSTOM to provide
// your own proxy settings. When proxy_mode is WEBKIT_NETWORK_PROXY_MODE_CUSTOM
// proxy_settings must be a valid KitNetworkProxySettings; otherwise,
// proxy_settings must be NULL.
//
// Deprecated: Use webkit_website_data_manager_set_network_proxy_settings()
// instead.
//
// The function takes the following parameters:
//
//    - proxyMode: KitNetworkProxyMode.
//    - proxySettings or NULL.
//
func (context *WebContext) SetNetworkProxySettings(proxyMode NetworkProxyMode, proxySettings *NetworkProxySettings) {
	var _arg0 *C.WebKitWebContext           // out
	var _arg1 C.WebKitNetworkProxyMode      // out
	var _arg2 *C.WebKitNetworkProxySettings // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = C.WebKitNetworkProxyMode(proxyMode)
	if proxySettings != nil {
		_arg2 = (*C.WebKitNetworkProxySettings)(gextras.StructNative(unsafe.Pointer(proxySettings)))
	}

	C.webkit_web_context_set_network_proxy_settings(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(proxyMode)
	runtime.KeepAlive(proxySettings)
}

// SetPreferredLanguages: set the list of preferred languages, sorted from most
// desirable to least desirable. The list will be used to build the
// "Accept-Language" header that will be included in the network requests
// started by the KitWebContext.
//
// The function takes the following parameters:
//
//    - languages: NULL-terminated list of language identifiers.
//
func (context *WebContext) SetPreferredLanguages(languages []string) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 **C.gchar           // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	{
		_arg1 = (**C.gchar)(C.malloc(C.size_t(uint((len(languages) + 1)) * uint(unsafe.Sizeof(uint(0))))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(languages)+1)
			var zero *C.gchar
			out[len(languages)] = zero
			for i := range languages {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(languages[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.webkit_web_context_set_preferred_languages(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(languages)
}

// SetProcessModel specifies a process model for WebViews, which WebKit will use
// to determine how auxiliary processes are handled.
//
// WEBKIT_PROCESS_MODEL_MULTIPLE_SECONDARY_PROCESSES will use one process per
// view most of the time, while still allowing for web views to share a process
// when needed (for example when different views interact with each other).
// Using this model, when a process hangs or crashes, only the WebViews using it
// stop working, while the rest of the WebViews in the application will still
// function normally.
//
// WEBKIT_PROCESS_MODEL_SHARED_SECONDARY_PROCESS is deprecated since 2.26, using
// it has no effect for security reasons.
//
// This method **must be called before any web process has been created**, as
// early as possible in your application. Calling it later will make your
// application crash.
//
// The function takes the following parameters:
//
//    - processModel: KitProcessModel.
//
func (context *WebContext) SetProcessModel(processModel ProcessModel) {
	var _arg0 *C.WebKitWebContext  // out
	var _arg1 C.WebKitProcessModel // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = C.WebKitProcessModel(processModel)

	C.webkit_web_context_set_process_model(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(processModel)
}

// SetSandboxEnabled: set whether WebKit subprocesses will be sandboxed,
// limiting access to the system.
//
// This method **must be called before any web process has been created**, as
// early as possible in your application. Calling it later is a fatal error.
//
// This is only implemented on Linux and is a no-op otherwise.
//
// The function takes the following parameters:
//
//    - enabled: if TRUE enable sandboxing.
//
func (context *WebContext) SetSandboxEnabled(enabled bool) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.webkit_web_context_set_sandbox_enabled(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(enabled)
}

// SetSpellCheckingEnabled: enable or disable the spell checking feature.
//
// The function takes the following parameters:
//
//    - enabled: value to be set.
//
func (context *WebContext) SetSpellCheckingEnabled(enabled bool) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.webkit_web_context_set_spell_checking_enabled(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(enabled)
}

// SetSpellCheckingLanguages: set the list of spell checking languages to be
// used for spell checking.
//
// The locale string typically is in the form lang_COUNTRY, where lang is an
// ISO-639 language code, and COUNTRY is an ISO-3166 country code. For instance,
// sv_FI for Swedish as written in Finland or pt_BR for Portuguese as written in
// Brazil.
//
// You need to call this function with a valid list of languages at least once
// in order to properly enable the spell checking feature in WebKit.
//
// The function takes the following parameters:
//
//    - languages: NULL-terminated list of spell checking languages.
//
func (context *WebContext) SetSpellCheckingLanguages(languages []string) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 **C.gchar           // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	{
		_arg1 = (**C.gchar)(C.malloc(C.size_t(uint((len(languages) + 1)) * uint(unsafe.Sizeof(uint(0))))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(languages)+1)
			var zero *C.gchar
			out[len(languages)] = zero
			for i := range languages {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(languages[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.webkit_web_context_set_spell_checking_languages(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(languages)
}

// SetTLSErrorsPolicy: set the TLS errors policy of context as policy
//
// Deprecated: Use webkit_website_data_manager_set_tls_errors_policy() instead.
//
// The function takes the following parameters:
//
//    - policy: KitTLSErrorsPolicy.
//
func (context *WebContext) SetTLSErrorsPolicy(policy TLSErrorsPolicy) {
	var _arg0 *C.WebKitWebContext     // out
	var _arg1 C.WebKitTLSErrorsPolicy // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = C.WebKitTLSErrorsPolicy(policy)

	C.webkit_web_context_set_tls_errors_policy(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(policy)
}

// SetUseSystemAppearanceForScrollbars: set the
// KitWebContext:use-system-appearance-for-scrollbars property.
//
// The function takes the following parameters:
//
//    - enabled: value to set.
//
func (context *WebContext) SetUseSystemAppearanceForScrollbars(enabled bool) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.webkit_web_context_set_use_system_appearance_for_scrollbars(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(enabled)
}

// SetWebExtensionsDirectory: set the directory where WebKit will look for Web
// Extensions. This method must be called before loading anything in this
// context, otherwise it will not have any effect. You can connect to
// KitWebContext::initialize-web-extensions to call this method before anything
// is loaded.
//
// The function takes the following parameters:
//
//    - directory to add.
//
func (context *WebContext) SetWebExtensionsDirectory(directory string) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(directory)))
	defer C.free(unsafe.Pointer(_arg1))

	C.webkit_web_context_set_web_extensions_directory(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(directory)
}

// SetWebExtensionsInitializationUserData: set user data to be passed to Web
// Extensions on initialization. The data will be passed to the
// KitWebExtensionInitializeWithUserDataFunction. This method must be called
// before loading anything in this context, otherwise it will not have any
// effect. You can connect to KitWebContext::initialize-web-extensions to call
// this method before anything is loaded.
//
// The function takes the following parameters:
//
//    - userData: #GVariant.
//
func (context *WebContext) SetWebExtensionsInitializationUserData(userData *glib.Variant) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.GVariant         // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(userData)))

	C.webkit_web_context_set_web_extensions_initialization_user_data(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(userData)
}

// SetWebProcessCountLimit sets the maximum number of web processes that can be
// created at the same time for the context. The default value is 0 and means no
// limit.
//
// This function is now deprecated and does nothing for security reasons.
//
// Deprecated: since version 2.26.
//
// The function takes the following parameters:
//
//    - limit: maximum number of web processes.
//
func (context *WebContext) SetWebProcessCountLimit(limit uint) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 C.guint             // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = C.guint(limit)

	C.webkit_web_context_set_web_process_count_limit(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(limit)
}

// ConnectAutomationStarted: this signal is emitted when a new automation
// request is made. Note that it will never be emitted if automation is not
// enabled in context, see webkit_web_context_set_automation_allowed() for more
// details.
func (context *WebContext) ConnectAutomationStarted(f func(session AutomationSession)) externglib.SignalHandle {
	return context.Connect("automation-started", f)
}

// ConnectDownloadStarted: this signal is emitted when a new download request is
// made.
func (context *WebContext) ConnectDownloadStarted(f func(download Download)) externglib.SignalHandle {
	return context.Connect("download-started", f)
}

// ConnectInitializeNotificationPermissions: this signal is emitted when a
// KitWebContext needs to set initial notification permissions for a web
// process. It is emitted when a new web process is about to be launched, and
// signals the most appropriate moment to use
// webkit_web_context_initialize_notification_permissions(). If no notification
// permissions have changed since the last time this signal was emitted, then
// there is no need to call
// webkit_web_context_initialize_notification_permissions() again.
func (context *WebContext) ConnectInitializeNotificationPermissions(f func()) externglib.SignalHandle {
	return context.Connect("initialize-notification-permissions", f)
}

// ConnectInitializeWebExtensions: this signal is emitted when a new web process
// is about to be launched. It signals the most appropriate moment to use
// webkit_web_context_set_web_extensions_initialization_user_data() and
// webkit_web_context_set_web_extensions_directory().
func (context *WebContext) ConnectInitializeWebExtensions(f func()) externglib.SignalHandle {
	return context.Connect("initialize-web-extensions", f)
}

// ConnectUserMessageReceived: this signal is emitted when a KitUserMessage is
// received from a KitWebExtension. You can reply to the message using
// webkit_user_message_send_reply().
//
// You can handle the user message asynchronously by calling g_object_ref() on
// message and returning TRUE.
func (context *WebContext) ConnectUserMessageReceived(f func(message UserMessage) bool) externglib.SignalHandle {
	return context.Connect("user-message-received", f)
}

// WebContextGetDefault gets the default web context.
func WebContextGetDefault() *WebContext {
	var _cret *C.WebKitWebContext // in

	_cret = C.webkit_web_context_get_default()

	var _webContext *WebContext // out

	_webContext = wrapWebContext(externglib.Take(unsafe.Pointer(_cret)))

	return _webContext
}
