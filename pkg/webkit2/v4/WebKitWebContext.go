// Code generated by girgen. DO NOT EDIT.

package webkit2

import (
	"context"
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: webkit2gtk-4.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <webkit2/webkit2.h>
// extern void callbackDelete(gpointer);
// void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
// void _gotk4_webkit24_URISchemeRequestCallback(WebKitURISchemeRequest*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.webkit_cache_model_get_type()), F: marshalCacheModel},
		{T: externglib.Type(C.webkit_process_model_get_type()), F: marshalProcessModel},
		{T: externglib.Type(C.webkit_web_context_get_type()), F: marshalWebContexter},
	})
}

// CacheModel: enum values used for determining the KitWebContext cache model.
type CacheModel int

const (
	// CacheModelDocumentViewer: disable the cache completely, which
	// substantially reduces memory usage. Useful for applications that only
	// access a single local file, with no navigation to other pages. No remote
	// resources will be cached.
	CacheModelDocumentViewer CacheModel = iota
	// CacheModelWebBrowser: improve document load speed substantially by
	// caching a very large number of resources and previously viewed content.
	CacheModelWebBrowser
	// CacheModelDocumentBrowser: cache model optimized for viewing a series of
	// local files -- for example, a documentation viewer or a website designer.
	// WebKit will cache a moderate number of resources.
	CacheModelDocumentBrowser
)

func marshalCacheModel(p uintptr) (interface{}, error) {
	return CacheModel(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for CacheModel.
func (c CacheModel) String() string {
	switch c {
	case CacheModelDocumentViewer:
		return "DocumentViewer"
	case CacheModelWebBrowser:
		return "WebBrowser"
	case CacheModelDocumentBrowser:
		return "DocumentBrowser"
	default:
		return fmt.Sprintf("CacheModel(%d)", c)
	}
}

// ProcessModel: enum values used for determining the KitWebContext process
// model.
type ProcessModel int

const (
	// ProcessModelSharedSecondaryProcess: deprecated 2.26.
	ProcessModelSharedSecondaryProcess ProcessModel = iota
	// ProcessModelMultipleSecondaryProcesses: use one process for each
	// KitWebView, while still allowing for some of them to share a process in
	// certain situations. The main advantage of this process model is that the
	// rendering process for a web view can crash while the rest of the views
	// keep working normally. This process model is indicated for applications
	// which may use a number of web views and the content of in each must not
	// interfere with the rest â€” for example a full-fledged web browser with
	// support for multiple tabs.
	ProcessModelMultipleSecondaryProcesses
)

func marshalProcessModel(p uintptr) (interface{}, error) {
	return ProcessModel(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for ProcessModel.
func (p ProcessModel) String() string {
	switch p {
	case ProcessModelSharedSecondaryProcess:
		return "SharedSecondaryProcess"
	case ProcessModelMultipleSecondaryProcesses:
		return "MultipleSecondaryProcesses"
	default:
		return fmt.Sprintf("ProcessModel(%d)", p)
	}
}

// URISchemeRequestCallback: type definition for a function that will be called
// back when an URI request is made for a user registered URI scheme.
type URISchemeRequestCallback func(request *URISchemeRequest)

//export _gotk4_webkit24_URISchemeRequestCallback
func _gotk4_webkit24_URISchemeRequestCallback(arg0 *C.WebKitURISchemeRequest, arg1 C.gpointer) {
	v := gbox.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var request *URISchemeRequest // out

	request = wrapURISchemeRequest(externglib.Take(unsafe.Pointer(arg0)))

	fn := v.(URISchemeRequestCallback)
	fn(request)
}

// WebContextOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type WebContextOverrider interface {
	AutomationStarted(session *AutomationSession)
	DownloadStarted(download *Download)
	InitializeNotificationPermissions()
	InitializeWebExtensions()
	UserMessageReceived(message *UserMessage) bool
}

type WebContext struct {
	*externglib.Object
}

var _ gextras.Nativer = (*WebContext)(nil)

func wrapWebContext(obj *externglib.Object) *WebContext {
	return &WebContext{
		Object: obj,
	}
}

func marshalWebContexter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWebContext(obj), nil
}

// NewWebContext: create a new KitWebContext
func NewWebContext() *WebContext {
	var _cret *C.WebKitWebContext // in

	_cret = C.webkit_web_context_new()

	var _webContext *WebContext // out

	_webContext = wrapWebContext(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _webContext
}

// NewWebContextEphemeral: create a new ephemeral KitWebContext. An ephemeral
// KitWebContext is a context created with an ephemeral KitWebsiteDataManager.
// This is just a convenient method to create ephemeral contexts without having
// to create your own KitWebsiteDataManager. All KitWebView<!-- -->s associated
// with this context will also be ephemeral. Websites will not store any data in
// the client storage. This is normally used to implement private instances.
func NewWebContextEphemeral() *WebContext {
	var _cret *C.WebKitWebContext // in

	_cret = C.webkit_web_context_new_ephemeral()

	var _webContext *WebContext // out

	_webContext = wrapWebContext(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _webContext
}

// NewWebContextWithWebsiteDataManager: create a new KitWebContext with a
// KitWebsiteDataManager.
func NewWebContextWithWebsiteDataManager(manager *WebsiteDataManager) *WebContext {
	var _arg1 *C.WebKitWebsiteDataManager // out
	var _cret *C.WebKitWebContext         // in

	_arg1 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))

	_cret = C.webkit_web_context_new_with_website_data_manager(_arg1)

	var _webContext *WebContext // out

	_webContext = wrapWebContext(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _webContext
}

// AddPathToSandbox adds a path to be mounted in the sandbox. path must exist
// before any web process has been created otherwise it will be silently
// ignored. It is a fatal error to add paths after a web process has been
// spawned.
//
// Paths in directories such as /sys, /proc, and /dev or all of / are not valid.
//
// See also webkit_web_context_set_sandbox_enabled()
func (context *WebContext) AddPathToSandbox(path string, readOnly bool) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.char             // out
	var _arg2 C.gboolean          // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	if readOnly {
		_arg2 = C.TRUE
	}

	C.webkit_web_context_add_path_to_sandbox(_arg0, _arg1, _arg2)
}

// AllowTLSCertificateForHost: ignore further TLS errors on the host for the
// certificate present in info.
func (context *WebContext) AllowTLSCertificateForHost(certificate gio.TLSCertificater, host string) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.GTlsCertificate  // out
	var _arg2 *C.gchar            // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer((certificate).(gextras.Nativer).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(host)))

	C.webkit_web_context_allow_tls_certificate_for_host(_arg0, _arg1, _arg2)
}

// ClearCache clears all resources currently cached. See also
// webkit_web_context_set_cache_model().
func (context *WebContext) ClearCache() {
	var _arg0 *C.WebKitWebContext // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	C.webkit_web_context_clear_cache(_arg0)
}

// DownloadURI requests downloading of the specified URI string. The download
// operation will not be associated to any KitWebView, if you are interested in
// starting a download from a particular KitWebView use
// webkit_web_view_download_uri() instead.
func (context *WebContext) DownloadURI(uri string) *Download {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.gchar            // out
	var _cret *C.WebKitDownload   // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))

	_cret = C.webkit_web_context_download_uri(_arg0, _arg1)

	var _download *Download // out

	_download = wrapDownload(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _download
}

// CacheModel returns the current cache model. For more information about this
// value check the documentation of the function
// webkit_web_context_set_cache_model().
func (context *WebContext) CacheModel() CacheModel {
	var _arg0 *C.WebKitWebContext // out
	var _cret C.WebKitCacheModel  // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_cache_model(_arg0)

	var _cacheModel CacheModel // out

	_cacheModel = CacheModel(_cret)

	return _cacheModel
}

// CookieManager: get the KitCookieManager of the context's
// KitWebsiteDataManager.
func (context *WebContext) CookieManager() *CookieManager {
	var _arg0 *C.WebKitWebContext    // out
	var _cret *C.WebKitCookieManager // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_cookie_manager(_arg0)

	var _cookieManager *CookieManager // out

	_cookieManager = wrapCookieManager(externglib.Take(unsafe.Pointer(_cret)))

	return _cookieManager
}

// FaviconDatabase: get the KitFaviconDatabase associated with context.
//
// To initialize the database you need to call
// webkit_web_context_set_favicon_database_directory().
func (context *WebContext) FaviconDatabase() *FaviconDatabase {
	var _arg0 *C.WebKitWebContext      // out
	var _cret *C.WebKitFaviconDatabase // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_favicon_database(_arg0)

	var _faviconDatabase *FaviconDatabase // out

	_faviconDatabase = wrapFaviconDatabase(externglib.Take(unsafe.Pointer(_cret)))

	return _faviconDatabase
}

// FaviconDatabaseDirectory: get the directory path being used to store the
// favicons database for context, or NULL if
// webkit_web_context_set_favicon_database_directory() hasn't been called yet.
//
// This function will always return the same path after having called
// webkit_web_context_set_favicon_database_directory() for the first time.
func (context *WebContext) FaviconDatabaseDirectory() string {
	var _arg0 *C.WebKitWebContext // out
	var _cret *C.gchar            // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_favicon_database_directory(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// GeolocationManager: get the KitGeolocationManager of context.
func (context *WebContext) GeolocationManager() *GeolocationManager {
	var _arg0 *C.WebKitWebContext         // out
	var _cret *C.WebKitGeolocationManager // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_geolocation_manager(_arg0)

	var _geolocationManager *GeolocationManager // out

	_geolocationManager = wrapGeolocationManager(externglib.Take(unsafe.Pointer(_cret)))

	return _geolocationManager
}

// Plugins: asynchronously get the list of installed plugins.
//
// When the operation is finished, callback will be called. You can then call
// webkit_web_context_get_plugins_finish() to get the result of the operation.
//
// Deprecated: since version 2.32.
func (context *WebContext) Plugins(ctx context.Context, callback gio.AsyncReadyCallback) {
	var _arg0 *C.WebKitWebContext   // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg3 = C.gpointer(gbox.AssignOnce(callback))

	C.webkit_web_context_get_plugins(_arg0, _arg1, _arg2, _arg3)
}

// PluginsFinish: finish an asynchronous operation started with
// webkit_web_context_get_plugins.
//
// Deprecated: since version 2.32.
func (context *WebContext) PluginsFinish(result gio.AsyncResulter) (*externglib.List, error) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.GAsyncResult     // out
	var _cret *C.GList            // in
	var _cerr *C.GError           // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((result).(gextras.Nativer).Native()))

	_cret = C.webkit_web_context_get_plugins_finish(_arg0, _arg1, &_cerr)

	var _list *externglib.List // out
	var _goerr error           // out

	_list = externglib.WrapList(uintptr(unsafe.Pointer(_cret)))
	_list.DataWrapper(func(_p unsafe.Pointer) interface{} {
		src := (*C.WebKitPlugin)(_p)
		var dst Plugin // out
		dst = *wrapPlugin(externglib.AssumeOwnership(unsafe.Pointer(src)))
		return dst
	})
	_list.AttachFinalizer(func(v uintptr) {
		C.g_object_unref(C.gpointer(uintptr(unsafe.Pointer(v))))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _list, _goerr
}

// ProcessModel returns the current process model. For more information about
// this value see webkit_web_context_set_process_model().
func (context *WebContext) ProcessModel() ProcessModel {
	var _arg0 *C.WebKitWebContext  // out
	var _cret C.WebKitProcessModel // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_process_model(_arg0)

	var _processModel ProcessModel // out

	_processModel = ProcessModel(_cret)

	return _processModel
}

// SandboxEnabled: get whether sandboxing is currently enabled.
func (context *WebContext) SandboxEnabled() bool {
	var _arg0 *C.WebKitWebContext // out
	var _cret C.gboolean          // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_sandbox_enabled(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SecurityManager: get the KitSecurityManager of context.
func (context *WebContext) SecurityManager() *SecurityManager {
	var _arg0 *C.WebKitWebContext      // out
	var _cret *C.WebKitSecurityManager // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_security_manager(_arg0)

	var _securityManager *SecurityManager // out

	_securityManager = wrapSecurityManager(externglib.Take(unsafe.Pointer(_cret)))

	return _securityManager
}

// SpellCheckingEnabled: get whether spell checking feature is currently
// enabled.
func (context *WebContext) SpellCheckingEnabled() bool {
	var _arg0 *C.WebKitWebContext // out
	var _cret C.gboolean          // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_spell_checking_enabled(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SpellCheckingLanguages: get the the list of spell checking languages
// associated with context, or NULL if no languages have been previously set.
//
// See webkit_web_context_set_spell_checking_languages() for more details on the
// format of the languages in the list.
func (context *WebContext) SpellCheckingLanguages() []string {
	var _arg0 *C.WebKitWebContext // out
	var _cret **C.gchar

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_spell_checking_languages(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// TLSErrorsPolicy: get the TLS errors policy of context
//
// Deprecated: Use webkit_website_data_manager_get_tls_errors_policy() instead.
func (context *WebContext) TLSErrorsPolicy() TLSErrorsPolicy {
	var _arg0 *C.WebKitWebContext     // out
	var _cret C.WebKitTLSErrorsPolicy // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_tls_errors_policy(_arg0)

	var _tlsErrorsPolicy TLSErrorsPolicy // out

	_tlsErrorsPolicy = TLSErrorsPolicy(_cret)

	return _tlsErrorsPolicy
}

// UseSystemAppearanceForScrollbars: get the
// KitWebContext:use-system-appearance-for-scrollbars property.
func (context *WebContext) UseSystemAppearanceForScrollbars() bool {
	var _arg0 *C.WebKitWebContext // out
	var _cret C.gboolean          // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_use_system_appearance_for_scrollbars(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WebProcessCountLimit gets the maximum number of web processes that can be
// created at the same time for the context.
//
// This function is now deprecated and always returns 0 (no limit). See also
// webkit_web_context_set_web_process_count_limit().
//
// Deprecated: since version 2.26.
func (context *WebContext) WebProcessCountLimit() uint {
	var _arg0 *C.WebKitWebContext // out
	var _cret C.guint             // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_web_process_count_limit(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// WebsiteDataManager: get the KitWebsiteDataManager of context.
func (context *WebContext) WebsiteDataManager() *WebsiteDataManager {
	var _arg0 *C.WebKitWebContext         // out
	var _cret *C.WebKitWebsiteDataManager // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_get_website_data_manager(_arg0)

	var _websiteDataManager *WebsiteDataManager // out

	_websiteDataManager = wrapWebsiteDataManager(externglib.Take(unsafe.Pointer(_cret)))

	return _websiteDataManager
}

// IsAutomationAllowed: get whether automation is allowed in context. See also
// webkit_web_context_set_automation_allowed().
func (context *WebContext) IsAutomationAllowed() bool {
	var _arg0 *C.WebKitWebContext // out
	var _cret C.gboolean          // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_is_automation_allowed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEphemeral: get whether a KitWebContext is ephemeral.
func (context *WebContext) IsEphemeral() bool {
	var _arg0 *C.WebKitWebContext // out
	var _cret C.gboolean          // in

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_context_is_ephemeral(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PrefetchDns: resolve the domain name of the given hostname in advance, so
// that if a URI of hostname is requested the load will be performed more
// quickly.
func (context *WebContext) PrefetchDns(hostname string) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))

	C.webkit_web_context_prefetch_dns(_arg0, _arg1)
}

// RegisterURIScheme: register scheme in context, so that when an URI request
// with scheme is made in the KitWebContext, the KitURISchemeRequestCallback
// registered will be called with a KitURISchemeRequest. It is possible to
// handle URI scheme requests asynchronously, by calling g_object_ref() on the
// KitURISchemeRequest and calling webkit_uri_scheme_request_finish() later when
// the data of the request is available or
// webkit_uri_scheme_request_finish_error() in case of error.
//
// <informalexample><programlisting> static void about_uri_scheme_request_cb
// (WebKitURISchemeRequest *request, gpointer user_data) { GInputStream *stream;
// gsize stream_length; const gchar *path;
//
//    path = webkit_uri_scheme_request_get_path (request);
//    if (!g_strcmp0 (path, "memory")) {
//        /<!-- -->* Create a GInputStream with the contents of memory about page, and set its length to stream_length *<!-- -->/
//    } else if (!g_strcmp0 (path, "applications")) {
//        /<!-- -->* Create a GInputStream with the contents of applications about page, and set its length to stream_length *<!-- -->/
//    } else if (!g_strcmp0 (path, "example")) {
//        gchar *contents;
//
//        contents = g_strdup_printf ("&lt;html&gt;&lt;body&gt;&lt;p&gt;Example about page&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;");
//        stream_length = strlen (contents);
//        stream = g_memory_input_stream_new_from_data (contents, stream_length, g_free);
//    } else {
//        GError *error;
//
//        error = g_error_new (ABOUT_HANDLER_ERROR, ABOUT_HANDLER_ERROR_INVALID, "Invalid about:s page.", path);
//        webkit_uri_scheme_request_finish_error (request, error);
//        g_error_free (error);
//        return;
//    }
//    webkit_uri_scheme_request_finish (request, stream, stream_length, "text/html");
//    g_object_unref (stream);
//
// } </programlisting></informalexample>
func (context *WebContext) RegisterURIScheme(scheme string, callback URISchemeRequestCallback) {
	var _arg0 *C.WebKitWebContext              // out
	var _arg1 *C.gchar                         // out
	var _arg2 C.WebKitURISchemeRequestCallback // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
	_arg2 = (*[0]byte)(C._gotk4_webkit24_URISchemeRequestCallback)
	_arg3 = C.gpointer(gbox.Assign(callback))
	_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.webkit_web_context_register_uri_scheme(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// SendMessageToAllExtensions: send message to all KitWebExtension<!-- -->s
// associated to context. If message is floating, it's consumed.
func (context *WebContext) SendMessageToAllExtensions(message *UserMessage) {
	var _arg0 *C.WebKitWebContext  // out
	var _arg1 *C.WebKitUserMessage // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.WebKitUserMessage)(unsafe.Pointer(message.Native()))

	C.webkit_web_context_send_message_to_all_extensions(_arg0, _arg1)
}

// SetAdditionalPluginsDirectory: set an additional directory where WebKit will
// look for plugins.
//
// Deprecated: since version 2.32.
func (context *WebContext) SetAdditionalPluginsDirectory(directory string) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(directory)))

	C.webkit_web_context_set_additional_plugins_directory(_arg0, _arg1)
}

// SetAutomationAllowed: set whether automation is allowed in context. When
// automation is enabled the browser could be controlled by another process by
// requesting an automation session. When a new automation session is requested
// the signal KitWebContext::automation-started is emitted. Automation is
// disabled by default, so you need to explicitly call this method passing TRUE
// to enable it.
//
// Note that only one KitWebContext can have automation enabled, so this will do
// nothing if there's another KitWebContext with automation already enabled.
func (context *WebContext) SetAutomationAllowed(allowed bool) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	if allowed {
		_arg1 = C.TRUE
	}

	C.webkit_web_context_set_automation_allowed(_arg0, _arg1)
}

// SetCacheModel specifies a usage model for WebViews, which WebKit will use to
// determine its caching behavior. All web views follow the cache model. This
// cache model determines the RAM and disk space to use for caching previously
// viewed content .
//
// Research indicates that users tend to browse within clusters of documents
// that hold resources in common, and to revisit previously visited documents.
// WebKit and the frameworks below it include built-in caches that take
// advantage of these patterns, substantially improving document load speed in
// browsing situations. The WebKit cache model controls the behaviors of all of
// these caches, including various WebCore caches.
//
// Browsers can improve document load speed substantially by specifying
// WEBKIT_CACHE_MODEL_WEB_BROWSER. Applications without a browsing interface can
// reduce memory usage substantially by specifying
// WEBKIT_CACHE_MODEL_DOCUMENT_VIEWER. The default value is
// WEBKIT_CACHE_MODEL_WEB_BROWSER.
func (context *WebContext) SetCacheModel(cacheModel CacheModel) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 C.WebKitCacheModel  // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = C.WebKitCacheModel(cacheModel)

	C.webkit_web_context_set_cache_model(_arg0, _arg1)
}

// SetDiskCacheDirectory: set the directory where disk cache files will be
// stored This method must be called before loading anything in this context,
// otherwise it will not have any effect.
//
// Note that this method overrides the directory set in the
// KitWebsiteDataManager, but it doesn't change the value returned by
// webkit_website_data_manager_get_disk_cache_directory() since the
// KitWebsiteDataManager is immutable.
//
// Deprecated: Use webkit_web_context_new_with_website_data_manager() instead.
func (context *WebContext) SetDiskCacheDirectory(directory string) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(directory)))

	C.webkit_web_context_set_disk_cache_directory(_arg0, _arg1)
}

// SetFaviconDatabaseDirectory: set the directory path to be used to store the
// favicons database for context on disk. Passing NULL as path means using the
// default directory for the platform (see g_get_user_cache_dir()).
//
// Calling this method also means enabling the favicons database for its use
// from the applications, so that's why it's expected to be called only once.
// Further calls for the same instance of KitWebContext won't cause any effect.
func (context *WebContext) SetFaviconDatabaseDirectory(path string) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))

	C.webkit_web_context_set_favicon_database_directory(_arg0, _arg1)
}

// SetNetworkProxySettings: set the network proxy settings to be used by
// connections started in context. By default WEBKIT_NETWORK_PROXY_MODE_DEFAULT
// is used, which means that the system settings will be used
// (g_proxy_resolver_get_default()). If you want to override the system default
// settings, you can either use WEBKIT_NETWORK_PROXY_MODE_NO_PROXY to make sure
// no proxies are used at all, or WEBKIT_NETWORK_PROXY_MODE_CUSTOM to provide
// your own proxy settings. When proxy_mode is WEBKIT_NETWORK_PROXY_MODE_CUSTOM
// proxy_settings must be a valid KitNetworkProxySettings; otherwise,
// proxy_settings must be NULL.
//
// Deprecated: Use webkit_website_data_manager_set_network_proxy_settings()
// instead.
func (context *WebContext) SetNetworkProxySettings(proxyMode NetworkProxyMode, proxySettings *NetworkProxySettings) {
	var _arg0 *C.WebKitWebContext           // out
	var _arg1 C.WebKitNetworkProxyMode      // out
	var _arg2 *C.WebKitNetworkProxySettings // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = C.WebKitNetworkProxyMode(proxyMode)
	_arg2 = (*C.WebKitNetworkProxySettings)(gextras.StructNative(unsafe.Pointer(proxySettings)))

	C.webkit_web_context_set_network_proxy_settings(_arg0, _arg1, _arg2)
}

// SetPreferredLanguages: set the list of preferred languages, sorted from most
// desirable to least desirable. The list will be used to build the
// "Accept-Language" header that will be included in the network requests
// started by the KitWebContext.
func (context *WebContext) SetPreferredLanguages(languages []string) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 **C.gchar

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	{
		_arg1 = (**C.gchar)(C.malloc(C.ulong(len(languages)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
		{
			out := unsafe.Slice(_arg1, len(languages)+1)
			var zero *C.gchar
			out[len(languages)] = zero
			for i := range languages {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(languages[i])))
			}
		}
	}

	C.webkit_web_context_set_preferred_languages(_arg0, _arg1)
}

// SetProcessModel specifies a process model for WebViews, which WebKit will use
// to determine how auxiliary processes are handled.
//
// WEBKIT_PROCESS_MODEL_MULTIPLE_SECONDARY_PROCESSES will use one process per
// view most of the time, while still allowing for web views to share a process
// when needed (for example when different views interact with each other).
// Using this model, when a process hangs or crashes, only the WebViews using it
// stop working, while the rest of the WebViews in the application will still
// function normally.
//
// WEBKIT_PROCESS_MODEL_SHARED_SECONDARY_PROCESS is deprecated since 2.26, using
// it has no effect for security reasons.
//
// This method **must be called before any web process has been created**, as
// early as possible in your application. Calling it later will make your
// application crash.
func (context *WebContext) SetProcessModel(processModel ProcessModel) {
	var _arg0 *C.WebKitWebContext  // out
	var _arg1 C.WebKitProcessModel // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = C.WebKitProcessModel(processModel)

	C.webkit_web_context_set_process_model(_arg0, _arg1)
}

// SetSandboxEnabled: set whether WebKit subprocesses will be sandboxed,
// limiting access to the system.
//
// This method **must be called before any web process has been created**, as
// early as possible in your application. Calling it later is a fatal error.
//
// This is only implemented on Linux and is a no-op otherwise.
func (context *WebContext) SetSandboxEnabled(enabled bool) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.webkit_web_context_set_sandbox_enabled(_arg0, _arg1)
}

// SetSpellCheckingEnabled: enable or disable the spell checking feature.
func (context *WebContext) SetSpellCheckingEnabled(enabled bool) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.webkit_web_context_set_spell_checking_enabled(_arg0, _arg1)
}

// SetSpellCheckingLanguages: set the list of spell checking languages to be
// used for spell checking.
//
// The locale string typically is in the form lang_COUNTRY, where lang is an
// ISO-639 language code, and COUNTRY is an ISO-3166 country code. For instance,
// sv_FI for Swedish as written in Finland or pt_BR for Portuguese as written in
// Brazil.
//
// You need to call this function with a valid list of languages at least once
// in order to properly enable the spell checking feature in WebKit.
func (context *WebContext) SetSpellCheckingLanguages(languages []string) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 **C.gchar

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	{
		_arg1 = (**C.gchar)(C.malloc(C.ulong(len(languages)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
		{
			out := unsafe.Slice(_arg1, len(languages)+1)
			var zero *C.gchar
			out[len(languages)] = zero
			for i := range languages {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(languages[i])))
			}
		}
	}

	C.webkit_web_context_set_spell_checking_languages(_arg0, _arg1)
}

// SetTLSErrorsPolicy: set the TLS errors policy of context as policy
//
// Deprecated: Use webkit_website_data_manager_set_tls_errors_policy() instead.
func (context *WebContext) SetTLSErrorsPolicy(policy TLSErrorsPolicy) {
	var _arg0 *C.WebKitWebContext     // out
	var _arg1 C.WebKitTLSErrorsPolicy // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = C.WebKitTLSErrorsPolicy(policy)

	C.webkit_web_context_set_tls_errors_policy(_arg0, _arg1)
}

// SetUseSystemAppearanceForScrollbars: set the
// KitWebContext:use-system-appearance-for-scrollbars property.
func (context *WebContext) SetUseSystemAppearanceForScrollbars(enabled bool) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.webkit_web_context_set_use_system_appearance_for_scrollbars(_arg0, _arg1)
}

// SetWebExtensionsDirectory: set the directory where WebKit will look for Web
// Extensions. This method must be called before loading anything in this
// context, otherwise it will not have any effect. You can connect to
// KitWebContext::initialize-web-extensions to call this method before anything
// is loaded.
func (context *WebContext) SetWebExtensionsDirectory(directory string) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(directory)))

	C.webkit_web_context_set_web_extensions_directory(_arg0, _arg1)
}

// SetWebExtensionsInitializationUserData: set user data to be passed to Web
// Extensions on initialization. The data will be passed to the
// KitWebExtensionInitializeWithUserDataFunction. This method must be called
// before loading anything in this context, otherwise it will not have any
// effect. You can connect to KitWebContext::initialize-web-extensions to call
// this method before anything is loaded.
func (context *WebContext) SetWebExtensionsInitializationUserData(userData *glib.Variant) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 *C.GVariant         // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(userData)))

	C.webkit_web_context_set_web_extensions_initialization_user_data(_arg0, _arg1)
}

// SetWebProcessCountLimit sets the maximum number of web processes that can be
// created at the same time for the context. The default value is 0 and means no
// limit.
//
// This function is now deprecated and does nothing for security reasons.
//
// Deprecated: since version 2.26.
func (context *WebContext) SetWebProcessCountLimit(limit uint) {
	var _arg0 *C.WebKitWebContext // out
	var _arg1 C.guint             // out

	_arg0 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))
	_arg1 = C.guint(limit)

	C.webkit_web_context_set_web_process_count_limit(_arg0, _arg1)
}

// WebContextGetDefault gets the default web context
func WebContextGetDefault() *WebContext {
	var _cret *C.WebKitWebContext // in

	_cret = C.webkit_web_context_get_default()

	var _webContext *WebContext // out

	_webContext = wrapWebContext(externglib.Take(unsafe.Pointer(_cret)))

	return _webContext
}
