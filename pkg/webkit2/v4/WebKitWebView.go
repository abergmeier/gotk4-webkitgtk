// Code generated by girgen. DO NOT EDIT.

package webkit2

import (
	"context"
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/gtk/v3"
)

// #cgo pkg-config: webkit2gtk-4.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <webkit2/webkit2.h>
// void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.webkit_insecure_content_event_get_type()), F: marshalInsecureContentEvent},
		{T: externglib.Type(C.webkit_load_event_get_type()), F: marshalLoadEvent},
		{T: externglib.Type(C.webkit_policy_decision_type_get_type()), F: marshalPolicyDecisionType},
		{T: externglib.Type(C.webkit_save_mode_get_type()), F: marshalSaveMode},
		{T: externglib.Type(C.webkit_snapshot_region_get_type()), F: marshalSnapshotRegion},
		{T: externglib.Type(C.webkit_web_process_termination_reason_get_type()), F: marshalWebProcessTerminationReason},
		{T: externglib.Type(C.webkit_snapshot_options_get_type()), F: marshalSnapshotOptions},
		{T: externglib.Type(C.webkit_web_view_get_type()), F: marshalWebViewer},
	})
}

// InsecureContentEvent: enum values used to denote the different events which
// can trigger the detection of insecure content.
type InsecureContentEvent C.gint

const (
	// InsecureContentRun: insecure content has been detected by trying to
	// execute any kind of logic (e.g. a script) from an untrusted source.
	InsecureContentRun InsecureContentEvent = iota
	// InsecureContentDisplayed: insecure content has been detected by trying to
	// display any kind of resource (e.g. an image) from an untrusted source.
	InsecureContentDisplayed
)

func marshalInsecureContentEvent(p uintptr) (interface{}, error) {
	return InsecureContentEvent(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for InsecureContentEvent.
func (i InsecureContentEvent) String() string {
	switch i {
	case InsecureContentRun:
		return "Run"
	case InsecureContentDisplayed:
		return "Displayed"
	default:
		return fmt.Sprintf("InsecureContentEvent(%d)", i)
	}
}

// LoadEvent: enum values used to denote the different events that happen during
// a KitWebView load operation.
type LoadEvent C.gint

const (
	// LoadStarted: new load request has been made. No data has been received
	// yet, empty structures have been allocated to perform the load; the load
	// may still fail due to transport issues such as not being able to resolve
	// a name, or connect to a port.
	LoadStarted LoadEvent = iota
	// LoadRedirected: provisional data source received a server redirect.
	LoadRedirected
	// LoadCommitted: content started arriving for a page load. The necessary
	// transport requirements are established, and the load is being performed.
	LoadCommitted
	// LoadFinished: load completed. All resources are done loading or there was
	// an error during the load operation.
	LoadFinished
)

func marshalLoadEvent(p uintptr) (interface{}, error) {
	return LoadEvent(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for LoadEvent.
func (l LoadEvent) String() string {
	switch l {
	case LoadStarted:
		return "Started"
	case LoadRedirected:
		return "Redirected"
	case LoadCommitted:
		return "Committed"
	case LoadFinished:
		return "Finished"
	default:
		return fmt.Sprintf("LoadEvent(%d)", l)
	}
}

// PolicyDecisionType: enum values used for determining the type of a policy
// decision during KitWebView::decide-policy.
type PolicyDecisionType C.gint

const (
	// PolicyDecisionTypeNavigationAction: this type of policy decision is
	// requested when WebKit is about to navigate to a new page in either the
	// main frame or a subframe. Acceptable policy decisions are either
	// webkit_policy_decision_use() or webkit_policy_decision_ignore(). This
	// type of policy decision is always a KitNavigationPolicyDecision.
	PolicyDecisionTypeNavigationAction PolicyDecisionType = iota
	// PolicyDecisionTypeNewWindowAction: this type of policy decision is
	// requested when WebKit is about to create a new window. Acceptable policy
	// decisions are either webkit_policy_decision_use() or
	// webkit_policy_decision_ignore(). This type of policy decision is always a
	// KitNavigationPolicyDecision. These decisions are useful for implementing
	// special actions for new windows, such as forcing the new window to open
	// in a tab when a keyboard modifier is active or handling a special target
	// attribute on &lt;a&gt; elements.
	PolicyDecisionTypeNewWindowAction
	// PolicyDecisionTypeResponse: this type of decision is used when WebKit has
	// received a response for a network resource and is about to start the
	// load. Note that these resources include all subresources of a page such
	// as images and stylesheets as well as main documents. Appropriate policy
	// responses to this decision are webkit_policy_decision_use(),
	// webkit_policy_decision_ignore(), or webkit_policy_decision_download().
	// This type of policy decision is always a KitResponsePolicyDecision. This
	// decision is useful for forcing some types of resources to be downloaded
	// rather than rendered in the WebView or to block the transfer of resources
	// entirely.
	PolicyDecisionTypeResponse
)

func marshalPolicyDecisionType(p uintptr) (interface{}, error) {
	return PolicyDecisionType(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PolicyDecisionType.
func (p PolicyDecisionType) String() string {
	switch p {
	case PolicyDecisionTypeNavigationAction:
		return "NavigationAction"
	case PolicyDecisionTypeNewWindowAction:
		return "NewWindowAction"
	case PolicyDecisionTypeResponse:
		return "Response"
	default:
		return fmt.Sprintf("PolicyDecisionType(%d)", p)
	}
}

// SaveMode: enum values to specify the different ways in which a KitWebView can
// save its current web page into a self-contained file.
type SaveMode C.gint

const (
	// SaveModeMhtml: save the current page using the MHTML format.
	SaveModeMhtml SaveMode = iota
)

func marshalSaveMode(p uintptr) (interface{}, error) {
	return SaveMode(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SaveMode.
func (s SaveMode) String() string {
	switch s {
	case SaveModeMhtml:
		return "Mhtml"
	default:
		return fmt.Sprintf("SaveMode(%d)", s)
	}
}

// SnapshotRegion: enum values used to specify the region from which to get a
// KitWebView snapshot.
type SnapshotRegion C.gint

const (
	// SnapshotRegionVisible specifies a snapshot only for the area that is
	// visible in the webview.
	SnapshotRegionVisible SnapshotRegion = iota
	// SnapshotRegionFullDocument: snapshot of the entire document.
	SnapshotRegionFullDocument
)

func marshalSnapshotRegion(p uintptr) (interface{}, error) {
	return SnapshotRegion(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SnapshotRegion.
func (s SnapshotRegion) String() string {
	switch s {
	case SnapshotRegionVisible:
		return "Visible"
	case SnapshotRegionFullDocument:
		return "FullDocument"
	default:
		return fmt.Sprintf("SnapshotRegion(%d)", s)
	}
}

// WebProcessTerminationReason: enum values used to specify the reason why the
// web process terminated abnormally.
type WebProcessTerminationReason C.gint

const (
	// WebProcessCrashed: web process crashed.
	WebProcessCrashed WebProcessTerminationReason = iota
	// WebProcessExceededMemoryLimit: web process exceeded the memory limit.
	WebProcessExceededMemoryLimit
)

func marshalWebProcessTerminationReason(p uintptr) (interface{}, error) {
	return WebProcessTerminationReason(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WebProcessTerminationReason.
func (w WebProcessTerminationReason) String() string {
	switch w {
	case WebProcessCrashed:
		return "Crashed"
	case WebProcessExceededMemoryLimit:
		return "ExceededMemoryLimit"
	default:
		return fmt.Sprintf("WebProcessTerminationReason(%d)", w)
	}
}

// SnapshotOptions: enum values used to specify options when taking a snapshot
// from a KitWebView.
type SnapshotOptions C.guint

const (
	// SnapshotOptionsNone: do not include any special options.
	SnapshotOptionsNone SnapshotOptions = 0b0
	// SnapshotOptionsIncludeSelectionHighlighting: whether to include in the
	// snapshot the highlight of the selected content.
	SnapshotOptionsIncludeSelectionHighlighting SnapshotOptions = 0b1
	// SnapshotOptionsTransparentBackground: do not fill the background with
	// white before rendering the snapshot. Since 2.8.
	SnapshotOptionsTransparentBackground SnapshotOptions = 0b10
)

func marshalSnapshotOptions(p uintptr) (interface{}, error) {
	return SnapshotOptions(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for SnapshotOptions.
func (s SnapshotOptions) String() string {
	if s == 0 {
		return "SnapshotOptions(0)"
	}

	var builder strings.Builder
	builder.Grow(100)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case SnapshotOptionsNone:
			builder.WriteString("None|")
		case SnapshotOptionsIncludeSelectionHighlighting:
			builder.WriteString("IncludeSelectionHighlighting|")
		case SnapshotOptionsTransparentBackground:
			builder.WriteString("TransparentBackground|")
		default:
			builder.WriteString(fmt.Sprintf("SnapshotOptions(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s SnapshotOptions) Has(other SnapshotOptions) bool {
	return (s & other) == other
}

// WebViewOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type WebViewOverrider interface {
	Authenticate(request *AuthenticationRequest) bool
	Close()
	ContextMenu(contextMenu *ContextMenu, event *gdk.Event, hitTestResult *HitTestResult) bool
	ContextMenuDismissed()
	DecidePolicy(decision PolicyDecisioner, typ PolicyDecisionType) bool
	EnterFullscreen() bool
	InsecureContentDetected(event InsecureContentEvent)
	LeaveFullscreen() bool
	LoadChanged(loadEvent LoadEvent)
	LoadFailed(loadEvent LoadEvent, failingUri string, err error) bool
	LoadFailedWithTLSErrors(failingUri string, certificate gio.TLSCertificater, errors gio.TLSCertificateFlags) bool
	MouseTargetChanged(hitTestResult *HitTestResult, modifiers uint)
	PermissionRequest(permissionRequest PermissionRequester) bool
	Print(printOperation *PrintOperation) bool
	ReadyToShow()
	ResourceLoadStarted(resource *WebResource, request *URIRequest)
	RunAsModal()
	RunColorChooser(request *ColorChooserRequest) bool
	RunFileChooser(request *FileChooserRequest) bool
	ScriptDialog(dialog *ScriptDialog) bool
	ShowNotification(notification *Notification) bool
	ShowOptionMenu(rectangle *gdk.Rectangle, menu *OptionMenu) bool
	SubmitForm(request *FormSubmissionRequest)
	UserMessageReceived(message *UserMessage) bool
	WebProcessCrashed() bool
	WebProcessTerminated(reason WebProcessTerminationReason)
}

type WebView struct {
	WebViewBase
}

var (
	_ gtk.Containerer = (*WebView)(nil)
)

func wrapWebView(obj *externglib.Object) *WebView {
	return &WebView{
		WebViewBase: WebViewBase{
			Container: gtk.Container{
				Widget: gtk.Widget{
					InitiallyUnowned: externglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					ImplementorIface: atk.ImplementorIface{
						Object: obj,
					},
					Buildable: gtk.Buildable{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalWebViewer(p uintptr) (interface{}, error) {
	return wrapWebView(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewWebView creates a new KitWebView with the default KitWebContext and no
// KitUserContentManager associated with it. See also
// webkit_web_view_new_with_context(),
// webkit_web_view_new_with_user_content_manager(), and
// webkit_web_view_new_with_settings().
func NewWebView() *WebView {
	var _cret *C.GtkWidget // in

	_cret = C.webkit_web_view_new()

	var _webView *WebView // out

	_webView = wrapWebView(externglib.Take(unsafe.Pointer(_cret)))

	return _webView
}

// NewWebViewWithContext creates a new KitWebView with the given KitWebContext
// and no KitUserContentManager associated with it. See also
// webkit_web_view_new_with_user_content_manager() and
// webkit_web_view_new_with_settings().
//
// The function takes the following parameters:
//
//    - context to be used by the KitWebView.
//
func NewWebViewWithContext(context *WebContext) *WebView {
	var _arg1 *C.WebKitWebContext // out
	var _cret *C.GtkWidget        // in

	_arg1 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_view_new_with_context(_arg1)
	runtime.KeepAlive(context)

	var _webView *WebView // out

	_webView = wrapWebView(externglib.Take(unsafe.Pointer(_cret)))

	return _webView
}

// NewWebViewWithRelatedView creates a new KitWebView sharing the same web
// process with web_view. This method doesn't have any effect when
// WEBKIT_PROCESS_MODEL_SHARED_SECONDARY_PROCESS process model is used, because
// a single web process is shared for all the web views in the same
// KitWebContext. When using WEBKIT_PROCESS_MODEL_MULTIPLE_SECONDARY_PROCESSES
// process model, this method should always be used when creating the KitWebView
// in the KitWebView::create signal. You can also use this method to implement
// other process models based on
// WEBKIT_PROCESS_MODEL_MULTIPLE_SECONDARY_PROCESSES, like for example, sharing
// the same web process for all the views in the same security domain.
//
// The newly created KitWebView will also have the same KitUserContentManager,
// KitSettings, and KitWebsitePolicies as web_view.
//
// The function takes the following parameters:
//
//    - webView: related KitWebView.
//
func NewWebViewWithRelatedView(webView *WebView) *WebView {
	var _arg1 *C.WebKitWebView // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_new_with_related_view(_arg1)
	runtime.KeepAlive(webView)

	var _webView *WebView // out

	_webView = wrapWebView(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _webView
}

// NewWebViewWithSettings creates a new KitWebView with the given KitSettings.
// See also webkit_web_view_new_with_context(), and
// webkit_web_view_new_with_user_content_manager().
//
// The function takes the following parameters:
//
//    - settings: KitSettings.
//
func NewWebViewWithSettings(settings *Settings) *WebView {
	var _arg1 *C.WebKitSettings // out
	var _cret *C.GtkWidget      // in

	_arg1 = (*C.WebKitSettings)(unsafe.Pointer(settings.Native()))

	_cret = C.webkit_web_view_new_with_settings(_arg1)
	runtime.KeepAlive(settings)

	var _webView *WebView // out

	_webView = wrapWebView(externglib.Take(unsafe.Pointer(_cret)))

	return _webView
}

// NewWebViewWithUserContentManager creates a new KitWebView with the given
// KitUserContentManager. The content loaded in the view may be affected by the
// content injected in the view by the user content manager.
//
// The function takes the following parameters:
//
//    - userContentManager: KitUserContentManager.
//
func NewWebViewWithUserContentManager(userContentManager *UserContentManager) *WebView {
	var _arg1 *C.WebKitUserContentManager // out
	var _cret *C.GtkWidget                // in

	_arg1 = (*C.WebKitUserContentManager)(unsafe.Pointer(userContentManager.Native()))

	_cret = C.webkit_web_view_new_with_user_content_manager(_arg1)
	runtime.KeepAlive(userContentManager)

	var _webView *WebView // out

	_webView = wrapWebView(externglib.Take(unsafe.Pointer(_cret)))

	return _webView
}

// CanExecuteEditingCommand: asynchronously check if it is possible to execute
// the given editing command.
//
// When the operation is finished, callback will be called. You can then call
// webkit_web_view_can_execute_editing_command_finish() to get the result of the
// operation.
//
// The function takes the following parameters:
//
//    - ctx or NULL to ignore.
//    - command to check.
//    - callback to call when the request is satisfied.
//
func (webView *WebView) CanExecuteEditingCommand(ctx context.Context, command string, callback gio.AsyncReadyCallback) {
	var _arg0 *C.WebKitWebView      // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(command)))
	defer C.free(unsafe.Pointer(_arg1))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.webkit_web_view_can_execute_editing_command(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(command)
	runtime.KeepAlive(callback)
}

// CanExecuteEditingCommandFinish: finish an asynchronous operation started with
// webkit_web_view_can_execute_editing_command().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (webView *WebView) CanExecuteEditingCommandFinish(result gio.AsyncResulter) error {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.GAsyncResult  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.webkit_web_view_can_execute_editing_command_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// CanGoBack determines whether web_view has a previous history item.
func (webView *WebView) CanGoBack() bool {
	var _arg0 *C.WebKitWebView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_can_go_back(_arg0)
	runtime.KeepAlive(webView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanGoForward determines whether web_view has a next history item.
func (webView *WebView) CanGoForward() bool {
	var _arg0 *C.WebKitWebView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_can_go_forward(_arg0)
	runtime.KeepAlive(webView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanShowMIMEType: whether or not a MIME type can be displayed in web_view.
//
// The function takes the following parameters:
//
//    - mimeType: MIME type.
//
func (webView *WebView) CanShowMIMEType(mimeType string) bool {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.gchar         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(mimeType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.webkit_web_view_can_show_mime_type(_arg0, _arg1)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(mimeType)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DownloadURI requests downloading of the specified URI string for web_view.
//
// The function takes the following parameters:
//
//    - uri: URI to download.
//
func (webView *WebView) DownloadURI(uri string) *Download {
	var _arg0 *C.WebKitWebView  // out
	var _arg1 *C.char           // out
	var _cret *C.WebKitDownload // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.webkit_web_view_download_uri(_arg0, _arg1)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(uri)

	var _download *Download // out

	_download = wrapDownload(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _download
}

// ExecuteEditingCommand: request to execute the given command for web_view. You
// can use webkit_web_view_can_execute_editing_command() to check whether it's
// possible to execute the command.
//
// The function takes the following parameters:
//
//    - command to execute.
//
func (webView *WebView) ExecuteEditingCommand(command string) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(command)))
	defer C.free(unsafe.Pointer(_arg1))

	C.webkit_web_view_execute_editing_command(_arg0, _arg1)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(command)
}

// ExecuteEditingCommandWithArgument: request to execute the given command with
// argument for web_view. You can use
// webkit_web_view_can_execute_editing_command() to check whether it's possible
// to execute the command.
//
// The function takes the following parameters:
//
//    - command to execute.
//    - argument: command argument.
//
func (webView *WebView) ExecuteEditingCommandWithArgument(command, argument string) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.char          // out
	var _arg2 *C.char          // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(command)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(argument)))
	defer C.free(unsafe.Pointer(_arg2))

	C.webkit_web_view_execute_editing_command_with_argument(_arg0, _arg1, _arg2)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(command)
	runtime.KeepAlive(argument)
}

// AutomationPresentationType: get the presentation type of KitWebView when
// created for automation.
func (webView *WebView) AutomationPresentationType() AutomationBrowsingContextPresentation {
	var _arg0 *C.WebKitWebView                              // out
	var _cret C.WebKitAutomationBrowsingContextPresentation // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_automation_presentation_type(_arg0)
	runtime.KeepAlive(webView)

	var _automationBrowsingContextPresentation AutomationBrowsingContextPresentation // out

	_automationBrowsingContextPresentation = AutomationBrowsingContextPresentation(_cret)

	return _automationBrowsingContextPresentation
}

// BackForwardList obtains the KitBackForwardList associated with the given
// KitWebView. The KitBackForwardList is owned by the KitWebView.
func (webView *WebView) BackForwardList() *BackForwardList {
	var _arg0 *C.WebKitWebView         // out
	var _cret *C.WebKitBackForwardList // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_back_forward_list(_arg0)
	runtime.KeepAlive(webView)

	var _backForwardList *BackForwardList // out

	_backForwardList = wrapBackForwardList(externglib.Take(unsafe.Pointer(_cret)))

	return _backForwardList
}

// BackgroundColor gets the color that is used to draw the web_view background
// before the actual contents are rendered. For more information see also
// webkit_web_view_set_background_color().
func (webView *WebView) BackgroundColor() *gdk.RGBA {
	var _arg0 *C.WebKitWebView // out
	var _arg1 C.GdkRGBA        // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	C.webkit_web_view_get_background_color(_arg0, &_arg1)
	runtime.KeepAlive(webView)

	var _rgba *gdk.RGBA // out

	_rgba = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _rgba
}

// Context gets the web context of web_view.
func (webView *WebView) Context() *WebContext {
	var _arg0 *C.WebKitWebView    // out
	var _cret *C.WebKitWebContext // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_context(_arg0)
	runtime.KeepAlive(webView)

	var _webContext *WebContext // out

	_webContext = wrapWebContext(externglib.Take(unsafe.Pointer(_cret)))

	return _webContext
}

// CustomCharset returns the current custom character encoding name of web_view.
func (webView *WebView) CustomCharset() string {
	var _arg0 *C.WebKitWebView // out
	var _cret *C.gchar         // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_custom_charset(_arg0)
	runtime.KeepAlive(webView)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// EditorState gets the web editor state of web_view.
func (webView *WebView) EditorState() *EditorState {
	var _arg0 *C.WebKitWebView     // out
	var _cret *C.WebKitEditorState // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_editor_state(_arg0)
	runtime.KeepAlive(webView)

	var _editorState *EditorState // out

	_editorState = wrapEditorState(externglib.Take(unsafe.Pointer(_cret)))

	return _editorState
}

// EstimatedLoadProgress gets the value of the
// KitWebView:estimated-load-progress property. You can monitor the estimated
// progress of a load operation by connecting to the
// notify::estimated-load-progress signal of web_view.
func (webView *WebView) EstimatedLoadProgress() float64 {
	var _arg0 *C.WebKitWebView // out
	var _cret C.gdouble        // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_estimated_load_progress(_arg0)
	runtime.KeepAlive(webView)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Favicon returns favicon currently associated to web_view, if any. You can
// connect to notify::favicon signal of web_view to be notified when the favicon
// is available.
func (webView *WebView) Favicon() *cairo.Surface {
	var _arg0 *C.WebKitWebView   // out
	var _cret *C.cairo_surface_t // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_favicon(_arg0)
	runtime.KeepAlive(webView)

	var _surface *cairo.Surface // out

	_surface = cairo.WrapSurface(uintptr(unsafe.Pointer(_cret)))
	C.cairo_surface_reference(_cret)
	runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
		C.cairo_surface_destroy((*C.cairo_surface_t)(unsafe.Pointer(v.Native())))
	})

	return _surface
}

// FindController gets the KitFindController that will allow the caller to query
// the KitWebView for the text to look for.
func (webView *WebView) FindController() *FindController {
	var _arg0 *C.WebKitWebView        // out
	var _cret *C.WebKitFindController // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_find_controller(_arg0)
	runtime.KeepAlive(webView)

	var _findController *FindController // out

	_findController = wrapFindController(externglib.Take(unsafe.Pointer(_cret)))

	return _findController
}

// InputMethodContext: get the KitInputMethodContext currently in use by
// web_view, or NULL if no input method is being used.
func (webView *WebView) InputMethodContext() InputMethodContexter {
	var _arg0 *C.WebKitWebView            // out
	var _cret *C.WebKitInputMethodContext // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_input_method_context(_arg0)
	runtime.KeepAlive(webView)

	var _inputMethodContext InputMethodContexter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			rv, ok := (externglib.CastObject(object)).(InputMethodContexter)
			if !ok {
				panic("object of type " + object.TypeFromInstance().String() + " is not webkit2.InputMethodContexter")
			}
			_inputMethodContext = rv
		}
	}

	return _inputMethodContext
}

// Inspector: get the KitWebInspector associated to web_view.
func (webView *WebView) Inspector() *WebInspector {
	var _arg0 *C.WebKitWebView      // out
	var _cret *C.WebKitWebInspector // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_inspector(_arg0)
	runtime.KeepAlive(webView)

	var _webInspector *WebInspector // out

	_webInspector = wrapWebInspector(externglib.Take(unsafe.Pointer(_cret)))

	return _webInspector
}

// IsMuted gets the mute state of web_view.
func (webView *WebView) IsMuted() bool {
	var _arg0 *C.WebKitWebView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_is_muted(_arg0)
	runtime.KeepAlive(webView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MainResource: return the main resource of web_view.
func (webView *WebView) MainResource() *WebResource {
	var _arg0 *C.WebKitWebView     // out
	var _cret *C.WebKitWebResource // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_main_resource(_arg0)
	runtime.KeepAlive(webView)

	var _webResource *WebResource // out

	_webResource = wrapWebResource(externglib.Take(unsafe.Pointer(_cret)))

	return _webResource
}

// PageID: get the identifier of the KitWebPage corresponding to the KitWebView.
func (webView *WebView) PageID() uint64 {
	var _arg0 *C.WebKitWebView // out
	var _cret C.guint64        // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_page_id(_arg0)
	runtime.KeepAlive(webView)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// SessionState gets the current session state of web_view.
func (webView *WebView) SessionState() *WebViewSessionState {
	var _arg0 *C.WebKitWebView             // out
	var _cret *C.WebKitWebViewSessionState // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_session_state(_arg0)
	runtime.KeepAlive(webView)

	var _webViewSessionState *WebViewSessionState // out

	_webViewSessionState = (*WebViewSessionState)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_webViewSessionState)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.webkit_web_view_session_state_unref((*C.WebKitWebViewSessionState)(intern.C))
		},
	)

	return _webViewSessionState
}

// Settings gets the KitSettings currently applied to web_view. If no other
// KitSettings have been explicitly applied to web_view with
// webkit_web_view_set_settings(), the default KitSettings will be returned.
// This method always returns a valid KitSettings object. To modify any of the
// web_view settings, you can either create a new KitSettings object with
// webkit_settings_new(), setting the desired preferences, and then replace the
// existing web_view settings with webkit_web_view_set_settings() or get the
// existing web_view settings and update it directly. KitSettings objects can be
// shared by multiple KitWebView<!-- -->s, so modifying the settings of a
// KitWebView would affect other KitWebView<!-- -->s using the same KitSettings.
func (webView *WebView) Settings() *Settings {
	var _arg0 *C.WebKitWebView  // out
	var _cret *C.WebKitSettings // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_settings(_arg0)
	runtime.KeepAlive(webView)

	var _settings *Settings // out

	_settings = wrapSettings(externglib.Take(unsafe.Pointer(_cret)))

	return _settings
}

// Snapshot: asynchronously retrieves a snapshot of web_view for region. options
// specifies how the snapshot should be rendered.
//
// When the operation is finished, callback will be called. You must call
// webkit_web_view_get_snapshot_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx: #GCancellable.
//    - region for this snapshot.
//    - options for the snapshot.
//    - callback: ReadyCallback.
//
func (webView *WebView) Snapshot(ctx context.Context, region SnapshotRegion, options SnapshotOptions, callback gio.AsyncReadyCallback) {
	var _arg0 *C.WebKitWebView        // out
	var _arg3 *C.GCancellable         // out
	var _arg1 C.WebKitSnapshotRegion  // out
	var _arg2 C.WebKitSnapshotOptions // out
	var _arg4 C.GAsyncReadyCallback   // out
	var _arg5 C.gpointer

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.WebKitSnapshotRegion(region)
	_arg2 = C.WebKitSnapshotOptions(options)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.webkit_web_view_get_snapshot(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(region)
	runtime.KeepAlive(options)
	runtime.KeepAlive(callback)
}

// SnapshotFinish finishes an asynchronous operation started with
// webkit_web_view_get_snapshot().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (webView *WebView) SnapshotFinish(result gio.AsyncResulter) (*cairo.Surface, error) {
	var _arg0 *C.WebKitWebView   // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.cairo_surface_t // in
	var _cerr *C.GError          // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.webkit_web_view_get_snapshot_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(result)

	var _surface *cairo.Surface // out
	var _goerr error            // out

	_surface = cairo.WrapSurface(uintptr(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
		C.cairo_surface_destroy((*C.cairo_surface_t)(unsafe.Pointer(v.Native())))
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _surface, _goerr
}

// Title gets the value of the KitWebView:title property. You can connect to
// notify::title signal of web_view to be notified when the title has been
// received.
func (webView *WebView) Title() string {
	var _arg0 *C.WebKitWebView // out
	var _cret *C.gchar         // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_title(_arg0)
	runtime.KeepAlive(webView)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TLSInfo retrieves the Certificate associated with the main resource of
// web_view, and the CertificateFlags showing what problems, if any, have been
// found with that certificate. If the connection is not HTTPS, this function
// returns FALSE. This function should be called after a response has been
// received from the server, so you can connect to KitWebView::load-changed and
// call this function when it's emitted with WEBKIT_LOAD_COMMITTED event.
//
// Note that this function provides no information about the security of the web
// page if the current KitTLSErrorsPolicy is WEBKIT_TLS_ERRORS_POLICY_IGNORE, as
// subresources of the page may be controlled by an attacker. This function may
// safely be used to determine the security status of the current page only if
// the current KitTLSErrorsPolicy is WEBKIT_TLS_ERRORS_POLICY_FAIL, in which
// case subresources that fail certificate verification will be blocked.
func (webView *WebView) TLSInfo() (gio.TLSCertificater, gio.TLSCertificateFlags, bool) {
	var _arg0 *C.WebKitWebView       // out
	var _arg1 *C.GTlsCertificate     // in
	var _arg2 C.GTlsCertificateFlags // in
	var _cret C.gboolean             // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_tls_info(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(webView)

	var _certificate gio.TLSCertificater // out
	var _errors gio.TLSCertificateFlags  // out
	var _ok bool                         // out

	{
		objptr := unsafe.Pointer(_arg1)
		if objptr == nil {
			panic("object of type gio.TLSCertificater is nil")
		}

		object := externglib.Take(objptr)
		rv, ok := (externglib.CastObject(object)).(gio.TLSCertificater)
		if !ok {
			panic("object of type " + object.TypeFromInstance().String() + " is not gio.TLSCertificater")
		}
		_certificate = rv
	}
	_errors = gio.TLSCertificateFlags(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _certificate, _errors, _ok
}

// URI returns the current active URI of web_view. The active URI might change
// during a load operation:
//
// <orderedlist> <listitem><para> When nothing has been loaded yet on web_view
// the active URI is NULL. </para></listitem> <listitem><para> When a new load
// operation starts the active URI is the requested URI: <itemizedlist>
// <listitem><para> If the load operation was started by
// webkit_web_view_load_uri(), the requested URI is the given one.
// </para></listitem> <listitem><para> If the load operation was started by
// webkit_web_view_load_html(), the requested URI is "about:blank".
// </para></listitem> <listitem><para> If the load operation was started by
// webkit_web_view_load_alternate_html(), the requested URI is content URI
// provided. </para></listitem> <listitem><para> If the load operation was
// started by webkit_web_view_go_back() or webkit_web_view_go_forward(), the
// requested URI is the original URI of the previous/next item in the
// KitBackForwardList of web_view. </para></listitem> <listitem><para> If the
// load operation was started by webkit_web_view_go_to_back_forward_list_item(),
// the requested URI is the opriginal URI of the given KitBackForwardListItem.
// </para></listitem> </itemizedlist> </para></listitem> <listitem><para> If
// there is a server redirection during the load operation, the active URI is
// the redirected URI. When the signal KitWebView::load-changed is emitted with
// WEBKIT_LOAD_REDIRECTED event, the active URI is already updated to the
// redirected URI. </para></listitem> <listitem><para> When the signal
// KitWebView::load-changed is emitted with WEBKIT_LOAD_COMMITTED event, the
// active URI is the final one and it will not change unless a new load
// operation is started or a navigation action within the same page is
// performed. </para></listitem> </orderedlist>
//
// You can monitor the active URI by connecting to the notify::uri signal of
// web_view.
func (webView *WebView) URI() string {
	var _arg0 *C.WebKitWebView // out
	var _cret *C.gchar         // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_uri(_arg0)
	runtime.KeepAlive(webView)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// UserContentManager gets the user content manager associated to web_view.
func (webView *WebView) UserContentManager() *UserContentManager {
	var _arg0 *C.WebKitWebView            // out
	var _cret *C.WebKitUserContentManager // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_user_content_manager(_arg0)
	runtime.KeepAlive(webView)

	var _userContentManager *UserContentManager // out

	_userContentManager = wrapUserContentManager(externglib.Take(unsafe.Pointer(_cret)))

	return _userContentManager
}

// WebsiteDataManager: get the KitWebsiteDataManager associated to web_view. If
// web_view is not ephemeral, the returned KitWebsiteDataManager will be the
// same as the KitWebsiteDataManager of web_view's KitWebContext.
func (webView *WebView) WebsiteDataManager() *WebsiteDataManager {
	var _arg0 *C.WebKitWebView            // out
	var _cret *C.WebKitWebsiteDataManager // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_website_data_manager(_arg0)
	runtime.KeepAlive(webView)

	var _websiteDataManager *WebsiteDataManager // out

	_websiteDataManager = wrapWebsiteDataManager(externglib.Take(unsafe.Pointer(_cret)))

	return _websiteDataManager
}

// WebsitePolicies gets the default website policies set on construction in the
// web_view. These can be overridden on a per-origin basis via the
// KitWebView::decide-policy signal handler.
//
// See also webkit_policy_decision_use_with_policies().
func (webView *WebView) WebsitePolicies() *WebsitePolicies {
	var _arg0 *C.WebKitWebView         // out
	var _cret *C.WebKitWebsitePolicies // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_website_policies(_arg0)
	runtime.KeepAlive(webView)

	var _websitePolicies *WebsitePolicies // out

	_websitePolicies = wrapWebsitePolicies(externglib.Take(unsafe.Pointer(_cret)))

	return _websitePolicies
}

// WindowProperties: get the KitWindowProperties object containing the
// properties that the window containing web_view should have.
func (webView *WebView) WindowProperties() *WindowProperties {
	var _arg0 *C.WebKitWebView          // out
	var _cret *C.WebKitWindowProperties // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_window_properties(_arg0)
	runtime.KeepAlive(webView)

	var _windowProperties *WindowProperties // out

	_windowProperties = wrapWindowProperties(externglib.Take(unsafe.Pointer(_cret)))

	return _windowProperties
}

// ZoomLevel: get the zoom level of web_view, i.e. the factor by which the view
// contents are scaled with respect to their original size.
func (webView *WebView) ZoomLevel() float64 {
	var _arg0 *C.WebKitWebView // out
	var _cret C.gdouble        // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_zoom_level(_arg0)
	runtime.KeepAlive(webView)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// GoBack loads the previous history item. You can monitor the load operation by
// connecting to KitWebView::load-changed signal.
func (webView *WebView) GoBack() {
	var _arg0 *C.WebKitWebView // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	C.webkit_web_view_go_back(_arg0)
	runtime.KeepAlive(webView)
}

// GoForward loads the next history item. You can monitor the load operation by
// connecting to KitWebView::load-changed signal.
func (webView *WebView) GoForward() {
	var _arg0 *C.WebKitWebView // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	C.webkit_web_view_go_forward(_arg0)
	runtime.KeepAlive(webView)
}

// GoToBackForwardListItem loads the specific history item list_item. You can
// monitor the load operation by connecting to KitWebView::load-changed signal.
//
// The function takes the following parameters:
//
//    - listItem: KitBackForwardListItem.
//
func (webView *WebView) GoToBackForwardListItem(listItem *BackForwardListItem) {
	var _arg0 *C.WebKitWebView             // out
	var _arg1 *C.WebKitBackForwardListItem // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.WebKitBackForwardListItem)(unsafe.Pointer(listItem.Native()))

	C.webkit_web_view_go_to_back_forward_list_item(_arg0, _arg1)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(listItem)
}

// IsControlledByAutomation: get whether a KitWebView was created with
// KitWebView:is-controlled-by-automation property enabled. Only KitWebView<!--
// -->s controlled by automation can be used in an automation session.
func (webView *WebView) IsControlledByAutomation() bool {
	var _arg0 *C.WebKitWebView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_is_controlled_by_automation(_arg0)
	runtime.KeepAlive(webView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (webView *WebView) IsEditable() bool {
	var _arg0 *C.WebKitWebView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_is_editable(_arg0)
	runtime.KeepAlive(webView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEphemeral: get whether a KitWebView is ephemeral. To create an ephemeral
// KitWebView you need to use g_object_new() and pass is-ephemeral property with
// TRUE value. See KitWebView:is-ephemeral for more details. If web_view was
// created with a ephemeral KitWebView:related-view or an ephemeral
// KitWebView:web-context it will also be ephemeral.
func (webView *WebView) IsEphemeral() bool {
	var _arg0 *C.WebKitWebView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_is_ephemeral(_arg0)
	runtime.KeepAlive(webView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsLoading gets the value of the KitWebView:is-loading property. You can
// monitor when a KitWebView is loading a page by connecting to
// notify::is-loading signal of web_view. This is useful when you are
// interesting in knowing when the view is loading something but not in the
// details about the status of the load operation, for example to start a
// spinner when the view is loading a page and stop it when it finishes.
func (webView *WebView) IsLoading() bool {
	var _arg0 *C.WebKitWebView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_is_loading(_arg0)
	runtime.KeepAlive(webView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsPlayingAudio gets the value of the KitWebView:is-playing-audio property.
// You can monitor when a page in a KitWebView is playing audio by connecting to
// the notify::is-playing-audio signal of web_view. This is useful when the
// application wants to provide visual feedback when a page is producing sound.
func (webView *WebView) IsPlayingAudio() bool {
	var _arg0 *C.WebKitWebView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_is_playing_audio(_arg0)
	runtime.KeepAlive(webView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LoadAlternateHtml: load the given content string for the URI content_uri.
// This allows clients to display page-loading errors in the KitWebView itself.
// When this method is called from KitWebView::load-failed signal to show an
// error page, then the back-forward list is maintained appropriately. For
// everything else this method works the same way as
// webkit_web_view_load_html().
//
// The function takes the following parameters:
//
//    - content: new content to display as the main page of the web_view.
//    - contentUri: URI for the alternate page content.
//    - baseUri: base URI for relative locations or NULL.
//
func (webView *WebView) LoadAlternateHtml(content, contentUri, baseUri string) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _arg3 *C.gchar         // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(content)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(contentUri)))
	defer C.free(unsafe.Pointer(_arg2))
	if baseUri != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(baseUri)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	C.webkit_web_view_load_alternate_html(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(content)
	runtime.KeepAlive(contentUri)
	runtime.KeepAlive(baseUri)
}

// LoadBytes: load the specified bytes into web_view using the given mime_type
// and encoding. When mime_type is NULL, it defaults to "text/html". When
// encoding is NULL, it defaults to "UTF-8". When base_uri is NULL, it defaults
// to "about:blank". You can monitor the load operation by connecting to
// KitWebView::load-changed signal.
//
// The function takes the following parameters:
//
//    - bytes: input data to load.
//    - mimeType: MIME type of bytes, or NULL.
//    - encoding: character encoding of bytes, or NULL.
//    - baseUri: base URI for relative locations or NULL.
//
func (webView *WebView) LoadBytes(bytes *glib.Bytes, mimeType, encoding, baseUri string) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.GBytes        // out
	var _arg2 *C.gchar         // out
	var _arg3 *C.gchar         // out
	var _arg4 *C.gchar         // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))
	if mimeType != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(mimeType)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if encoding != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(encoding)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if baseUri != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(baseUri)))
		defer C.free(unsafe.Pointer(_arg4))
	}

	C.webkit_web_view_load_bytes(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(bytes)
	runtime.KeepAlive(mimeType)
	runtime.KeepAlive(encoding)
	runtime.KeepAlive(baseUri)
}

// LoadHtml: load the given content string with the specified base_uri. If
// base_uri is not NULL, relative URLs in the content will be resolved against
// base_uri and absolute local paths must be children of the base_uri. For
// security reasons absolute local paths that are not children of base_uri will
// cause the web process to terminate. If you need to include URLs in content
// that are local paths in a different directory than base_uri you can build a
// data URI for them. When base_uri is NULL, it defaults to "about:blank". The
// mime type of the document will be "text/html". You can monitor the load
// operation by connecting to KitWebView::load-changed signal.
//
// The function takes the following parameters:
//
//    - content: HTML string to load.
//    - baseUri: base URI for relative locations or NULL.
//
func (webView *WebView) LoadHtml(content, baseUri string) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(content)))
	defer C.free(unsafe.Pointer(_arg1))
	if baseUri != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(baseUri)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	C.webkit_web_view_load_html(_arg0, _arg1, _arg2)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(content)
	runtime.KeepAlive(baseUri)
}

// LoadPlainText: load the specified plain_text string into web_view. The mime
// type of document will be "text/plain". You can monitor the load operation by
// connecting to KitWebView::load-changed signal.
//
// The function takes the following parameters:
//
//    - plainText: plain text to load.
//
func (webView *WebView) LoadPlainText(plainText string) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(plainText)))
	defer C.free(unsafe.Pointer(_arg1))

	C.webkit_web_view_load_plain_text(_arg0, _arg1)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(plainText)
}

// LoadRequest requests loading of the specified KitURIRequest. You can monitor
// the load operation by connecting to KitWebView::load-changed signal.
//
// The function takes the following parameters:
//
//    - request to load.
//
func (webView *WebView) LoadRequest(request *URIRequest) {
	var _arg0 *C.WebKitWebView    // out
	var _arg1 *C.WebKitURIRequest // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.WebKitURIRequest)(unsafe.Pointer(request.Native()))

	C.webkit_web_view_load_request(_arg0, _arg1)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(request)
}

// LoadURI requests loading of the specified URI string. You can monitor the
// load operation by connecting to KitWebView::load-changed signal.
//
// The function takes the following parameters:
//
//    - uri: URI string.
//
func (webView *WebView) LoadURI(uri string) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	C.webkit_web_view_load_uri(_arg0, _arg1)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(uri)
}

// Reload reloads the current contents of web_view. See also
// webkit_web_view_reload_bypass_cache().
func (webView *WebView) Reload() {
	var _arg0 *C.WebKitWebView // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	C.webkit_web_view_reload(_arg0)
	runtime.KeepAlive(webView)
}

// ReloadBypassCache reloads the current contents of web_view without using any
// cached data.
func (webView *WebView) ReloadBypassCache() {
	var _arg0 *C.WebKitWebView // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	C.webkit_web_view_reload_bypass_cache(_arg0)
	runtime.KeepAlive(webView)
}

// RestoreSessionState: restore the web_view session state from state.
//
// The function takes the following parameters:
//
//    - state: KitWebViewSessionState.
//
func (webView *WebView) RestoreSessionState(state *WebViewSessionState) {
	var _arg0 *C.WebKitWebView             // out
	var _arg1 *C.WebKitWebViewSessionState // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.WebKitWebViewSessionState)(gextras.StructNative(unsafe.Pointer(state)))

	C.webkit_web_view_restore_session_state(_arg0, _arg1)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(state)
}

// RunJavascript: asynchronously run script in the context of the current page
// in web_view. If WebKitSettings:enable-javascript is FALSE, this method will
// do nothing.
//
// When the operation is finished, callback will be called. You can then call
// webkit_web_view_run_javascript_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx or NULL to ignore.
//    - script to run.
//    - callback to call when the script finished.
//
func (webView *WebView) RunJavascript(ctx context.Context, script string, callback gio.AsyncReadyCallback) {
	var _arg0 *C.WebKitWebView      // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(script)))
	defer C.free(unsafe.Pointer(_arg1))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.webkit_web_view_run_javascript(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(script)
	runtime.KeepAlive(callback)
}

// RunJavascriptFinish: finish an asynchronous operation started with
// webkit_web_view_run_javascript().
//
// This is an example of using webkit_web_view_run_javascript() with a script
// returning a string:
//
// <informalexample><programlisting> static void web_view_javascript_finished
// (GObject *object, GAsyncResult *result, gpointer user_data) {
// WebKitJavascriptResult *js_result; JSCValue *value; GError *error = NULL;
//
//    js_result = webkit_web_view_run_javascript_finish (WEBKIT_WEB_VIEW (object), result, &error);
//    if (!js_result) {
//        g_warning ("Error running javascript: s", error->message);
//        g_error_free (error);
//        return;
//    }
//
//    value = webkit_javascript_result_get_js_value (js_result);
//    if (jsc_value_is_string (value)) {
//        JSCException *exception;
//        gchar        *str_value;
//
//        str_value = jsc_value_to_string (value);
//        exception = jsc_context_get_exception (jsc_value_get_context (value));
//        if (exception)
//            g_warning ("Error running javascript: s", jsc_exception_get_message (exception));
//        else
//            g_print ("Script result: s\n", str_value);
//        g_free (str_value);
//    } else {
//        g_warning ("Error running javascript: unexpected return value");
//    }
//    webkit_javascript_result_unref (js_result);
//
// }
//
// static void web_view_get_link_url (WebKitWebView *web_view, const gchar
// *link_id) { gchar *script;
//
//    script = g_strdup_printf ("window.document.getElementById('s').href;", link_id);
//    webkit_web_view_run_javascript (web_view, script, NULL, web_view_javascript_finished, NULL);
//    g_free (script);
//
// } </programlisting></informalexample>.
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (webView *WebView) RunJavascriptFinish(result gio.AsyncResulter) (*JavascriptResult, error) {
	var _arg0 *C.WebKitWebView          // out
	var _arg1 *C.GAsyncResult           // out
	var _cret *C.WebKitJavascriptResult // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.webkit_web_view_run_javascript_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(result)

	var _javascriptResult *JavascriptResult // out
	var _goerr error                        // out

	_javascriptResult = (*JavascriptResult)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_javascriptResult)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.webkit_javascript_result_unref((*C.WebKitJavascriptResult)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _javascriptResult, _goerr
}

// RunJavascriptFromGresource: asynchronously run the script from resource in
// the context of the current page in web_view.
//
// When the operation is finished, callback will be called. You can then call
// webkit_web_view_run_javascript_from_gresource_finish() to get the result of
// the operation.
//
// The function takes the following parameters:
//
//    - ctx or NULL to ignore.
//    - resource: location of the resource to load.
//    - callback to call when the script finished.
//
func (webView *WebView) RunJavascriptFromGresource(ctx context.Context, resource string, callback gio.AsyncReadyCallback) {
	var _arg0 *C.WebKitWebView      // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(resource)))
	defer C.free(unsafe.Pointer(_arg1))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.webkit_web_view_run_javascript_from_gresource(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(resource)
	runtime.KeepAlive(callback)
}

// RunJavascriptFromGresourceFinish: finish an asynchronous operation started
// with webkit_web_view_run_javascript_from_gresource().
//
// Check webkit_web_view_run_javascript_finish() for a usage example.
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (webView *WebView) RunJavascriptFromGresourceFinish(result gio.AsyncResulter) (*JavascriptResult, error) {
	var _arg0 *C.WebKitWebView          // out
	var _arg1 *C.GAsyncResult           // out
	var _cret *C.WebKitJavascriptResult // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.webkit_web_view_run_javascript_from_gresource_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(result)

	var _javascriptResult *JavascriptResult // out
	var _goerr error                        // out

	_javascriptResult = (*JavascriptResult)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_javascriptResult)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.webkit_javascript_result_unref((*C.WebKitJavascriptResult)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _javascriptResult, _goerr
}

// RunJavascriptInWorld: asynchronously run script in the script world with name
// world_name of the current page context in web_view. If
// WebKitSettings:enable-javascript is FALSE, this method will do nothing.
//
// When the operation is finished, callback will be called. You can then call
// webkit_web_view_run_javascript_in_world_finish() to get the result of the
// operation.
//
// The function takes the following parameters:
//
//    - ctx or NULL to ignore.
//    - script to run.
//    - worldName: name of a KitScriptWorld.
//    - callback to call when the script finished.
//
func (webView *WebView) RunJavascriptInWorld(ctx context.Context, script, worldName string, callback gio.AsyncReadyCallback) {
	var _arg0 *C.WebKitWebView      // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg2 *C.gchar              // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(script)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(worldName)))
	defer C.free(unsafe.Pointer(_arg2))
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.webkit_web_view_run_javascript_in_world(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(script)
	runtime.KeepAlive(worldName)
	runtime.KeepAlive(callback)
}

// RunJavascriptInWorldFinish: finish an asynchronous operation started with
// webkit_web_view_run_javascript_in_world().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (webView *WebView) RunJavascriptInWorldFinish(result gio.AsyncResulter) (*JavascriptResult, error) {
	var _arg0 *C.WebKitWebView          // out
	var _arg1 *C.GAsyncResult           // out
	var _cret *C.WebKitJavascriptResult // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.webkit_web_view_run_javascript_in_world_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(result)

	var _javascriptResult *JavascriptResult // out
	var _goerr error                        // out

	_javascriptResult = (*JavascriptResult)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_javascriptResult)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.webkit_javascript_result_unref((*C.WebKitJavascriptResult)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _javascriptResult, _goerr
}

// Save: asynchronously save the current web page associated to the KitWebView
// into a self-contained format using the mode specified in save_mode.
//
// When the operation is finished, callback will be called. You can then call
// webkit_web_view_save_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx or NULL to ignore.
//    - saveMode specifying how the web page should be saved.
//    - callback to call when the request is satisfied.
//
func (webView *WebView) Save(ctx context.Context, saveMode SaveMode, callback gio.AsyncReadyCallback) {
	var _arg0 *C.WebKitWebView      // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.WebKitSaveMode      // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.WebKitSaveMode(saveMode)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.webkit_web_view_save(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(saveMode)
	runtime.KeepAlive(callback)
}

// SaveFinish: finish an asynchronous operation started with
// webkit_web_view_save().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (webView *WebView) SaveFinish(result gio.AsyncResulter) (gio.InputStreamer, error) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.GInputStream  // in
	var _cerr *C.GError        // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.webkit_web_view_save_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(result)

	var _inputStream gio.InputStreamer // out
	var _goerr error                   // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.InputStreamer is nil")
		}

		object := externglib.AssumeOwnership(objptr)
		rv, ok := (externglib.CastObject(object)).(gio.InputStreamer)
		if !ok {
			panic("object of type " + object.TypeFromInstance().String() + " is not gio.InputStreamer")
		}
		_inputStream = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _inputStream, _goerr
}

// SaveToFile: asynchronously save the current web page associated to the
// KitWebView into a self-contained format using the mode specified in save_mode
// and writing it to file.
//
// When the operation is finished, callback will be called. You can then call
// webkit_web_view_save_to_file_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx or NULL to ignore.
//    - file where the current web page should be saved to.
//    - saveMode specifying how the web page should be saved.
//    - callback to call when the request is satisfied.
//
func (webView *WebView) SaveToFile(ctx context.Context, file gio.Filer, saveMode SaveMode, callback gio.AsyncReadyCallback) {
	var _arg0 *C.WebKitWebView      // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.GFile              // out
	var _arg2 C.WebKitSaveMode      // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))
	_arg2 = C.WebKitSaveMode(saveMode)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.webkit_web_view_save_to_file(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(file)
	runtime.KeepAlive(saveMode)
	runtime.KeepAlive(callback)
}

// SaveToFileFinish: finish an asynchronous operation started with
// webkit_web_view_save_to_file().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (webView *WebView) SaveToFileFinish(result gio.AsyncResulter) error {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.GAsyncResult  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.webkit_web_view_save_to_file_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SendMessageToPage: send message to the KitWebPage corresponding to web_view.
// If message is floating, it's consumed.
//
// If you don't expect any reply, or you simply want to ignore it, you can pass
// NULL as callback. When the operation is finished, callback will be called.
// You can then call webkit_web_view_send_message_to_page_finish() to get the
// message reply.
//
// The function takes the following parameters:
//
//    - ctx or NULL to ignore.
//    - message: KitUserMessage.
//    - callback: (nullable): A ReadyCallback to call when the request is
//    satisfied or NULL.
//
func (webView *WebView) SendMessageToPage(ctx context.Context, message *UserMessage, callback gio.AsyncReadyCallback) {
	var _arg0 *C.WebKitWebView      // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.WebKitUserMessage  // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.WebKitUserMessage)(unsafe.Pointer(message.Native()))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.webkit_web_view_send_message_to_page(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(message)
	runtime.KeepAlive(callback)
}

// SendMessageToPageFinish: finish an asynchronous operation started with
// webkit_web_view_send_message_to_page().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (webView *WebView) SendMessageToPageFinish(result gio.AsyncResulter) (*UserMessage, error) {
	var _arg0 *C.WebKitWebView     // out
	var _arg1 *C.GAsyncResult      // out
	var _cret *C.WebKitUserMessage // in
	var _cerr *C.GError            // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.webkit_web_view_send_message_to_page_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(result)

	var _userMessage *UserMessage // out
	var _goerr error              // out

	_userMessage = wrapUserMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _userMessage, _goerr
}

// SetBackgroundColor sets the color that will be used to draw the web_view
// background before the actual contents are rendered. Note that if the web page
// loaded in web_view specifies a background color, it will take precedence over
// the rgba color. By default the web_view background color is opaque white.
// Note that the parent window must have a RGBA visual and Widget:app-paintable
// property set to TRUE for backgrounds colors to work.
//
// <informalexample><programlisting> static void
// browser_window_set_background_color (BrowserWindow *window, const GdkRGBA
// *rgba) { WebKitWebView *web_view; GdkScreen *screen = gtk_window_get_screen
// (GTK_WINDOW (window)); GdkVisual *rgba_visual = gdk_screen_get_rgba_visual
// (screen);
//
//    if (!rgba_visual)
//         return;
//
//    gtk_widget_set_visual (GTK_WIDGET (window), rgba_visual);
//    gtk_widget_set_app_paintable (GTK_WIDGET (window), TRUE);
//
//    web_view = browser_window_get_web_view (window);
//    webkit_web_view_set_background_color (web_view, rgba);
//
// } </programlisting></informalexample>.
//
// The function takes the following parameters:
//
//    - rgba: RGBA.
//
func (webView *WebView) SetBackgroundColor(rgba *gdk.RGBA) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.GdkRGBA       // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(rgba)))

	C.webkit_web_view_set_background_color(_arg0, _arg1)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(rgba)
}

// SetCustomCharset sets the current custom character encoding override of
// web_view. The custom character encoding will override any text encoding
// detected via HTTP headers or META tags. Calling this method will stop any
// current load operation and reload the current page. Setting the custom
// character encoding to NULL removes the character encoding override.
//
// The function takes the following parameters:
//
//    - charset: character encoding name or NULL.
//
func (webView *WebView) SetCustomCharset(charset string) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	if charset != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(charset)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.webkit_web_view_set_custom_charset(_arg0, _arg1)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(charset)
}

// SetEditable sets whether the user is allowed to edit the HTML document.
//
// If editable is TRUE, web_view allows the user to edit the HTML document. If
// editable is FALSE, an element in web_view's document can only be edited if
// the CONTENTEDITABLE attribute has been set on the element or one of its
// parent elements. By default a KitWebView is not editable.
//
// Normally, a HTML document is not editable unless the elements within the
// document are editable. This function provides a way to make the contents of a
// KitWebView editable without altering the document or DOM structure.
//
// The function takes the following parameters:
//
//    - editable indicating the editable state.
//
func (webView *WebView) SetEditable(editable bool) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	if editable {
		_arg1 = C.TRUE
	}

	C.webkit_web_view_set_editable(_arg0, _arg1)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(editable)
}

// SetInputMethodContext: set the KitInputMethodContext to be used by web_view,
// or NULL to not use any input method. Note that the same KitInputMethodContext
// can't be set on more than one KitWebView at the same time.
//
// The function takes the following parameters:
//
//    - context to set, or NULL.
//
func (webView *WebView) SetInputMethodContext(context InputMethodContexter) {
	var _arg0 *C.WebKitWebView            // out
	var _arg1 *C.WebKitInputMethodContext // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	if context != nil {
		_arg1 = (*C.WebKitInputMethodContext)(unsafe.Pointer(context.Native()))
	}

	C.webkit_web_view_set_input_method_context(_arg0, _arg1)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(context)
}

// SetIsMuted sets the mute state of web_view.
//
// The function takes the following parameters:
//
//    - muted: mute flag.
//
func (webView *WebView) SetIsMuted(muted bool) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	if muted {
		_arg1 = C.TRUE
	}

	C.webkit_web_view_set_is_muted(_arg0, _arg1)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(muted)
}

// SetSettings sets the KitSettings to be applied to web_view. The existing
// KitSettings of web_view will be replaced by settings. New settings are
// applied immediately on web_view. The same KitSettings object can be shared by
// multiple KitWebView<!-- -->s.
//
// The function takes the following parameters:
//
//    - settings: KitSettings.
//
func (webView *WebView) SetSettings(settings *Settings) {
	var _arg0 *C.WebKitWebView  // out
	var _arg1 *C.WebKitSettings // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.WebKitSettings)(unsafe.Pointer(settings.Native()))

	C.webkit_web_view_set_settings(_arg0, _arg1)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(settings)
}

// SetZoomLevel: set the zoom level of web_view, i.e. the factor by which the
// view contents are scaled with respect to their original size.
//
// The function takes the following parameters:
//
//    - zoomLevel: zoom level.
//
func (webView *WebView) SetZoomLevel(zoomLevel float64) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 C.gdouble        // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = C.gdouble(zoomLevel)

	C.webkit_web_view_set_zoom_level(_arg0, _arg1)
	runtime.KeepAlive(webView)
	runtime.KeepAlive(zoomLevel)
}

// StopLoading stops any ongoing loading operation in web_view. This method does
// nothing if no content is being loaded. If there is a loading operation in
// progress, it will be cancelled and KitWebView::load-failed signal will be
// emitted with WEBKIT_NETWORK_ERROR_CANCELLED error.
func (webView *WebView) StopLoading() {
	var _arg0 *C.WebKitWebView // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	C.webkit_web_view_stop_loading(_arg0)
	runtime.KeepAlive(webView)
}

// TryClose tries to close the web_view. This will fire the onbeforeunload event
// to ask the user for confirmation to close the page. If there isn't an
// onbeforeunload event handler or the user confirms to close the page, the
// KitWebView::close signal is emitted, otherwise nothing happens.
func (webView *WebView) TryClose() {
	var _arg0 *C.WebKitWebView // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	C.webkit_web_view_try_close(_arg0)
	runtime.KeepAlive(webView)
}

// ConnectAuthenticate: this signal is emitted when the user is challenged with
// HTTP authentication. To let the application access or supply the credentials
// as well as to allow the client application to either cancel the request or
// perform the authentication, the signal will pass an instance of the
// KitAuthenticationRequest in the request argument. To handle this signal
// asynchronously you should keep a ref of the request and return TRUE. To
// disable HTTP authentication entirely, connect to this signal and simply
// return TRUE.
//
// The default signal handler will run a default authentication dialog
// asynchronously for the user to interact with.
func (webView *WebView) ConnectAuthenticate(f func(request AuthenticationRequest) bool) externglib.SignalHandle {
	return webView.Connect("authenticate", f)
}

// ConnectClose: emitted when closing a KitWebView is requested. This occurs
// when a call is made from JavaScript's <function>window.close</function>
// function or after trying to close the web_view with
// webkit_web_view_try_close(). It is the owner's responsibility to handle this
// signal to hide or destroy the KitWebView, if necessary.
func (webView *WebView) ConnectClose(f func()) externglib.SignalHandle {
	return webView.Connect("close", f)
}

// ConnectContextMenu: emitted when a context menu is about to be displayed to
// give the application a chance to customize the proposed menu, prevent the
// menu from being displayed, or build its own context menu. <itemizedlist>
// <listitem><para> To customize the proposed menu you can use
// webkit_context_menu_prepend(), webkit_context_menu_append() or
// webkit_context_menu_insert() to add new KitContextMenuItem<!-- -->s to
// context_menu, webkit_context_menu_move_item() to reorder existing items, or
// webkit_context_menu_remove() to remove an existing item. The signal handler
// should return FALSE, and the menu represented by context_menu will be shown.
// </para></listitem> <listitem><para> To prevent the menu from being displayed
// you can just connect to this signal and return TRUE so that the proposed menu
// will not be shown. </para></listitem> <listitem><para> To build your own
// menu, you can remove all items from the proposed menu with
// webkit_context_menu_remove_all(), add your own items and return FALSE so that
// the menu will be shown. You can also ignore the proposed KitContextMenu,
// build your own Menu and return TRUE to prevent the proposed menu from being
// shown. </para></listitem> <listitem><para> If you just want the default menu
// to be shown always, simply don't connect to this signal because showing the
// proposed context menu is the default behaviour. </para></listitem>
// </itemizedlist>
//
// The event is expected to be one of the following types: <itemizedlist>
// <listitem><para> a EventButton of type GDK_BUTTON_PRESS when the context menu
// was triggered with mouse. </para></listitem> <listitem><para> a EventKey of
// type GDK_KEY_PRESS if the keyboard was used to show the menu.
// </para></listitem> <listitem><para> a generic Event of type GDK_NOTHING when
// the Widget::popup-menu signal was used to show the context menu.
// </para></listitem> </itemizedlist>
//
// If the signal handler returns FALSE the context menu represented by
// context_menu will be shown, if it return TRUE the context menu will not be
// shown.
//
// The proposed KitContextMenu passed in context_menu argument is only valid
// during the signal emission.
func (webView *WebView) ConnectContextMenu(f func(contextMenu ContextMenu, event *gdk.Event, hitTestResult HitTestResult) bool) externglib.SignalHandle {
	return webView.Connect("context-menu", f)
}

// ConnectContextMenuDismissed: emitted after KitWebView::context-menu signal,
// if the context menu is shown, to notify that the context menu is dismissed.
func (webView *WebView) ConnectContextMenuDismissed(f func()) externglib.SignalHandle {
	return webView.Connect("context-menu-dismissed", f)
}

// ConnectCreate: emitted when the creation of a new KitWebView is requested. If
// this signal is handled the signal handler should return the newly created
// KitWebView.
//
// The KitNavigationAction parameter contains information about the navigation
// action that triggered this signal.
//
// The new KitWebView must be related to web_view, see
// webkit_web_view_new_with_related_view() for more details.
//
// The new KitWebView should not be displayed to the user until the
// KitWebView::ready-to-show signal is emitted.
func (webView *WebView) ConnectCreate(f func(navigationAction *NavigationAction) gtk.Widgetter) externglib.SignalHandle {
	return webView.Connect("create", f)
}

// ConnectDecidePolicy: this signal is emitted when WebKit is requesting the
// client to decide a policy decision, such as whether to navigate to a page,
// open a new window or whether or not to download a resource. The
// KitNavigationPolicyDecision passed in the decision argument is a generic
// type, but should be casted to a more specific type when making the decision.
// For example:
//
// <informalexample><programlisting> static gboolean decide_policy_cb
// (WebKitWebView *web_view, WebKitPolicyDecision *decision,
// WebKitPolicyDecisionType type) { switch (type) { case
// WEBKIT_POLICY_DECISION_TYPE_NAVIGATION_ACTION: {
// WebKitNavigationPolicyDecision *navigation_decision =
// WEBKIT_NAVIGATION_POLICY_DECISION (decision); /<!-- -->* Make a policy
// decision here. *<!-- -->/ break; } case
// WEBKIT_POLICY_DECISION_TYPE_NEW_WINDOW_ACTION: {
// WebKitNavigationPolicyDecision *navigation_decision =
// WEBKIT_NAVIGATION_POLICY_DECISION (decision); /<!-- -->* Make a policy
// decision here. *<!-- -->/ break; } case WEBKIT_POLICY_DECISION_TYPE_RESPONSE:
// WebKitResponsePolicyDecision *response = WEBKIT_RESPONSE_POLICY_DECISION
// (decision); /<!-- -->* Make a policy decision here. *<!-- -->/ break;
// default: /<!-- -->* Making no decision results in
// webkit_policy_decision_use(). *<!-- -->/ return FALSE; } return TRUE; }
// </programlisting></informalexample>
//
// It is possible to make policy decision asynchronously, by simply calling
// g_object_ref() on the decision argument and returning TRUE to block the
// default signal handler. If the last reference is removed on a
// KitPolicyDecision and no decision has been made explicitly,
// webkit_policy_decision_use() will be the default policy decision. The default
// signal handler will simply call webkit_policy_decision_use(). Only the first
// policy decision chosen for a given KitPolicyDecision will have any affect.
func (webView *WebView) ConnectDecidePolicy(f func(decision PolicyDecisioner, decisionType PolicyDecisionType) bool) externglib.SignalHandle {
	return webView.Connect("decide-policy", f)
}

// ConnectEnterFullscreen: emitted when JavaScript code calls
// <function>element.webkitRequestFullScreen</function>. If the signal is not
// handled the KitWebView will proceed to full screen its top level window. This
// signal can be used by client code to request permission to the user prior
// doing the full screen transition and eventually prepare the top-level window
// (e.g. hide some widgets that would otherwise be part of the full screen
// window).
func (webView *WebView) ConnectEnterFullscreen(f func() bool) externglib.SignalHandle {
	return webView.Connect("enter-fullscreen", f)
}

// ConnectInsecureContentDetected: this signal is emitted when insecure content
// has been detected in a page loaded through a secure connection. This
// typically means that a external resource from an unstrusted source has been
// run or displayed, resulting in a mix of HTTPS and non-HTTPS content.
//
// You can check the event parameter to know exactly which kind of event has
// been detected (see KitInsecureContentEvent).
func (webView *WebView) ConnectInsecureContentDetected(f func(event InsecureContentEvent)) externglib.SignalHandle {
	return webView.Connect("insecure-content-detected", f)
}

// ConnectLeaveFullscreen: emitted when the KitWebView is about to restore its
// top level window out of its full screen state. This signal can be used by
// client code to restore widgets hidden during the KitWebView::enter-fullscreen
// stage for instance.
func (webView *WebView) ConnectLeaveFullscreen(f func() bool) externglib.SignalHandle {
	return webView.Connect("leave-fullscreen", f)
}

// ConnectLoadChanged: emitted when a load operation in web_view changes. The
// signal is always emitted with WEBKIT_LOAD_STARTED when a new load request is
// made and WEBKIT_LOAD_FINISHED when the load finishes successfully or due to
// an error. When the ongoing load operation fails KitWebView::load-failed
// signal is emitted before KitWebView::load-changed is emitted with
// WEBKIT_LOAD_FINISHED. If a redirection is received from the server, this
// signal is emitted with WEBKIT_LOAD_REDIRECTED after the initial emission with
// WEBKIT_LOAD_STARTED and before WEBKIT_LOAD_COMMITTED. When the page content
// starts arriving the signal is emitted with WEBKIT_LOAD_COMMITTED event.
//
// You can handle this signal and use a switch to track any ongoing load
// operation.
//
// <informalexample><programlisting> static void web_view_load_changed
// (WebKitWebView *web_view, WebKitLoadEvent load_event, gpointer user_data) {
// switch (load_event) { case WEBKIT_LOAD_STARTED: /<!-- -->* New load, we have
// now a provisional URI *<!-- -->/ provisional_uri = webkit_web_view_get_uri
// (web_view); /<!-- -->* Here we could start a spinner or update the <!-- -->*
// location bar with the provisional URI *<!-- -->/ break; case
// WEBKIT_LOAD_REDIRECTED: redirected_uri = webkit_web_view_get_uri (web_view);
// break; case WEBKIT_LOAD_COMMITTED: /<!-- -->* The load is being performed.
// Current URI is <!-- -->* the final one and it won't change unless a new <!--
// -->* load is requested or a navigation within the <!-- -->* same page is
// performed *<!-- -->/ uri = webkit_web_view_get_uri (web_view); break; case
// WEBKIT_LOAD_FINISHED: /<!-- -->* Load finished, we can now stop the spinner
// *<!-- -->/ break; } } </programlisting></informalexample>.
func (webView *WebView) ConnectLoadChanged(f func(loadEvent LoadEvent)) externglib.SignalHandle {
	return webView.Connect("load-changed", f)
}

// ConnectLoadFailedWithTLSErrors: emitted when a TLS error occurs during a load
// operation. To allow an exception for this certificate and the host of
// failing_uri use webkit_web_context_allow_tls_certificate_for_host().
//
// To handle this signal asynchronously you should call g_object_ref() on
// certificate and return TRUE.
//
// If FALSE is returned, KitWebView::load-failed will be emitted. The load will
// finish regardless of the returned value.
func (webView *WebView) ConnectLoadFailedWithTLSErrors(f func(failingUri string, certificate gio.TLSCertificater, errors gio.TLSCertificateFlags) bool) externglib.SignalHandle {
	return webView.Connect("load-failed-with-tls-errors", f)
}

// ConnectMouseTargetChanged: this signal is emitted when the mouse cursor moves
// over an element such as a link, image or a media element. To determine what
// type of element the mouse cursor is over, a Hit Test is performed on the
// current mouse coordinates and the result is passed in the hit_test_result
// argument. The modifiers argument is a bitmask of ModifierType flags
// indicating the state of modifier keys. The signal is emitted again when the
// mouse is moved out of the current element with a new hit_test_result.
func (webView *WebView) ConnectMouseTargetChanged(f func(hitTestResult HitTestResult, modifiers uint)) externglib.SignalHandle {
	return webView.Connect("mouse-target-changed", f)
}

// ConnectPermissionRequest: this signal is emitted when WebKit is requesting
// the client to decide about a permission request, such as allowing the browser
// to switch to fullscreen mode, sharing its location or similar operations.
//
// A possible way to use this signal could be through a dialog allowing the user
// decide what to do with the request:
//
// <informalexample><programlisting> static gboolean permission_request_cb
// (WebKitWebView *web_view, WebKitPermissionRequest *request, GtkWindow
// *parent_window) { GtkWidget *dialog = gtk_message_dialog_new (parent_window,
// GTK_DIALOG_MODAL, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO, "Allow Permission
// Request?"); gtk_widget_show (dialog); gint result = gtk_dialog_run
// (GTK_DIALOG (dialog));
//
//    switch (result) {
//    case GTK_RESPONSE_YES:
//        webkit_permission_request_allow (request);
//        break;
//    default:
//        webkit_permission_request_deny (request);
//        break;
//    }
//    gtk_widget_destroy (dialog);
//
//    return TRUE;
//
// } </programlisting></informalexample>
//
// It is possible to handle permission requests asynchronously, by simply
// calling g_object_ref() on the request argument and returning TRUE to block
// the default signal handler. If the last reference is removed on a
// KitPermissionRequest and the request has not been handled,
// webkit_permission_request_deny() will be the default action.
//
// If the signal is not handled, the request will be completed automatically by
// the specific KitPermissionRequest that could allow or deny it. Check the
// documentation of classes implementing KitPermissionRequest interface to know
// their default action.
func (webView *WebView) ConnectPermissionRequest(f func(request PermissionRequester) bool) externglib.SignalHandle {
	return webView.Connect("permission-request", f)
}

// ConnectPrint: emitted when printing is requested on web_view, usually by a
// JavaScript call, before the print dialog is shown. This signal can be used to
// set the initial print settings and page setup of print_operation to be used
// as default values in the print dialog. You can call
// webkit_print_operation_set_print_settings() and
// webkit_print_operation_set_page_setup() and then return FALSE to propagate
// the event so that the print dialog is shown.
//
// You can connect to this signal and return TRUE to cancel the print operation
// or implement your own print dialog.
func (webView *WebView) ConnectPrint(f func(printOperation PrintOperation) bool) externglib.SignalHandle {
	return webView.Connect("print", f)
}

// ConnectReadyToShow: emitted after KitWebView::create on the newly created
// KitWebView when it should be displayed to the user. When this signal is
// emitted all the information about how the window should look, including size,
// position, whether the location, status and scrollbars should be displayed, is
// already set on the KitWindowProperties of web_view. See also
// webkit_web_view_get_window_properties().
func (webView *WebView) ConnectReadyToShow(f func()) externglib.SignalHandle {
	return webView.Connect("ready-to-show", f)
}

// ConnectResourceLoadStarted: emitted when a new resource is going to be
// loaded. The request parameter contains the KitURIRequest that will be sent to
// the server. You can monitor the load operation by connecting to the different
// signals of resource.
func (webView *WebView) ConnectResourceLoadStarted(f func(resource WebResource, request URIRequest)) externglib.SignalHandle {
	return webView.Connect("resource-load-started", f)
}

// ConnectRunAsModal: emitted after KitWebView::ready-to-show on the newly
// created KitWebView when JavaScript code calls
// <function>window.showModalDialog</function>. The purpose of this signal is to
// allow the client application to prepare the new view to behave as modal. Once
// the signal is emitted a new main loop will be run to block user interaction
// in the parent KitWebView until the new dialog is closed.
func (webView *WebView) ConnectRunAsModal(f func()) externglib.SignalHandle {
	return webView.Connect("run-as-modal", f)
}

// ConnectRunColorChooser: this signal is emitted when the user interacts with a
// &lt;input type='color' /&gt; HTML element, requesting from WebKit to show a
// dialog to select a color. To let the application know the details of the
// color chooser, as well as to allow the client application to either cancel
// the request or perform an actual color selection, the signal will pass an
// instance of the KitColorChooserRequest in the request argument.
//
// It is possible to handle this request asynchronously by increasing the
// reference count of the request.
//
// The default signal handler will asynchronously run a regular ColorChooser for
// the user to interact with.
func (webView *WebView) ConnectRunColorChooser(f func(request ColorChooserRequest) bool) externglib.SignalHandle {
	return webView.Connect("run-color-chooser", f)
}

// ConnectRunFileChooser: this signal is emitted when the user interacts with a
// &lt;input type='file' /&gt; HTML element, requesting from WebKit to show a
// dialog to select one or more files to be uploaded. To let the application
// know the details of the file chooser, as well as to allow the client
// application to either cancel the request or perform an actual selection of
// files, the signal will pass an instance of the KitFileChooserRequest in the
// request argument.
//
// The default signal handler will asynchronously run a regular
// FileChooserDialog for the user to interact with.
func (webView *WebView) ConnectRunFileChooser(f func(request FileChooserRequest) bool) externglib.SignalHandle {
	return webView.Connect("run-file-chooser", f)
}

// ConnectScriptDialog: emitted when JavaScript code calls
// <function>window.alert</function>, <function>window.confirm</function> or
// <function>window.prompt</function>, or when
// <function>onbeforeunload</function> event is fired. The dialog parameter
// should be used to build the dialog. If the signal is not handled a different
// dialog will be built and shown depending on the dialog type: <itemizedlist>
// <listitem><para> WEBKIT_SCRIPT_DIALOG_ALERT: message dialog with a single
// Close button. </para></listitem> <listitem><para>
// WEBKIT_SCRIPT_DIALOG_CONFIRM: message dialog with OK and Cancel buttons.
// </para></listitem> <listitem><para> WEBKIT_SCRIPT_DIALOG_PROMPT: message
// dialog with OK and Cancel buttons and a text entry with the default text.
// </para></listitem> <listitem><para>
// WEBKIT_SCRIPT_DIALOG_BEFORE_UNLOAD_CONFIRM: message dialog with Stay and
// Leave buttons. </para></listitem> </itemizedlist>
//
// It is possible to handle the script dialog request asynchronously, by simply
// caling webkit_script_dialog_ref() on the dialog argument and calling
// webkit_script_dialog_close() when done. If the last reference is removed on a
// KitScriptDialog and the dialog has not been closed,
// webkit_script_dialog_close() will be called.
func (webView *WebView) ConnectScriptDialog(f func(dialog *ScriptDialog) bool) externglib.SignalHandle {
	return webView.Connect("script-dialog", f)
}

// ConnectShowNotification: this signal is emitted when a notification should be
// presented to the user. The notification is kept alive until either: 1) the
// web page cancels it or 2) a navigation happens.
//
// The default handler will emit a notification using libnotify, if built with
// support for it.
func (webView *WebView) ConnectShowNotification(f func(notification Notification) bool) externglib.SignalHandle {
	return webView.Connect("show-notification", f)
}

// ConnectShowOptionMenu: this signal is emitted when a select element in
// web_view needs to display a dropdown menu. This signal can be used to show a
// custom menu, using menu to get the details of all items that should be
// displayed. The area of the element in the KitWebView is given as rectangle
// parameter, it can be used to position the menu. To handle this signal
// asynchronously you should keep a ref of the menu.
func (webView *WebView) ConnectShowOptionMenu(f func(object OptionMenu, p0 *gdk.Event, p1 *gdk.Rectangle) bool) externglib.SignalHandle {
	return webView.Connect("show-option-menu", f)
}

// ConnectSubmitForm: this signal is emitted when a form is about to be
// submitted. The request argument passed contains information about the text
// fields of the form. This is typically used to store login information that
// can be used later to pre-fill the form. The form will not be submitted until
// webkit_form_submission_request_submit() is called.
//
// It is possible to handle the form submission request asynchronously, by
// simply calling g_object_ref() on the request argument and calling
// webkit_form_submission_request_submit() when done to continue with the form
// submission. If the last reference is removed on a KitFormSubmissionRequest
// and the form has not been submitted, webkit_form_submission_request_submit()
// will be called.
func (webView *WebView) ConnectSubmitForm(f func(request FormSubmissionRequest)) externglib.SignalHandle {
	return webView.Connect("submit-form", f)
}

// ConnectUserMessageReceived: this signal is emitted when a KitUserMessage is
// received from the KitWebPage corresponding to web_view. You can reply to the
// message using webkit_user_message_send_reply().
//
// You can handle the user message asynchronously by calling g_object_ref() on
// message and returning TRUE. If the last reference of message is removed and
// the message has not been replied to, the operation in the KitWebPage will
// finish with error WEBKIT_USER_MESSAGE_UNHANDLED_MESSAGE.
func (webView *WebView) ConnectUserMessageReceived(f func(message UserMessage) bool) externglib.SignalHandle {
	return webView.Connect("user-message-received", f)
}

// ConnectWebProcessCrashed: this signal is emitted when the web process
// crashes.
func (webView *WebView) ConnectWebProcessCrashed(f func() bool) externglib.SignalHandle {
	return webView.Connect("web-process-crashed", f)
}

// ConnectWebProcessTerminated: this signal is emitted when the web process
// terminates abnormally due to reason.
func (webView *WebView) ConnectWebProcessTerminated(f func(reason WebProcessTerminationReason)) externglib.SignalHandle {
	return webView.Connect("web-process-terminated", f)
}
