// Code generated by girgen. DO NOT EDIT.

package webkit2

import (
	"context"
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/gtk/v3"
	"github.com/gotk3/gotk3/cairo"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: webkit2gtk-4.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <webkit2/webkit2.h>
// void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.webkit_insecure_content_event_get_type()), F: marshalInsecureContentEvent},
		{T: externglib.Type(C.webkit_load_event_get_type()), F: marshalLoadEvent},
		{T: externglib.Type(C.webkit_policy_decision_type_get_type()), F: marshalPolicyDecisionType},
		{T: externglib.Type(C.webkit_save_mode_get_type()), F: marshalSaveMode},
		{T: externglib.Type(C.webkit_snapshot_region_get_type()), F: marshalSnapshotRegion},
		{T: externglib.Type(C.webkit_web_process_termination_reason_get_type()), F: marshalWebProcessTerminationReason},
		{T: externglib.Type(C.webkit_snapshot_options_get_type()), F: marshalSnapshotOptions},
		{T: externglib.Type(C.webkit_web_view_get_type()), F: marshalWebViewer},
	})
}

// InsecureContentEvent: enum values used to denote the different events which
// can trigger the detection of insecure content.
type InsecureContentEvent int

const (
	// InsecureContentRun: insecure content has been detected by trying to
	// execute any kind of logic (e.g. a script) from an untrusted source.
	InsecureContentRun InsecureContentEvent = iota
	// InsecureContentDisplayed: insecure content has been detected by trying to
	// display any kind of resource (e.g. an image) from an untrusted source.
	InsecureContentDisplayed
)

func marshalInsecureContentEvent(p uintptr) (interface{}, error) {
	return InsecureContentEvent(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for InsecureContentEvent.
func (i InsecureContentEvent) String() string {
	switch i {
	case InsecureContentRun:
		return "Run"
	case InsecureContentDisplayed:
		return "Displayed"
	default:
		return fmt.Sprintf("InsecureContentEvent(%d)", i)
	}
}

// LoadEvent: enum values used to denote the different events that happen during
// a KitWebView load operation.
type LoadEvent int

const (
	// LoadStarted: new load request has been made. No data has been received
	// yet, empty structures have been allocated to perform the load; the load
	// may still fail due to transport issues such as not being able to resolve
	// a name, or connect to a port.
	LoadStarted LoadEvent = iota
	// LoadRedirected: provisional data source received a server redirect.
	LoadRedirected
	// LoadCommitted: content started arriving for a page load. The necessary
	// transport requirements are established, and the load is being performed.
	LoadCommitted
	// LoadFinished: load completed. All resources are done loading or there was
	// an error during the load operation.
	LoadFinished
)

func marshalLoadEvent(p uintptr) (interface{}, error) {
	return LoadEvent(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for LoadEvent.
func (l LoadEvent) String() string {
	switch l {
	case LoadStarted:
		return "Started"
	case LoadRedirected:
		return "Redirected"
	case LoadCommitted:
		return "Committed"
	case LoadFinished:
		return "Finished"
	default:
		return fmt.Sprintf("LoadEvent(%d)", l)
	}
}

// PolicyDecisionType: enum values used for determining the type of a policy
// decision during KitWebView::decide-policy.
type PolicyDecisionType int

const (
	// PolicyDecisionTypeNavigationAction: this type of policy decision is
	// requested when WebKit is about to navigate to a new page in either the
	// main frame or a subframe. Acceptable policy decisions are either
	// webkit_policy_decision_use() or webkit_policy_decision_ignore(). This
	// type of policy decision is always a KitNavigationPolicyDecision.
	PolicyDecisionTypeNavigationAction PolicyDecisionType = iota
	// PolicyDecisionTypeNewWindowAction: this type of policy decision is
	// requested when WebKit is about to create a new window. Acceptable policy
	// decisions are either webkit_policy_decision_use() or
	// webkit_policy_decision_ignore(). This type of policy decision is always a
	// KitNavigationPolicyDecision. These decisions are useful for implementing
	// special actions for new windows, such as forcing the new window to open
	// in a tab when a keyboard modifier is active or handling a special target
	// attribute on &lt;a&gt; elements.
	PolicyDecisionTypeNewWindowAction
	// PolicyDecisionTypeResponse: this type of decision is used when WebKit has
	// received a response for a network resource and is about to start the
	// load. Note that these resources include all subresources of a page such
	// as images and stylesheets as well as main documents. Appropriate policy
	// responses to this decision are webkit_policy_decision_use(),
	// webkit_policy_decision_ignore(), or webkit_policy_decision_download().
	// This type of policy decision is always a KitResponsePolicyDecision. This
	// decision is useful for forcing some types of resources to be downloaded
	// rather than rendered in the WebView or to block the transfer of resources
	// entirely.
	PolicyDecisionTypeResponse
)

func marshalPolicyDecisionType(p uintptr) (interface{}, error) {
	return PolicyDecisionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for PolicyDecisionType.
func (p PolicyDecisionType) String() string {
	switch p {
	case PolicyDecisionTypeNavigationAction:
		return "NavigationAction"
	case PolicyDecisionTypeNewWindowAction:
		return "NewWindowAction"
	case PolicyDecisionTypeResponse:
		return "Response"
	default:
		return fmt.Sprintf("PolicyDecisionType(%d)", p)
	}
}

// SaveMode: enum values to specify the different ways in which a KitWebView can
// save its current web page into a self-contained file.
type SaveMode int

const (
	// SaveModeMhtml: save the current page using the MHTML format.
	SaveModeMhtml SaveMode = iota
)

func marshalSaveMode(p uintptr) (interface{}, error) {
	return SaveMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for SaveMode.
func (s SaveMode) String() string {
	switch s {
	case SaveModeMhtml:
		return "Mhtml"
	default:
		return fmt.Sprintf("SaveMode(%d)", s)
	}
}

// SnapshotRegion: enum values used to specify the region from which to get a
// KitWebView snapshot
type SnapshotRegion int

const (
	// SnapshotRegionVisible specifies a snapshot only for the area that is
	// visible in the webview
	SnapshotRegionVisible SnapshotRegion = iota
	// SnapshotRegionFullDocument: snapshot of the entire document.
	SnapshotRegionFullDocument
)

func marshalSnapshotRegion(p uintptr) (interface{}, error) {
	return SnapshotRegion(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for SnapshotRegion.
func (s SnapshotRegion) String() string {
	switch s {
	case SnapshotRegionVisible:
		return "Visible"
	case SnapshotRegionFullDocument:
		return "FullDocument"
	default:
		return fmt.Sprintf("SnapshotRegion(%d)", s)
	}
}

// WebProcessTerminationReason: enum values used to specify the reason why the
// web process terminated abnormally.
type WebProcessTerminationReason int

const (
	// WebProcessCrashed: web process crashed.
	WebProcessCrashed WebProcessTerminationReason = iota
	// WebProcessExceededMemoryLimit: web process exceeded the memory limit.
	WebProcessExceededMemoryLimit
)

func marshalWebProcessTerminationReason(p uintptr) (interface{}, error) {
	return WebProcessTerminationReason(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for WebProcessTerminationReason.
func (w WebProcessTerminationReason) String() string {
	switch w {
	case WebProcessCrashed:
		return "Crashed"
	case WebProcessExceededMemoryLimit:
		return "ExceededMemoryLimit"
	default:
		return fmt.Sprintf("WebProcessTerminationReason(%d)", w)
	}
}

// SnapshotOptions: enum values used to specify options when taking a snapshot
// from a KitWebView.
type SnapshotOptions int

const (
	// SnapshotOptionsNone: do not include any special options.
	SnapshotOptionsNone SnapshotOptions = 0b0
	// SnapshotOptionsIncludeSelectionHighlighting: whether to include in the
	// snapshot the highlight of the selected content.
	SnapshotOptionsIncludeSelectionHighlighting SnapshotOptions = 0b1
	// SnapshotOptionsTransparentBackground: do not fill the background with
	// white before rendering the snapshot. Since 2.8
	SnapshotOptionsTransparentBackground SnapshotOptions = 0b10
)

func marshalSnapshotOptions(p uintptr) (interface{}, error) {
	return SnapshotOptions(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the names in string for SnapshotOptions.
func (s SnapshotOptions) String() string {
	if s == 0 {
		return "SnapshotOptions(0)"
	}

	var builder strings.Builder
	builder.Grow(100)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case SnapshotOptionsNone:
			builder.WriteString("None|")
		case SnapshotOptionsIncludeSelectionHighlighting:
			builder.WriteString("IncludeSelectionHighlighting|")
		case SnapshotOptionsTransparentBackground:
			builder.WriteString("TransparentBackground|")
		default:
			builder.WriteString(fmt.Sprintf("SnapshotOptions(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// WebViewOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type WebViewOverrider interface {
	Authenticate(request *AuthenticationRequest) bool
	Close()
	ContextMenuDismissed()
	DecidePolicy(decision PolicyDecisioner, typ PolicyDecisionType) bool
	EnterFullscreen() bool
	InsecureContentDetected(event InsecureContentEvent)
	LeaveFullscreen() bool
	LoadChanged(loadEvent LoadEvent)
	LoadFailed(loadEvent LoadEvent, failingUri string, err error) bool
	LoadFailedWithTLSErrors(failingUri string, certificate gio.TLSCertificater, errors gio.TLSCertificateFlags) bool
	MouseTargetChanged(hitTestResult *HitTestResult, modifiers uint)
	PermissionRequest(permissionRequest PermissionRequester) bool
	Print(printOperation *PrintOperation) bool
	ReadyToShow()
	ResourceLoadStarted(resource *WebResource, request *URIRequest)
	RunAsModal()
	RunColorChooser(request *ColorChooserRequest) bool
	RunFileChooser(request *FileChooserRequest) bool
	ScriptDialog(dialog *ScriptDialog) bool
	ShowNotification(notification *Notification) bool
	ShowOptionMenu(rectangle *gdk.Rectangle, menu *OptionMenu) bool
	SubmitForm(request *FormSubmissionRequest)
	UserMessageReceived(message *UserMessage) bool
	WebProcessCrashed() bool
	WebProcessTerminated(reason WebProcessTerminationReason)
}

type WebView struct {
	WebViewBase
}

var _ gextras.Nativer = (*WebView)(nil)

func wrapWebView(obj *externglib.Object) *WebView {
	return &WebView{
		WebViewBase: WebViewBase{
			Container: gtk.Container{
				Widget: gtk.Widget{
					InitiallyUnowned: externglib.InitiallyUnowned{
						Object: obj,
					},
					ImplementorIface: atk.ImplementorIface{
						Object: obj,
					},
					Buildable: gtk.Buildable{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalWebViewer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWebView(obj), nil
}

// NewWebView creates a new KitWebView with the default KitWebContext and no
// KitUserContentManager associated with it. See also
// webkit_web_view_new_with_context(),
// webkit_web_view_new_with_user_content_manager(), and
// webkit_web_view_new_with_settings().
func NewWebView() *WebView {
	var _cret *C.GtkWidget // in

	_cret = C.webkit_web_view_new()

	var _webView *WebView // out

	_webView = wrapWebView(externglib.Take(unsafe.Pointer(_cret)))

	return _webView
}

// NewWebViewWithContext creates a new KitWebView with the given KitWebContext
// and no KitUserContentManager associated with it. See also
// webkit_web_view_new_with_user_content_manager() and
// webkit_web_view_new_with_settings().
func NewWebViewWithContext(context *WebContext) *WebView {
	var _arg1 *C.WebKitWebContext // out
	var _cret *C.GtkWidget        // in

	_arg1 = (*C.WebKitWebContext)(unsafe.Pointer(context.Native()))

	_cret = C.webkit_web_view_new_with_context(_arg1)

	var _webView *WebView // out

	_webView = wrapWebView(externglib.Take(unsafe.Pointer(_cret)))

	return _webView
}

// NewWebViewWithRelatedView creates a new KitWebView sharing the same web
// process with web_view. This method doesn't have any effect when
// WEBKIT_PROCESS_MODEL_SHARED_SECONDARY_PROCESS process model is used, because
// a single web process is shared for all the web views in the same
// KitWebContext. When using WEBKIT_PROCESS_MODEL_MULTIPLE_SECONDARY_PROCESSES
// process model, this method should always be used when creating the KitWebView
// in the KitWebView::create signal. You can also use this method to implement
// other process models based on
// WEBKIT_PROCESS_MODEL_MULTIPLE_SECONDARY_PROCESSES, like for example, sharing
// the same web process for all the views in the same security domain.
//
// The newly created KitWebView will also have the same KitUserContentManager,
// KitSettings, and KitWebsitePolicies as web_view.
func NewWebViewWithRelatedView(webView *WebView) *WebView {
	var _arg1 *C.WebKitWebView // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_new_with_related_view(_arg1)

	var _webView *WebView // out

	_webView = wrapWebView(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _webView
}

// NewWebViewWithSettings creates a new KitWebView with the given KitSettings.
// See also webkit_web_view_new_with_context(), and
// webkit_web_view_new_with_user_content_manager().
func NewWebViewWithSettings(settings *Settings) *WebView {
	var _arg1 *C.WebKitSettings // out
	var _cret *C.GtkWidget      // in

	_arg1 = (*C.WebKitSettings)(unsafe.Pointer(settings.Native()))

	_cret = C.webkit_web_view_new_with_settings(_arg1)

	var _webView *WebView // out

	_webView = wrapWebView(externglib.Take(unsafe.Pointer(_cret)))

	return _webView
}

// NewWebViewWithUserContentManager creates a new KitWebView with the given
// KitUserContentManager. The content loaded in the view may be affected by the
// content injected in the view by the user content manager.
func NewWebViewWithUserContentManager(userContentManager *UserContentManager) *WebView {
	var _arg1 *C.WebKitUserContentManager // out
	var _cret *C.GtkWidget                // in

	_arg1 = (*C.WebKitUserContentManager)(unsafe.Pointer(userContentManager.Native()))

	_cret = C.webkit_web_view_new_with_user_content_manager(_arg1)

	var _webView *WebView // out

	_webView = wrapWebView(externglib.Take(unsafe.Pointer(_cret)))

	return _webView
}

// CanExecuteEditingCommand: asynchronously check if it is possible to execute
// the given editing command.
//
// When the operation is finished, callback will be called. You can then call
// webkit_web_view_can_execute_editing_command_finish() to get the result of the
// operation.
func (webView *WebView) CanExecuteEditingCommand(ctx context.Context, command string, callback gio.AsyncReadyCallback) {
	var _arg0 *C.WebKitWebView      // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(command)))
	_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg4 = C.gpointer(gbox.AssignOnce(callback))

	C.webkit_web_view_can_execute_editing_command(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// CanExecuteEditingCommandFinish: finish an asynchronous operation started with
// webkit_web_view_can_execute_editing_command().
func (webView *WebView) CanExecuteEditingCommandFinish(result gio.AsyncResulter) error {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.GAsyncResult  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((result).(gextras.Nativer).Native()))

	C.webkit_web_view_can_execute_editing_command_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// CanGoBack determines whether web_view has a previous history item.
func (webView *WebView) CanGoBack() bool {
	var _arg0 *C.WebKitWebView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_can_go_back(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanGoForward determines whether web_view has a next history item.
func (webView *WebView) CanGoForward() bool {
	var _arg0 *C.WebKitWebView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_can_go_forward(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanShowMIMEType: whether or not a MIME type can be displayed in web_view.
func (webView *WebView) CanShowMIMEType(mimeType string) bool {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.gchar         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(mimeType)))

	_cret = C.webkit_web_view_can_show_mime_type(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DownloadURI requests downloading of the specified URI string for web_view.
func (webView *WebView) DownloadURI(uri string) *Download {
	var _arg0 *C.WebKitWebView  // out
	var _arg1 *C.char           // out
	var _cret *C.WebKitDownload // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))

	_cret = C.webkit_web_view_download_uri(_arg0, _arg1)

	var _download *Download // out

	_download = wrapDownload(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _download
}

// ExecuteEditingCommand: request to execute the given command for web_view. You
// can use webkit_web_view_can_execute_editing_command() to check whether it's
// possible to execute the command.
func (webView *WebView) ExecuteEditingCommand(command string) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(command)))

	C.webkit_web_view_execute_editing_command(_arg0, _arg1)
}

// ExecuteEditingCommandWithArgument: request to execute the given command with
// argument for web_view. You can use
// webkit_web_view_can_execute_editing_command() to check whether it's possible
// to execute the command.
func (webView *WebView) ExecuteEditingCommandWithArgument(command string, argument string) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.char          // out
	var _arg2 *C.char          // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(command)))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(argument)))

	C.webkit_web_view_execute_editing_command_with_argument(_arg0, _arg1, _arg2)
}

// AutomationPresentationType: get the presentation type of KitWebView when
// created for automation.
func (webView *WebView) AutomationPresentationType() AutomationBrowsingContextPresentation {
	var _arg0 *C.WebKitWebView                              // out
	var _cret C.WebKitAutomationBrowsingContextPresentation // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_automation_presentation_type(_arg0)

	var _automationBrowsingContextPresentation AutomationBrowsingContextPresentation // out

	_automationBrowsingContextPresentation = AutomationBrowsingContextPresentation(_cret)

	return _automationBrowsingContextPresentation
}

// BackForwardList obtains the KitBackForwardList associated with the given
// KitWebView. The KitBackForwardList is owned by the KitWebView.
func (webView *WebView) BackForwardList() *BackForwardList {
	var _arg0 *C.WebKitWebView         // out
	var _cret *C.WebKitBackForwardList // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_back_forward_list(_arg0)

	var _backForwardList *BackForwardList // out

	_backForwardList = wrapBackForwardList(externglib.Take(unsafe.Pointer(_cret)))

	return _backForwardList
}

// BackgroundColor gets the color that is used to draw the web_view background
// before the actual contents are rendered. For more information see also
// webkit_web_view_set_background_color()
func (webView *WebView) BackgroundColor() gdk.RGBA {
	var _arg0 *C.WebKitWebView // out
	var _arg1 C.GdkRGBA        // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	C.webkit_web_view_get_background_color(_arg0, &_arg1)

	var _rgba gdk.RGBA // out

	_rgba = *(*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _rgba
}

// Context gets the web context of web_view.
func (webView *WebView) Context() *WebContext {
	var _arg0 *C.WebKitWebView    // out
	var _cret *C.WebKitWebContext // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_context(_arg0)

	var _webContext *WebContext // out

	_webContext = wrapWebContext(externglib.Take(unsafe.Pointer(_cret)))

	return _webContext
}

// CustomCharset returns the current custom character encoding name of web_view.
func (webView *WebView) CustomCharset() string {
	var _arg0 *C.WebKitWebView // out
	var _cret *C.gchar         // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_custom_charset(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// EditorState gets the web editor state of web_view.
func (webView *WebView) EditorState() *EditorState {
	var _arg0 *C.WebKitWebView     // out
	var _cret *C.WebKitEditorState // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_editor_state(_arg0)

	var _editorState *EditorState // out

	_editorState = wrapEditorState(externglib.Take(unsafe.Pointer(_cret)))

	return _editorState
}

// EstimatedLoadProgress gets the value of the
// KitWebView:estimated-load-progress property. You can monitor the estimated
// progress of a load operation by connecting to the
// notify::estimated-load-progress signal of web_view.
func (webView *WebView) EstimatedLoadProgress() float64 {
	var _arg0 *C.WebKitWebView // out
	var _cret C.gdouble        // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_estimated_load_progress(_arg0)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Favicon returns favicon currently associated to web_view, if any. You can
// connect to notify::favicon signal of web_view to be notified when the favicon
// is available.
func (webView *WebView) Favicon() *cairo.Surface {
	var _arg0 *C.WebKitWebView   // out
	var _cret *C.cairo_surface_t // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_favicon(_arg0)

	var _surface *cairo.Surface // out

	_surface = cairo.WrapSurface(uintptr(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
		C.cairo_surface_destroy((*C.cairo_surface_t)(unsafe.Pointer(v.Native())))
	})

	return _surface
}

// FindController gets the KitFindController that will allow the caller to query
// the KitWebView for the text to look for.
func (webView *WebView) FindController() *FindController {
	var _arg0 *C.WebKitWebView        // out
	var _cret *C.WebKitFindController // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_find_controller(_arg0)

	var _findController *FindController // out

	_findController = wrapFindController(externglib.Take(unsafe.Pointer(_cret)))

	return _findController
}

// InputMethodContext: get the KitInputMethodContext currently in use by
// web_view, or NULL if no input method is being used.
func (webView *WebView) InputMethodContext() InputMethodContexter {
	var _arg0 *C.WebKitWebView            // out
	var _cret *C.WebKitInputMethodContext // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_input_method_context(_arg0)

	var _inputMethodContext InputMethodContexter // out

	_inputMethodContext = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(InputMethodContexter)

	return _inputMethodContext
}

// Inspector: get the KitWebInspector associated to web_view
func (webView *WebView) Inspector() *WebInspector {
	var _arg0 *C.WebKitWebView      // out
	var _cret *C.WebKitWebInspector // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_inspector(_arg0)

	var _webInspector *WebInspector // out

	_webInspector = wrapWebInspector(externglib.Take(unsafe.Pointer(_cret)))

	return _webInspector
}

// IsMuted gets the mute state of web_view.
func (webView *WebView) IsMuted() bool {
	var _arg0 *C.WebKitWebView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_is_muted(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MainResource: return the main resource of web_view.
func (webView *WebView) MainResource() *WebResource {
	var _arg0 *C.WebKitWebView     // out
	var _cret *C.WebKitWebResource // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_main_resource(_arg0)

	var _webResource *WebResource // out

	_webResource = wrapWebResource(externglib.Take(unsafe.Pointer(_cret)))

	return _webResource
}

// PageID: get the identifier of the KitWebPage corresponding to the KitWebView
func (webView *WebView) PageID() uint64 {
	var _arg0 *C.WebKitWebView // out
	var _cret C.guint64        // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_page_id(_arg0)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// SessionState gets the current session state of web_view
func (webView *WebView) SessionState() *WebViewSessionState {
	var _arg0 *C.WebKitWebView             // out
	var _cret *C.WebKitWebViewSessionState // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_session_state(_arg0)

	var _webViewSessionState *WebViewSessionState // out

	_webViewSessionState = (*WebViewSessionState)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.webkit_web_view_session_state_ref(_cret)
	runtime.SetFinalizer(_webViewSessionState, func(v *WebViewSessionState) {
		C.webkit_web_view_session_state_unref((*C.WebKitWebViewSessionState)(gextras.StructNative(unsafe.Pointer(v))))
	})

	return _webViewSessionState
}

// Settings gets the KitSettings currently applied to web_view. If no other
// KitSettings have been explicitly applied to web_view with
// webkit_web_view_set_settings(), the default KitSettings will be returned.
// This method always returns a valid KitSettings object. To modify any of the
// web_view settings, you can either create a new KitSettings object with
// webkit_settings_new(), setting the desired preferences, and then replace the
// existing web_view settings with webkit_web_view_set_settings() or get the
// existing web_view settings and update it directly. KitSettings objects can be
// shared by multiple KitWebView<!-- -->s, so modifying the settings of a
// KitWebView would affect other KitWebView<!-- -->s using the same KitSettings.
func (webView *WebView) Settings() *Settings {
	var _arg0 *C.WebKitWebView  // out
	var _cret *C.WebKitSettings // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_settings(_arg0)

	var _settings *Settings // out

	_settings = wrapSettings(externglib.Take(unsafe.Pointer(_cret)))

	return _settings
}

// Snapshot: asynchronously retrieves a snapshot of web_view for region. options
// specifies how the snapshot should be rendered.
//
// When the operation is finished, callback will be called. You must call
// webkit_web_view_get_snapshot_finish() to get the result of the operation.
func (webView *WebView) Snapshot(ctx context.Context, region SnapshotRegion, options SnapshotOptions, callback gio.AsyncReadyCallback) {
	var _arg0 *C.WebKitWebView        // out
	var _arg3 *C.GCancellable         // out
	var _arg1 C.WebKitSnapshotRegion  // out
	var _arg2 C.WebKitSnapshotOptions // out
	var _arg4 C.GAsyncReadyCallback   // out
	var _arg5 C.gpointer

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.WebKitSnapshotRegion(region)
	_arg2 = C.WebKitSnapshotOptions(options)
	_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg5 = C.gpointer(gbox.AssignOnce(callback))

	C.webkit_web_view_get_snapshot(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

// SnapshotFinish finishes an asynchronous operation started with
// webkit_web_view_get_snapshot().
func (webView *WebView) SnapshotFinish(result gio.AsyncResulter) (*cairo.Surface, error) {
	var _arg0 *C.WebKitWebView   // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.cairo_surface_t // in
	var _cerr *C.GError          // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((result).(gextras.Nativer).Native()))

	_cret = C.webkit_web_view_get_snapshot_finish(_arg0, _arg1, &_cerr)

	var _surface *cairo.Surface // out
	var _goerr error            // out

	_surface = cairo.WrapSurface(uintptr(unsafe.Pointer(_cret)))
	C.cairo_surface_reference(_cret)
	runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
		C.cairo_surface_destroy((*C.cairo_surface_t)(unsafe.Pointer(v.Native())))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _surface, _goerr
}

// Title gets the value of the KitWebView:title property. You can connect to
// notify::title signal of web_view to be notified when the title has been
// received.
func (webView *WebView) Title() string {
	var _arg0 *C.WebKitWebView // out
	var _cret *C.gchar         // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_title(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TLSInfo retrieves the Certificate associated with the main resource of
// web_view, and the CertificateFlags showing what problems, if any, have been
// found with that certificate. If the connection is not HTTPS, this function
// returns FALSE. This function should be called after a response has been
// received from the server, so you can connect to KitWebView::load-changed and
// call this function when it's emitted with WEBKIT_LOAD_COMMITTED event.
//
// Note that this function provides no information about the security of the web
// page if the current KitTLSErrorsPolicy is WEBKIT_TLS_ERRORS_POLICY_IGNORE, as
// subresources of the page may be controlled by an attacker. This function may
// safely be used to determine the security status of the current page only if
// the current KitTLSErrorsPolicy is WEBKIT_TLS_ERRORS_POLICY_FAIL, in which
// case subresources that fail certificate verification will be blocked.
func (webView *WebView) TLSInfo() (gio.TLSCertificater, gio.TLSCertificateFlags, bool) {
	var _arg0 *C.WebKitWebView       // out
	var _arg1 *C.GTlsCertificate     // in
	var _arg2 C.GTlsCertificateFlags // in
	var _cret C.gboolean             // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_tls_info(_arg0, &_arg1, &_arg2)

	var _certificate gio.TLSCertificater // out
	var _errors gio.TLSCertificateFlags  // out
	var _ok bool                         // out

	_certificate = (gextras.CastObject(externglib.Take(unsafe.Pointer(_arg1)))).(gio.TLSCertificater)
	_errors = gio.TLSCertificateFlags(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _certificate, _errors, _ok
}

// URI returns the current active URI of web_view. The active URI might change
// during a load operation:
//
// <orderedlist> <listitem><para> When nothing has been loaded yet on web_view
// the active URI is NULL. </para></listitem> <listitem><para> When a new load
// operation starts the active URI is the requested URI: <itemizedlist>
// <listitem><para> If the load operation was started by
// webkit_web_view_load_uri(), the requested URI is the given one.
// </para></listitem> <listitem><para> If the load operation was started by
// webkit_web_view_load_html(), the requested URI is "about:blank".
// </para></listitem> <listitem><para> If the load operation was started by
// webkit_web_view_load_alternate_html(), the requested URI is content URI
// provided. </para></listitem> <listitem><para> If the load operation was
// started by webkit_web_view_go_back() or webkit_web_view_go_forward(), the
// requested URI is the original URI of the previous/next item in the
// KitBackForwardList of web_view. </para></listitem> <listitem><para> If the
// load operation was started by webkit_web_view_go_to_back_forward_list_item(),
// the requested URI is the opriginal URI of the given KitBackForwardListItem.
// </para></listitem> </itemizedlist> </para></listitem> <listitem><para> If
// there is a server redirection during the load operation, the active URI is
// the redirected URI. When the signal KitWebView::load-changed is emitted with
// WEBKIT_LOAD_REDIRECTED event, the active URI is already updated to the
// redirected URI. </para></listitem> <listitem><para> When the signal
// KitWebView::load-changed is emitted with WEBKIT_LOAD_COMMITTED event, the
// active URI is the final one and it will not change unless a new load
// operation is started or a navigation action within the same page is
// performed. </para></listitem> </orderedlist>
//
// You can monitor the active URI by connecting to the notify::uri signal of
// web_view.
func (webView *WebView) URI() string {
	var _arg0 *C.WebKitWebView // out
	var _cret *C.gchar         // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_uri(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// UserContentManager gets the user content manager associated to web_view.
func (webView *WebView) UserContentManager() *UserContentManager {
	var _arg0 *C.WebKitWebView            // out
	var _cret *C.WebKitUserContentManager // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_user_content_manager(_arg0)

	var _userContentManager *UserContentManager // out

	_userContentManager = wrapUserContentManager(externglib.Take(unsafe.Pointer(_cret)))

	return _userContentManager
}

// WebsiteDataManager: get the KitWebsiteDataManager associated to web_view. If
// web_view is not ephemeral, the returned KitWebsiteDataManager will be the
// same as the KitWebsiteDataManager of web_view's KitWebContext.
func (webView *WebView) WebsiteDataManager() *WebsiteDataManager {
	var _arg0 *C.WebKitWebView            // out
	var _cret *C.WebKitWebsiteDataManager // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_website_data_manager(_arg0)

	var _websiteDataManager *WebsiteDataManager // out

	_websiteDataManager = wrapWebsiteDataManager(externglib.Take(unsafe.Pointer(_cret)))

	return _websiteDataManager
}

// WebsitePolicies gets the default website policies set on construction in the
// web_view. These can be overridden on a per-origin basis via the
// KitWebView::decide-policy signal handler.
//
// See also webkit_policy_decision_use_with_policies().
func (webView *WebView) WebsitePolicies() *WebsitePolicies {
	var _arg0 *C.WebKitWebView         // out
	var _cret *C.WebKitWebsitePolicies // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_website_policies(_arg0)

	var _websitePolicies *WebsitePolicies // out

	_websitePolicies = wrapWebsitePolicies(externglib.Take(unsafe.Pointer(_cret)))

	return _websitePolicies
}

// WindowProperties: get the KitWindowProperties object containing the
// properties that the window containing web_view should have.
func (webView *WebView) WindowProperties() *WindowProperties {
	var _arg0 *C.WebKitWebView          // out
	var _cret *C.WebKitWindowProperties // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_window_properties(_arg0)

	var _windowProperties *WindowProperties // out

	_windowProperties = wrapWindowProperties(externglib.Take(unsafe.Pointer(_cret)))

	return _windowProperties
}

// ZoomLevel: get the zoom level of web_view, i.e. the factor by which the view
// contents are scaled with respect to their original size.
func (webView *WebView) ZoomLevel() float64 {
	var _arg0 *C.WebKitWebView // out
	var _cret C.gdouble        // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_get_zoom_level(_arg0)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// GoBack loads the previous history item. You can monitor the load operation by
// connecting to KitWebView::load-changed signal.
func (webView *WebView) GoBack() {
	var _arg0 *C.WebKitWebView // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	C.webkit_web_view_go_back(_arg0)
}

// GoForward loads the next history item. You can monitor the load operation by
// connecting to KitWebView::load-changed signal.
func (webView *WebView) GoForward() {
	var _arg0 *C.WebKitWebView // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	C.webkit_web_view_go_forward(_arg0)
}

// GoToBackForwardListItem loads the specific history item list_item. You can
// monitor the load operation by connecting to KitWebView::load-changed signal.
func (webView *WebView) GoToBackForwardListItem(listItem *BackForwardListItem) {
	var _arg0 *C.WebKitWebView             // out
	var _arg1 *C.WebKitBackForwardListItem // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.WebKitBackForwardListItem)(unsafe.Pointer(listItem.Native()))

	C.webkit_web_view_go_to_back_forward_list_item(_arg0, _arg1)
}

// IsControlledByAutomation: get whether a KitWebView was created with
// KitWebView:is-controlled-by-automation property enabled. Only KitWebView<!--
// -->s controlled by automation can be used in an automation session.
func (webView *WebView) IsControlledByAutomation() bool {
	var _arg0 *C.WebKitWebView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_is_controlled_by_automation(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (webView *WebView) IsEditable() bool {
	var _arg0 *C.WebKitWebView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_is_editable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEphemeral: get whether a KitWebView is ephemeral. To create an ephemeral
// KitWebView you need to use g_object_new() and pass is-ephemeral property with
// TRUE value. See KitWebView:is-ephemeral for more details. If web_view was
// created with a ephemeral KitWebView:related-view or an ephemeral
// KitWebView:web-context it will also be ephemeral.
func (webView *WebView) IsEphemeral() bool {
	var _arg0 *C.WebKitWebView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_is_ephemeral(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsLoading gets the value of the KitWebView:is-loading property. You can
// monitor when a KitWebView is loading a page by connecting to
// notify::is-loading signal of web_view. This is useful when you are
// interesting in knowing when the view is loading something but not in the
// details about the status of the load operation, for example to start a
// spinner when the view is loading a page and stop it when it finishes.
func (webView *WebView) IsLoading() bool {
	var _arg0 *C.WebKitWebView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_is_loading(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsPlayingAudio gets the value of the KitWebView:is-playing-audio property.
// You can monitor when a page in a KitWebView is playing audio by connecting to
// the notify::is-playing-audio signal of web_view. This is useful when the
// application wants to provide visual feedback when a page is producing sound.
func (webView *WebView) IsPlayingAudio() bool {
	var _arg0 *C.WebKitWebView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	_cret = C.webkit_web_view_is_playing_audio(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LoadAlternateHtml: load the given content string for the URI content_uri.
// This allows clients to display page-loading errors in the KitWebView itself.
// When this method is called from KitWebView::load-failed signal to show an
// error page, then the back-forward list is maintained appropriately. For
// everything else this method works the same way as
// webkit_web_view_load_html().
func (webView *WebView) LoadAlternateHtml(content string, contentUri string, baseUri string) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _arg3 *C.gchar         // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(content)))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(contentUri)))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(baseUri)))

	C.webkit_web_view_load_alternate_html(_arg0, _arg1, _arg2, _arg3)
}

// LoadHtml: load the given content string with the specified base_uri. If
// base_uri is not NULL, relative URLs in the content will be resolved against
// base_uri and absolute local paths must be children of the base_uri. For
// security reasons absolute local paths that are not children of base_uri will
// cause the web process to terminate. If you need to include URLs in content
// that are local paths in a different directory than base_uri you can build a
// data URI for them. When base_uri is NULL, it defaults to "about:blank". The
// mime type of the document will be "text/html". You can monitor the load
// operation by connecting to KitWebView::load-changed signal.
func (webView *WebView) LoadHtml(content string, baseUri string) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(content)))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(baseUri)))

	C.webkit_web_view_load_html(_arg0, _arg1, _arg2)
}

// LoadPlainText: load the specified plain_text string into web_view. The mime
// type of document will be "text/plain". You can monitor the load operation by
// connecting to KitWebView::load-changed signal.
func (webView *WebView) LoadPlainText(plainText string) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(plainText)))

	C.webkit_web_view_load_plain_text(_arg0, _arg1)
}

// LoadRequest requests loading of the specified KitURIRequest. You can monitor
// the load operation by connecting to KitWebView::load-changed signal.
func (webView *WebView) LoadRequest(request *URIRequest) {
	var _arg0 *C.WebKitWebView    // out
	var _arg1 *C.WebKitURIRequest // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.WebKitURIRequest)(unsafe.Pointer(request.Native()))

	C.webkit_web_view_load_request(_arg0, _arg1)
}

// LoadURI requests loading of the specified URI string. You can monitor the
// load operation by connecting to KitWebView::load-changed signal.
func (webView *WebView) LoadURI(uri string) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))

	C.webkit_web_view_load_uri(_arg0, _arg1)
}

// Reload reloads the current contents of web_view. See also
// webkit_web_view_reload_bypass_cache().
func (webView *WebView) Reload() {
	var _arg0 *C.WebKitWebView // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	C.webkit_web_view_reload(_arg0)
}

// ReloadBypassCache reloads the current contents of web_view without using any
// cached data.
func (webView *WebView) ReloadBypassCache() {
	var _arg0 *C.WebKitWebView // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	C.webkit_web_view_reload_bypass_cache(_arg0)
}

// RestoreSessionState: restore the web_view session state from state
func (webView *WebView) RestoreSessionState(state *WebViewSessionState) {
	var _arg0 *C.WebKitWebView             // out
	var _arg1 *C.WebKitWebViewSessionState // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.WebKitWebViewSessionState)(gextras.StructNative(unsafe.Pointer(state)))

	C.webkit_web_view_restore_session_state(_arg0, _arg1)
}

// RunJavascript: asynchronously run script in the context of the current page
// in web_view. If WebKitSettings:enable-javascript is FALSE, this method will
// do nothing.
//
// When the operation is finished, callback will be called. You can then call
// webkit_web_view_run_javascript_finish() to get the result of the operation.
func (webView *WebView) RunJavascript(ctx context.Context, script string, callback gio.AsyncReadyCallback) {
	var _arg0 *C.WebKitWebView      // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(script)))
	_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg4 = C.gpointer(gbox.AssignOnce(callback))

	C.webkit_web_view_run_javascript(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// RunJavascriptFinish: finish an asynchronous operation started with
// webkit_web_view_run_javascript().
//
// This is an example of using webkit_web_view_run_javascript() with a script
// returning a string:
//
// <informalexample><programlisting> static void web_view_javascript_finished
// (GObject *object, GAsyncResult *result, gpointer user_data) {
// WebKitJavascriptResult *js_result; JSCValue *value; GError *error = NULL;
//
//    js_result = webkit_web_view_run_javascript_finish (WEBKIT_WEB_VIEW (object), result, &error);
//    if (!js_result) {
//        g_warning ("Error running javascript: s", error->message);
//        g_error_free (error);
//        return;
//    }
//
//    value = webkit_javascript_result_get_js_value (js_result);
//    if (jsc_value_is_string (value)) {
//        JSCException *exception;
//        gchar        *str_value;
//
//        str_value = jsc_value_to_string (value);
//        exception = jsc_context_get_exception (jsc_value_get_context (value));
//        if (exception)
//            g_warning ("Error running javascript: s", jsc_exception_get_message (exception));
//        else
//            g_print ("Script result: s\n", str_value);
//        g_free (str_value);
//    } else {
//        g_warning ("Error running javascript: unexpected return value");
//    }
//    webkit_javascript_result_unref (js_result);
//
// }
//
// static void web_view_get_link_url (WebKitWebView *web_view, const gchar
// *link_id) { gchar *script;
//
//    script = g_strdup_printf ("window.document.getElementById('s').href;", link_id);
//    webkit_web_view_run_javascript (web_view, script, NULL, web_view_javascript_finished, NULL);
//    g_free (script);
//
// } </programlisting></informalexample>
func (webView *WebView) RunJavascriptFinish(result gio.AsyncResulter) (*JavascriptResult, error) {
	var _arg0 *C.WebKitWebView          // out
	var _arg1 *C.GAsyncResult           // out
	var _cret *C.WebKitJavascriptResult // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((result).(gextras.Nativer).Native()))

	_cret = C.webkit_web_view_run_javascript_finish(_arg0, _arg1, &_cerr)

	var _javascriptResult *JavascriptResult // out
	var _goerr error                        // out

	_javascriptResult = (*JavascriptResult)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.webkit_javascript_result_ref(_cret)
	runtime.SetFinalizer(_javascriptResult, func(v *JavascriptResult) {
		C.webkit_javascript_result_unref((*C.WebKitJavascriptResult)(gextras.StructNative(unsafe.Pointer(v))))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _javascriptResult, _goerr
}

// RunJavascriptFromGresource: asynchronously run the script from resource in
// the context of the current page in web_view.
//
// When the operation is finished, callback will be called. You can then call
// webkit_web_view_run_javascript_from_gresource_finish() to get the result of
// the operation.
func (webView *WebView) RunJavascriptFromGresource(ctx context.Context, resource string, callback gio.AsyncReadyCallback) {
	var _arg0 *C.WebKitWebView      // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(resource)))
	_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg4 = C.gpointer(gbox.AssignOnce(callback))

	C.webkit_web_view_run_javascript_from_gresource(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// RunJavascriptFromGresourceFinish: finish an asynchronous operation started
// with webkit_web_view_run_javascript_from_gresource().
//
// Check webkit_web_view_run_javascript_finish() for a usage example.
func (webView *WebView) RunJavascriptFromGresourceFinish(result gio.AsyncResulter) (*JavascriptResult, error) {
	var _arg0 *C.WebKitWebView          // out
	var _arg1 *C.GAsyncResult           // out
	var _cret *C.WebKitJavascriptResult // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((result).(gextras.Nativer).Native()))

	_cret = C.webkit_web_view_run_javascript_from_gresource_finish(_arg0, _arg1, &_cerr)

	var _javascriptResult *JavascriptResult // out
	var _goerr error                        // out

	_javascriptResult = (*JavascriptResult)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.webkit_javascript_result_ref(_cret)
	runtime.SetFinalizer(_javascriptResult, func(v *JavascriptResult) {
		C.webkit_javascript_result_unref((*C.WebKitJavascriptResult)(gextras.StructNative(unsafe.Pointer(v))))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _javascriptResult, _goerr
}

// RunJavascriptInWorld: asynchronously run script in the script world with name
// world_name of the current page context in web_view. If
// WebKitSettings:enable-javascript is FALSE, this method will do nothing.
//
// When the operation is finished, callback will be called. You can then call
// webkit_web_view_run_javascript_in_world_finish() to get the result of the
// operation.
func (webView *WebView) RunJavascriptInWorld(ctx context.Context, script string, worldName string, callback gio.AsyncReadyCallback) {
	var _arg0 *C.WebKitWebView      // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg2 *C.gchar              // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(script)))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(worldName)))
	_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg5 = C.gpointer(gbox.AssignOnce(callback))

	C.webkit_web_view_run_javascript_in_world(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

// RunJavascriptInWorldFinish: finish an asynchronous operation started with
// webkit_web_view_run_javascript_in_world().
func (webView *WebView) RunJavascriptInWorldFinish(result gio.AsyncResulter) (*JavascriptResult, error) {
	var _arg0 *C.WebKitWebView          // out
	var _arg1 *C.GAsyncResult           // out
	var _cret *C.WebKitJavascriptResult // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((result).(gextras.Nativer).Native()))

	_cret = C.webkit_web_view_run_javascript_in_world_finish(_arg0, _arg1, &_cerr)

	var _javascriptResult *JavascriptResult // out
	var _goerr error                        // out

	_javascriptResult = (*JavascriptResult)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.webkit_javascript_result_ref(_cret)
	runtime.SetFinalizer(_javascriptResult, func(v *JavascriptResult) {
		C.webkit_javascript_result_unref((*C.WebKitJavascriptResult)(gextras.StructNative(unsafe.Pointer(v))))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _javascriptResult, _goerr
}

// Save: asynchronously save the current web page associated to the KitWebView
// into a self-contained format using the mode specified in save_mode.
//
// When the operation is finished, callback will be called. You can then call
// webkit_web_view_save_finish() to get the result of the operation.
func (webView *WebView) Save(ctx context.Context, saveMode SaveMode, callback gio.AsyncReadyCallback) {
	var _arg0 *C.WebKitWebView      // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.WebKitSaveMode      // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.WebKitSaveMode(saveMode)
	_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg4 = C.gpointer(gbox.AssignOnce(callback))

	C.webkit_web_view_save(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// SaveFinish: finish an asynchronous operation started with
// webkit_web_view_save().
func (webView *WebView) SaveFinish(result gio.AsyncResulter) (gio.InputStreamer, error) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.GInputStream  // in
	var _cerr *C.GError        // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((result).(gextras.Nativer).Native()))

	_cret = C.webkit_web_view_save_finish(_arg0, _arg1, &_cerr)

	var _inputStream gio.InputStreamer // out
	var _goerr error                   // out

	_inputStream = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(gio.InputStreamer)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _inputStream, _goerr
}

// SaveToFile: asynchronously save the current web page associated to the
// KitWebView into a self-contained format using the mode specified in save_mode
// and writing it to file.
//
// When the operation is finished, callback will be called. You can then call
// webkit_web_view_save_to_file_finish() to get the result of the operation.
func (webView *WebView) SaveToFile(ctx context.Context, file gio.Filer, saveMode SaveMode, callback gio.AsyncReadyCallback) {
	var _arg0 *C.WebKitWebView      // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.GFile              // out
	var _arg2 C.WebKitSaveMode      // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GFile)(unsafe.Pointer((file).(gextras.Nativer).Native()))
	_arg2 = C.WebKitSaveMode(saveMode)
	_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg5 = C.gpointer(gbox.AssignOnce(callback))

	C.webkit_web_view_save_to_file(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

// SaveToFileFinish: finish an asynchronous operation started with
// webkit_web_view_save_to_file().
func (webView *WebView) SaveToFileFinish(result gio.AsyncResulter) error {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.GAsyncResult  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((result).(gextras.Nativer).Native()))

	C.webkit_web_view_save_to_file_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SendMessageToPage: send message to the KitWebPage corresponding to web_view.
// If message is floating, it's consumed.
//
// If you don't expect any reply, or you simply want to ignore it, you can pass
// NULL as callback. When the operation is finished, callback will be called.
// You can then call webkit_web_view_send_message_to_page_finish() to get the
// message reply.
func (webView *WebView) SendMessageToPage(ctx context.Context, message *UserMessage, callback gio.AsyncReadyCallback) {
	var _arg0 *C.WebKitWebView      // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.WebKitUserMessage  // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.WebKitUserMessage)(unsafe.Pointer(message.Native()))
	_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg4 = C.gpointer(gbox.AssignOnce(callback))

	C.webkit_web_view_send_message_to_page(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// SendMessageToPageFinish: finish an asynchronous operation started with
// webkit_web_view_send_message_to_page().
func (webView *WebView) SendMessageToPageFinish(result gio.AsyncResulter) (*UserMessage, error) {
	var _arg0 *C.WebKitWebView     // out
	var _arg1 *C.GAsyncResult      // out
	var _cret *C.WebKitUserMessage // in
	var _cerr *C.GError            // in

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((result).(gextras.Nativer).Native()))

	_cret = C.webkit_web_view_send_message_to_page_finish(_arg0, _arg1, &_cerr)

	var _userMessage *UserMessage // out
	var _goerr error              // out

	_userMessage = wrapUserMessage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _userMessage, _goerr
}

// SetBackgroundColor sets the color that will be used to draw the web_view
// background before the actual contents are rendered. Note that if the web page
// loaded in web_view specifies a background color, it will take precedence over
// the rgba color. By default the web_view background color is opaque white.
// Note that the parent window must have a RGBA visual and Widget:app-paintable
// property set to TRUE for backgrounds colors to work.
//
// <informalexample><programlisting> static void
// browser_window_set_background_color (BrowserWindow *window, const GdkRGBA
// *rgba) { WebKitWebView *web_view; GdkScreen *screen = gtk_window_get_screen
// (GTK_WINDOW (window)); GdkVisual *rgba_visual = gdk_screen_get_rgba_visual
// (screen);
//
//    if (!rgba_visual)
//         return;
//
//    gtk_widget_set_visual (GTK_WIDGET (window), rgba_visual);
//    gtk_widget_set_app_paintable (GTK_WIDGET (window), TRUE);
//
//    web_view = browser_window_get_web_view (window);
//    webkit_web_view_set_background_color (web_view, rgba);
//
// } </programlisting></informalexample>
func (webView *WebView) SetBackgroundColor(rgba *gdk.RGBA) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.GdkRGBA       // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(rgba)))

	C.webkit_web_view_set_background_color(_arg0, _arg1)
}

// SetCustomCharset sets the current custom character encoding override of
// web_view. The custom character encoding will override any text encoding
// detected via HTTP headers or META tags. Calling this method will stop any
// current load operation and reload the current page. Setting the custom
// character encoding to NULL removes the character encoding override.
func (webView *WebView) SetCustomCharset(charset string) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(charset)))

	C.webkit_web_view_set_custom_charset(_arg0, _arg1)
}

// SetEditable sets whether the user is allowed to edit the HTML document.
//
// If editable is TRUE, web_view allows the user to edit the HTML document. If
// editable is FALSE, an element in web_view's document can only be edited if
// the CONTENTEDITABLE attribute has been set on the element or one of its
// parent elements. By default a KitWebView is not editable.
//
// Normally, a HTML document is not editable unless the elements within the
// document are editable. This function provides a way to make the contents of a
// KitWebView editable without altering the document or DOM structure.
func (webView *WebView) SetEditable(editable bool) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	if editable {
		_arg1 = C.TRUE
	}

	C.webkit_web_view_set_editable(_arg0, _arg1)
}

// SetInputMethodContext: set the KitInputMethodContext to be used by web_view,
// or NULL to not use any input method. Note that the same KitInputMethodContext
// can't be set on more than one KitWebView at the same time.
func (webView *WebView) SetInputMethodContext(context InputMethodContexter) {
	var _arg0 *C.WebKitWebView            // out
	var _arg1 *C.WebKitInputMethodContext // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.WebKitInputMethodContext)(unsafe.Pointer((context).(gextras.Nativer).Native()))

	C.webkit_web_view_set_input_method_context(_arg0, _arg1)
}

// SetIsMuted sets the mute state of web_view.
func (webView *WebView) SetIsMuted(muted bool) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	if muted {
		_arg1 = C.TRUE
	}

	C.webkit_web_view_set_is_muted(_arg0, _arg1)
}

// SetSettings sets the KitSettings to be applied to web_view. The existing
// KitSettings of web_view will be replaced by settings. New settings are
// applied immediately on web_view. The same KitSettings object can be shared by
// multiple KitWebView<!-- -->s.
func (webView *WebView) SetSettings(settings *Settings) {
	var _arg0 *C.WebKitWebView  // out
	var _arg1 *C.WebKitSettings // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = (*C.WebKitSettings)(unsafe.Pointer(settings.Native()))

	C.webkit_web_view_set_settings(_arg0, _arg1)
}

// SetZoomLevel: set the zoom level of web_view, i.e. the factor by which the
// view contents are scaled with respect to their original size.
func (webView *WebView) SetZoomLevel(zoomLevel float64) {
	var _arg0 *C.WebKitWebView // out
	var _arg1 C.gdouble        // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))
	_arg1 = C.gdouble(zoomLevel)

	C.webkit_web_view_set_zoom_level(_arg0, _arg1)
}

// StopLoading stops any ongoing loading operation in web_view. This method does
// nothing if no content is being loaded. If there is a loading operation in
// progress, it will be cancelled and KitWebView::load-failed signal will be
// emitted with WEBKIT_NETWORK_ERROR_CANCELLED error.
func (webView *WebView) StopLoading() {
	var _arg0 *C.WebKitWebView // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	C.webkit_web_view_stop_loading(_arg0)
}

// TryClose tries to close the web_view. This will fire the onbeforeunload event
// to ask the user for confirmation to close the page. If there isn't an
// onbeforeunload event handler or the user confirms to close the page, the
// KitWebView::close signal is emitted, otherwise nothing happens.
func (webView *WebView) TryClose() {
	var _arg0 *C.WebKitWebView // out

	_arg0 = (*C.WebKitWebView)(unsafe.Pointer(webView.Native()))

	C.webkit_web_view_try_close(_arg0)
}
