// Code generated by girgen. DO NOT EDIT.

package webkit2

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: webkit2gtk-4.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <webkit2/webkit2.h>
// void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.webkit_tls_errors_policy_get_type()), F: marshalTLSErrorsPolicy},
		{T: externglib.Type(C.webkit_website_data_manager_get_type()), F: marshalWebsiteDataManagerer},
		{T: externglib.Type(C.webkit_itp_first_party_get_type()), F: marshalITPFirstParty},
		{T: externglib.Type(C.webkit_itp_third_party_get_type()), F: marshalITPThirdParty},
	})
}

// TLSErrorsPolicy: enum values used to denote the TLS errors policy.
type TLSErrorsPolicy int

const (
	// TLSErrorsPolicyIgnore: ignore TLS errors.
	TLSErrorsPolicyIgnore TLSErrorsPolicy = iota
	// TLSErrorsPolicyFail: TLS errors will emit
	// KitWebView::load-failed-with-tls-errors and, if the signal is handled,
	// finish the load. In case the signal is not handled,
	// KitWebView::load-failed is emitted before the load finishes.
	TLSErrorsPolicyFail
)

func marshalTLSErrorsPolicy(p uintptr) (interface{}, error) {
	return TLSErrorsPolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for TLSErrorsPolicy.
func (t TLSErrorsPolicy) String() string {
	switch t {
	case TLSErrorsPolicyIgnore:
		return "Ignore"
	case TLSErrorsPolicyFail:
		return "Fail"
	default:
		return fmt.Sprintf("TLSErrorsPolicy(%d)", t)
	}
}

type WebsiteDataManager struct {
	*externglib.Object
}

var _ gextras.Nativer = (*WebsiteDataManager)(nil)

func wrapWebsiteDataManager(obj *externglib.Object) *WebsiteDataManager {
	return &WebsiteDataManager{
		Object: obj,
	}
}

func marshalWebsiteDataManagerer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWebsiteDataManager(obj), nil
}

// NewWebsiteDataManagerEphemeral creates an ephemeral KitWebsiteDataManager.
// See KitWebsiteDataManager:is-ephemeral for more details.
func NewWebsiteDataManagerEphemeral() *WebsiteDataManager {
	var _cret *C.WebKitWebsiteDataManager // in

	_cret = C.webkit_website_data_manager_new_ephemeral()

	var _websiteDataManager *WebsiteDataManager // out

	_websiteDataManager = wrapWebsiteDataManager(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _websiteDataManager
}

// ClearFinish: finish an asynchronous operation started with
// webkit_website_data_manager_clear()
func (manager *WebsiteDataManager) ClearFinish(result gio.AsyncResulter) error {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _arg1 *C.GAsyncResult             // out
	var _cerr *C.GError                   // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((result).(gextras.Nativer).Native()))

	C.webkit_website_data_manager_clear_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// Fetch: asynchronously get the list of KitWebsiteData for the given types.
//
// When the operation is finished, callback will be called. You can then call
// webkit_website_data_manager_fetch_finish() to get the result of the
// operation.
func (manager *WebsiteDataManager) Fetch(types WebsiteDataTypes, cancellable *gio.Cancellable, callback gio.AsyncReadyCallback) {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _arg1 C.WebKitWebsiteDataTypes    // out
	var _arg2 *C.GCancellable             // out
	var _arg3 C.GAsyncReadyCallback       // out
	var _arg4 C.gpointer

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))
	_arg1 = C.WebKitWebsiteDataTypes(types)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg4 = C.gpointer(gbox.AssignOnce(callback))

	C.webkit_website_data_manager_fetch(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// BaseCacheDirectory: get the KitWebsiteDataManager:base-cache-directory
// property.
func (manager *WebsiteDataManager) BaseCacheDirectory() string {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _cret *C.gchar                    // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))

	_cret = C.webkit_website_data_manager_get_base_cache_directory(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// BaseDataDirectory: get the KitWebsiteDataManager:base-data-directory
// property.
func (manager *WebsiteDataManager) BaseDataDirectory() string {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _cret *C.gchar                    // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))

	_cret = C.webkit_website_data_manager_get_base_data_directory(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// CookieManager: get the KitCookieManager of manager.
func (manager *WebsiteDataManager) CookieManager() *CookieManager {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _cret *C.WebKitCookieManager      // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))

	_cret = C.webkit_website_data_manager_get_cookie_manager(_arg0)

	var _cookieManager *CookieManager // out

	_cookieManager = wrapCookieManager(externglib.Take(unsafe.Pointer(_cret)))

	return _cookieManager
}

// DiskCacheDirectory: get the KitWebsiteDataManager:disk-cache-directory
// property.
func (manager *WebsiteDataManager) DiskCacheDirectory() string {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _cret *C.gchar                    // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))

	_cret = C.webkit_website_data_manager_get_disk_cache_directory(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// DomCacheDirectory: get the KitWebsiteDataManager:dom-cache-directory
// property.
func (manager *WebsiteDataManager) DomCacheDirectory() string {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _cret *C.gchar                    // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))

	_cret = C.webkit_website_data_manager_get_dom_cache_directory(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// HstsCacheDirectory: get the KitWebsiteDataManager:hsts-cache-directory
// property.
func (manager *WebsiteDataManager) HstsCacheDirectory() string {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _cret *C.gchar                    // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))

	_cret = C.webkit_website_data_manager_get_hsts_cache_directory(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// IndexeddbDirectory: get the KitWebsiteDataManager:indexeddb-directory
// property.
func (manager *WebsiteDataManager) IndexeddbDirectory() string {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _cret *C.gchar                    // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))

	_cret = C.webkit_website_data_manager_get_indexeddb_directory(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// ItpDirectory: get the KitWebsiteDataManager:itp-directory property.
func (manager *WebsiteDataManager) ItpDirectory() string {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _cret *C.gchar                    // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))

	_cret = C.webkit_website_data_manager_get_itp_directory(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// ItpEnabled: get whether Intelligent Tracking Prevention (ITP) is enabled or
// not.
func (manager *WebsiteDataManager) ItpEnabled() bool {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))

	_cret = C.webkit_website_data_manager_get_itp_enabled(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ItpSummary: asynchronously get the list of KitITPThirdParty seen for manager.
// Every KitITPThirdParty contains the list of KitITPFirstParty under which it
// has been seen.
//
// When the operation is finished, callback will be called. You can then call
// webkit_website_data_manager_get_itp_summary_finish() to get the result of the
// operation.
func (manager *WebsiteDataManager) ItpSummary(cancellable *gio.Cancellable, callback gio.AsyncReadyCallback) {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _arg1 *C.GCancellable             // out
	var _arg2 C.GAsyncReadyCallback       // out
	var _arg3 C.gpointer

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg3 = C.gpointer(gbox.AssignOnce(callback))

	C.webkit_website_data_manager_get_itp_summary(_arg0, _arg1, _arg2, _arg3)
}

// LocalStorageDirectory: get the KitWebsiteDataManager:local-storage-directory
// property.
func (manager *WebsiteDataManager) LocalStorageDirectory() string {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _cret *C.gchar                    // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))

	_cret = C.webkit_website_data_manager_get_local_storage_directory(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// OfflineApplicationCacheDirectory: get the
// KitWebsiteDataManager:offline-application-cache-directory property.
func (manager *WebsiteDataManager) OfflineApplicationCacheDirectory() string {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _cret *C.gchar                    // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))

	_cret = C.webkit_website_data_manager_get_offline_application_cache_directory(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// PersistentCredentialStorageEnabled: get whether persistent credential storage
// is enabled or not. See also
// webkit_website_data_manager_set_persistent_credential_storage_enabled().
func (manager *WebsiteDataManager) PersistentCredentialStorageEnabled() bool {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))

	_cret = C.webkit_website_data_manager_get_persistent_credential_storage_enabled(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ServiceWorkerRegistrationsDirectory: get the
// KitWebsiteDataManager:service-worker-registrations-directory property.
func (manager *WebsiteDataManager) ServiceWorkerRegistrationsDirectory() string {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _cret *C.gchar                    // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))

	_cret = C.webkit_website_data_manager_get_service_worker_registrations_directory(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TLSErrorsPolicy: get the TLS errors policy of manager
func (manager *WebsiteDataManager) TLSErrorsPolicy() TLSErrorsPolicy {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _cret C.WebKitTLSErrorsPolicy     // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))

	_cret = C.webkit_website_data_manager_get_tls_errors_policy(_arg0)

	var _tlsErrorsPolicy TLSErrorsPolicy // out

	_tlsErrorsPolicy = TLSErrorsPolicy(_cret)

	return _tlsErrorsPolicy
}

// WebsqlDirectory: get the KitWebsiteDataManager:websql-directory property.
//
// Deprecated: WebSQL is no longer supported. Use IndexedDB instead.
func (manager *WebsiteDataManager) WebsqlDirectory() string {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _cret *C.gchar                    // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))

	_cret = C.webkit_website_data_manager_get_websql_directory(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// IsEphemeral: get whether a KitWebsiteDataManager is ephemeral. See
// KitWebsiteDataManager:is-ephemeral for more details.
func (manager *WebsiteDataManager) IsEphemeral() bool {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))

	_cret = C.webkit_website_data_manager_is_ephemeral(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveFinish: finish an asynchronous operation started with
// webkit_website_data_manager_remove().
func (manager *WebsiteDataManager) RemoveFinish(result gio.AsyncResulter) error {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _arg1 *C.GAsyncResult             // out
	var _cerr *C.GError                   // in

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((result).(gextras.Nativer).Native()))

	C.webkit_website_data_manager_remove_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SetItpEnabled: enable or disable Intelligent Tracking Prevention (ITP). When
// ITP is enabled resource load statistics are collected and used to decide
// whether to allow or block third-party cookies and prevent user tracking. Note
// that while ITP is enabled the accept policy
// WEBKIT_COOKIE_POLICY_ACCEPT_NO_THIRD_PARTY is ignored and
// WEBKIT_COOKIE_POLICY_ACCEPT_ALWAYS is used instead. See also
// webkit_cookie_manager_set_accept_policy().
func (manager *WebsiteDataManager) SetItpEnabled(enabled bool) {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _arg1 C.gboolean                  // out

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.webkit_website_data_manager_set_itp_enabled(_arg0, _arg1)
}

// SetNetworkProxySettings: set the network proxy settings to be used by
// connections started in manager session. By default
// WEBKIT_NETWORK_PROXY_MODE_DEFAULT is used, which means that the system
// settings will be used (g_proxy_resolver_get_default()). If you want to
// override the system default settings, you can either use
// WEBKIT_NETWORK_PROXY_MODE_NO_PROXY to make sure no proxies are used at all,
// or WEBKIT_NETWORK_PROXY_MODE_CUSTOM to provide your own proxy settings. When
// proxy_mode is WEBKIT_NETWORK_PROXY_MODE_CUSTOM proxy_settings must be a valid
// KitNetworkProxySettings; otherwise, proxy_settings must be NULL.
func (manager *WebsiteDataManager) SetNetworkProxySettings(proxyMode NetworkProxyMode, proxySettings *NetworkProxySettings) {
	var _arg0 *C.WebKitWebsiteDataManager   // out
	var _arg1 C.WebKitNetworkProxyMode      // out
	var _arg2 *C.WebKitNetworkProxySettings // out

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))
	_arg1 = C.WebKitNetworkProxyMode(proxyMode)
	_arg2 = (*C.WebKitNetworkProxySettings)(gextras.StructNative(unsafe.Pointer(proxySettings)))

	C.webkit_website_data_manager_set_network_proxy_settings(_arg0, _arg1, _arg2)
}

// SetPersistentCredentialStorageEnabled: enable or disable persistent
// credential storage. When enabled, which is the default for non-ephemeral
// sessions, the network process will try to read and write HTTP authentiacation
// credentials from persistent storage.
func (manager *WebsiteDataManager) SetPersistentCredentialStorageEnabled(enabled bool) {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _arg1 C.gboolean                  // out

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.webkit_website_data_manager_set_persistent_credential_storage_enabled(_arg0, _arg1)
}

// SetTLSErrorsPolicy: set the TLS errors policy of manager as policy
func (manager *WebsiteDataManager) SetTLSErrorsPolicy(policy TLSErrorsPolicy) {
	var _arg0 *C.WebKitWebsiteDataManager // out
	var _arg1 C.WebKitTLSErrorsPolicy     // out

	_arg0 = (*C.WebKitWebsiteDataManager)(unsafe.Pointer(manager.Native()))
	_arg1 = C.WebKitTLSErrorsPolicy(policy)

	C.webkit_website_data_manager_set_tls_errors_policy(_arg0, _arg1)
}

type ITPFirstParty struct {
	nocopy gextras.NoCopy
	native *C.WebKitITPFirstParty
}

func marshalITPFirstParty(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return &ITPFirstParty{native: (*C.WebKitITPFirstParty)(unsafe.Pointer(b))}, nil
}

// Domain: get the domain name of itp_first_party
func (itpFirstParty *ITPFirstParty) Domain() string {
	var _arg0 *C.WebKitITPFirstParty // out
	var _cret *C.char                // in

	_arg0 = (*C.WebKitITPFirstParty)(gextras.StructNative(unsafe.Pointer(itpFirstParty)))

	_cret = C.webkit_itp_first_party_get_domain(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// WebsiteDataAccessAllowed: get whether itp_first_party has granted website
// data access to its KitITPThirdParty. Each WebKitITPFirstParty is created by
// webkit_itp_third_party_get_first_parties() and therefore corresponds to
// exactly one KitITPThirdParty.
func (itpFirstParty *ITPFirstParty) WebsiteDataAccessAllowed() bool {
	var _arg0 *C.WebKitITPFirstParty // out
	var _cret C.gboolean             // in

	_arg0 = (*C.WebKitITPFirstParty)(gextras.StructNative(unsafe.Pointer(itpFirstParty)))

	_cret = C.webkit_itp_first_party_get_website_data_access_allowed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Ref: atomically increments the reference count of itp_first_party by one.
// This function is MT-safe and may be called from any thread.
func (itpFirstParty *ITPFirstParty) ref() *ITPFirstParty {
	var _arg0 *C.WebKitITPFirstParty // out
	var _cret *C.WebKitITPFirstParty // in

	_arg0 = (*C.WebKitITPFirstParty)(gextras.StructNative(unsafe.Pointer(itpFirstParty)))

	_cret = C.webkit_itp_first_party_ref(_arg0)

	var _itpFirstParty *ITPFirstParty // out

	_itpFirstParty = (*ITPFirstParty)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.webkit_itp_first_party_ref(_cret)
	runtime.SetFinalizer(_itpFirstParty, func(v *ITPFirstParty) {
		C.webkit_itp_first_party_unref((*C.WebKitITPFirstParty)(gextras.StructNative(unsafe.Pointer(v))))
	})

	return _itpFirstParty
}

// Unref: atomically decrements the reference count of itp_first_party by one.
// If the reference count drops to 0, all memory allocated by KitITPFirstParty
// is released. This function is MT-safe and may be called from any thread.
func (itpFirstParty *ITPFirstParty) unref() {
	var _arg0 *C.WebKitITPFirstParty // out

	_arg0 = (*C.WebKitITPFirstParty)(gextras.StructNative(unsafe.Pointer(itpFirstParty)))

	C.webkit_itp_first_party_unref(_arg0)
}

type ITPThirdParty struct {
	nocopy gextras.NoCopy
	native *C.WebKitITPThirdParty
}

func marshalITPThirdParty(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return &ITPThirdParty{native: (*C.WebKitITPThirdParty)(unsafe.Pointer(b))}, nil
}

// Domain: get the domain name of itp_third_party
func (itpThirdParty *ITPThirdParty) Domain() string {
	var _arg0 *C.WebKitITPThirdParty // out
	var _cret *C.char                // in

	_arg0 = (*C.WebKitITPThirdParty)(gextras.StructNative(unsafe.Pointer(itpThirdParty)))

	_cret = C.webkit_itp_third_party_get_domain(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Ref: atomically increments the reference count of itp_third_party by one.
// This function is MT-safe and may be called from any thread.
func (itpThirdParty *ITPThirdParty) ref() *ITPThirdParty {
	var _arg0 *C.WebKitITPThirdParty // out
	var _cret *C.WebKitITPThirdParty // in

	_arg0 = (*C.WebKitITPThirdParty)(gextras.StructNative(unsafe.Pointer(itpThirdParty)))

	_cret = C.webkit_itp_third_party_ref(_arg0)

	var _itpThirdParty *ITPThirdParty // out

	_itpThirdParty = (*ITPThirdParty)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.webkit_itp_third_party_ref(_cret)
	runtime.SetFinalizer(_itpThirdParty, func(v *ITPThirdParty) {
		C.webkit_itp_third_party_unref((*C.WebKitITPThirdParty)(gextras.StructNative(unsafe.Pointer(v))))
	})

	return _itpThirdParty
}

// Unref: atomically decrements the reference count of itp_third_party by one.
// If the reference count drops to 0, all memory allocated by KitITPThirdParty
// is released. This function is MT-safe and may be called from any thread.
func (itpThirdParty *ITPThirdParty) unref() {
	var _arg0 *C.WebKitITPThirdParty // out

	_arg0 = (*C.WebKitITPThirdParty)(gextras.StructNative(unsafe.Pointer(itpThirdParty)))

	C.webkit_itp_third_party_unref(_arg0)
}
